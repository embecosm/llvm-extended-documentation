This is llvm.info, produced by makeinfo version 6.0 from llvm.texi.

Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies published by
Embecosm support introducing others to free and open source software and
hardware.
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* llvm: (llvm).                The LLVM compiler
END-INFO-DIR-ENTRY

 This file documents the use of the LLVM compiler.

 Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies published by
Embecosm support introducing others to free and open source software and
hardware.


File: llvm.info,  Node: Asm Labels,  Next: Explicit Reg Vars,  Prev: Constraints,  Up: Using Assembly Language with C

6.43.4 Controlling Names Used in Assembler Code
-----------------------------------------------

You can specify the name to be used in the assembler code for a C
function or variable by writing the 'asm' (or '__asm__') keyword after
the declarator as follows:

     int foo asm ("myfoo") = 2;

This specifies that the name to be used for the variable 'foo' in the
assembler code should be 'myfoo' rather than the usual '_foo'.

 On systems where an underscore is normally prepended to the name of a C
function or variable, this feature allows you to define names for the
linker that do not start with an underscore.

 It does not make sense to use this feature with a non-static local
variable since such variables do not have assembler names.  If you are
trying to put the variable in a particular register, see *note Explicit
Reg Vars::.  GCC presently accepts such code with a warning, but will
probably be changed to issue an error, rather than a warning, in the
future.

 You cannot use 'asm' in this way in a function _definition_; but you
can get the same effect by writing a declaration for the function before
its definition and putting 'asm' there, like this:

     extern func () asm ("FUNC");

     func (x, y)
          int x, y;
     /* ... */

 It is up to you to make sure that the assembler names you choose do not
conflict with any other assembler symbols.  Also, you must not use a
register name; that would produce completely invalid assembler code.
GCC does not as yet have the ability to store static variables in
registers.  Perhaps that will be added.


File: llvm.info,  Node: Explicit Reg Vars,  Next: Size of an asm,  Prev: Asm Labels,  Up: Using Assembly Language with C

6.43.5 Variables in Specified Registers
---------------------------------------

GNU C allows you to put a few global variables into specified hardware
registers.  You can also specify the register in which an ordinary
register variable should be allocated.

   * Global register variables reserve registers throughout the program.
     This may be useful in programs such as programming language
     interpreters that have a couple of global variables that are
     accessed very often.

   * Local register variables in specific registers do not reserve the
     registers, except at the point where they are used as input or
     output operands in an 'asm' statement and the 'asm' statement
     itself is not deleted.  The compiler's data flow analysis is
     capable of determining where the specified registers contain live
     values, and where they are available for other uses.  Stores into
     local register variables may be deleted when they appear to be dead
     according to dataflow analysis.  References to local register
     variables may be deleted or moved or simplified.

     These local variables are sometimes convenient for use with the
     extended 'asm' feature (*note Extended Asm::), if you want to write
     one output of the assembler instruction directly into a particular
     register.  (This works provided the register you specify fits the
     constraints specified for that operand in the 'asm'.)

* Menu:

* Global Reg Vars::
* Local Reg Vars::


File: llvm.info,  Node: Global Reg Vars,  Next: Local Reg Vars,  Up: Explicit Reg Vars

6.43.5.1 Defining Global Register Variables
...........................................

You can define a global register variable in GNU C like this:

     register int *foo asm ("a5");

Here 'a5' is the name of the register that should be used.  Choose a
register that is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.

 Naturally the register name is CPU-dependent, so you need to
conditionalize your program according to CPU type.  The register 'a5' is
a good choice on a 68000 for a variable of pointer type.  On machines
with register windows, be sure to choose a "global" register that is not
affected magically by the function call mechanism.

 In addition, different operating systems on the same CPU may differ in
how they name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register '%a5'.

 Eventually there may be a way of asking the compiler to choose a
register automatically, but first we need to figure out how it should
choose and how to enable you to guide the choice.  No solution is
evident.

 Defining a global register variable in a certain register reserves that
register entirely for this use, at least within the current compilation.
The register is not allocated for any other purpose in the functions in
the current compilation, and is not saved and restored by these
functions.  Stores into this register are never deleted even if they
appear to be dead, but references may be deleted or moved or simplified.

 It is not safe to access the global register variables from signal
handlers, or from more than one thread of control, because the system
library routines may temporarily use the register for other things
(unless you recompile them specially for the task at hand).

 It is not safe for one function that uses a global register variable to
call another such function 'foo' by way of a third function 'lose' that
is compiled without knowledge of this variable (i.e. in a different
source file in which the variable isn't declared).  This is because
'lose' might save the register and put some other value there.  For
example, you can't expect a global register variable to be available in
the comparison-function that you pass to 'qsort', since 'qsort' might
have put something else in that register.  (If you are prepared to
recompile 'qsort' with the same global register variable, you can solve
this problem.)

 If you want to recompile 'qsort' or other source files that do not
actually use your global register variable, so that they do not use that
register for any other purpose, then it suffices to specify the compiler
option '-ffixed-REG'.  You need not actually add a global register
declaration to their source code.

 A function that can alter the value of a global register variable
cannot safely be called from a function compiled without this variable,
because it could clobber the value the caller expects to find there on
return.  Therefore, the function that is the entry point into the part
of the program that uses the global register variable must explicitly
save and restore the value that belongs to its caller.

 On most machines, 'longjmp' restores to each global register variable
the value it had at the time of the 'setjmp'.  On some machines,
however, 'longjmp' does not change the value of global register
variables.  To be portable, the function that called 'setjmp' should
make other arrangements to save the values of the global register
variables, and to restore them in a 'longjmp'.  This way, the same thing
happens regardless of what 'longjmp' does.

 All global register variable declarations must precede all function
definitions.  If such a declaration could appear after function
definitions, the declaration would be too late to prevent the register
from being used for other purposes in the preceding functions.

 Global register variables may not have initial values, because an
executable file has no means to supply initial contents for a register.

 On the SPARC, there are reports that g3 ... g7 are suitable registers,
but certain library functions, such as 'getwd', as well as the
subroutines for division and remainder, modify g3 and g4.  g1 and g2 are
local temporaries.

 On the 68000, a2 ... a5 should be suitable, as should d2 ... d7.  Of
course, it does not do to use more than a few of those.


File: llvm.info,  Node: Local Reg Vars,  Prev: Global Reg Vars,  Up: Explicit Reg Vars

6.43.5.2 Specifying Registers for Local Variables
.................................................

You can define a local register variable with a specified register like
this:

     register int *foo asm ("a5");

Here 'a5' is the name of the register that should be used.  Note that
this is the same syntax used for defining global register variables, but
for a local variable it appears within a function.

 Naturally the register name is CPU-dependent, but this is not a
problem, since specific registers are most often useful with explicit
assembler instructions (*note Extended Asm::).  Both of these things
generally require that you conditionalize your program according to CPU
type.

 In addition, operating systems on one type of CPU may differ in how
they name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register '%a5'.

 Defining such a register variable does not reserve the register; it
remains available for other uses in places where flow control determines
the variable's value is not live.

 This option does not guarantee that GCC generates code that has this
variable in the register you specify at all times.  You may not code an
explicit reference to this register in the assembler instruction
template part of an 'asm' statement and assume it always refers to this
variable.  However, using the variable as an input or output operand to
the 'asm' guarantees that the specified register is used for that
operand.  *Note Extended Asm::, for more information.

 Stores into local register variables may be deleted when they appear to
be dead according to dataflow analysis.  References to local register
variables may be deleted or moved or simplified.

 As with global register variables, it is recommended that you choose a
register that is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.

 Sometimes when writing inline 'asm' code, you need to make an operand
be a specific register, but there's no matching constraint letter for
that register.  To force the operand into that register, create a local
variable and specify the register in the variable's declaration.  Then
use the local variable for the asm operand and specify any constraint
letter that matches the register:

     register int *p1 asm ("r0") = ...;
     register int *p2 asm ("r1") = ...;
     register int *result asm ("r0");
     asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));

 _Warning:_ In the above example, be aware that a register (for example
r0) can be call-clobbered by subsequent code, including function calls
and library calls for arithmetic operators on other variables (for
example the initialization of p2).  In this case, use temporary
variables for expressions between the register assignments:

     int t1 = ...;
     register int *p1 asm ("r0") = ...;
     register int *p2 asm ("r1") = t1;
     register int *result asm ("r0");
     asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));


File: llvm.info,  Node: Size of an asm,  Prev: Explicit Reg Vars,  Up: Using Assembly Language with C

6.43.6 Size of an 'asm'
-----------------------

Some targets require that GCC track the size of each instruction used in
order to generate correct code.  Because the final length of the code
produced by an 'asm' statement is only known by the assembler, GCC must
make an estimate as to how big it will be.  It does this by counting the
number of instructions in the pattern of the 'asm' and multiplying that
by the length of the longest instruction supported by that processor.
(When working out the number of instructions, it assumes that any
occurrence of a newline or of whatever statement separator character is
supported by the assembler - typically ';' -- indicates the end of an
instruction.)

 Normally, GCC's estimate is adequate to ensure that correct code is
generated, but it is possible to confuse the compiler if you use pseudo
instructions or assembler macros that expand into multiple real
instructions, or if you use assembler directives that expand to more
space in the object file than is needed for a single instruction.  If
this happens then the assembler may produce a diagnostic saying that a
label is unreachable.


File: llvm.info,  Node: Alternate Keywords,  Next: Incomplete Enums,  Prev: Using Assembly Language with C,  Up: C Extensions

6.44 Alternate Keywords
=======================

'-ansi' and the various '-std' options disable certain keywords.  This
causes trouble when you want to use GNU C extensions, or a
general-purpose header file that should be usable by all programs,
including ISO C programs.  The keywords 'asm', 'typeof' and 'inline' are
not available in programs compiled with '-ansi' or '-std' (although
'inline' can be used in a program compiled with '-std=c99' or
'-std=c11').  The ISO C99 keyword 'restrict' is only available when
'-std=gnu99' (which will eventually be the default) or '-std=c99' (or
the equivalent '-std=iso9899:1999'), or an option for a later standard
version, is used.

 The way to solve these problems is to put '__' at the beginning and end
of each problematical keyword.  For example, use '__asm__' instead of
'asm', and '__inline__' instead of 'inline'.

 Other C compilers won't accept these alternative keywords; if you want
to compile with another compiler, you can define the alternate keywords
as macros to replace them with the customary keywords.  It looks like
this:

     #ifndef __GNUC__
     #define __asm__ asm
     #endif

 '-pedantic' and other options cause warnings for many GNU C extensions.
You can prevent such warnings within one expression by writing
'__extension__' before the expression.  '__extension__' has no effect
aside from this.


File: llvm.info,  Node: Incomplete Enums,  Next: Function Names,  Prev: Alternate Keywords,  Up: C Extensions

6.45 Incomplete 'enum' Types
============================

You can define an 'enum' tag without specifying its possible values.
This results in an incomplete type, much like what you get if you write
'struct foo' without describing the elements.  A later declaration that
does specify the possible values completes the type.

 You can't allocate variables or storage using the type while it is
incomplete.  However, you can work with pointers to that type.

 This extension may not be very useful, but it makes the handling of
'enum' more consistent with the way 'struct' and 'union' are handled.

 This extension is not supported by GNU C++.


File: llvm.info,  Node: Function Names,  Next: Return Address,  Prev: Incomplete Enums,  Up: C Extensions

6.46 Function Names as Strings
==============================

GCC provides three magic variables that hold the name of the current
function, as a string.  The first of these is '__func__', which is part
of the C99 standard:

 The identifier '__func__' is implicitly declared by the translator as
if, immediately following the opening brace of each function definition,
the declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing
function.  This name is the unadorned name of the function.

 '__FUNCTION__' is another name for '__func__', provided for backward
compatibility with old versions of GCC.

 In C, '__PRETTY_FUNCTION__' is yet another name for '__func__'.
However, in C++, '__PRETTY_FUNCTION__' contains the type signature of
the function as well as its bare name.  For example, this program:

     extern "C" {
     extern int printf (char *, ...);
     }

     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };

     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)

 These identifiers are variables, not preprocessor macros, and may not
be used to initialize 'char' arrays or be concatenated with other string
literals.


File: llvm.info,  Node: Return Address,  Next: Vector Extensions,  Prev: Function Names,  Up: C Extensions

6.47 Getting the Return or Frame Address of a Function
======================================================

These functions may be used to get information about the callers of a
function.

 -- Built-in Function: void * __builtin_return_address (unsigned int
          LEVEL)
     This function returns the return address of the current function,
     or of one of its callers.  The LEVEL argument is number of frames
     to scan up the call stack.  A value of '0' yields the return
     address of the current function, a value of '1' yields the return
     address of the caller of the current function, and so forth.  When
     inlining the expected behavior is that the function returns the
     address of the function that is returned to.  To work around this
     behavior use the 'noinline' function attribute.

     The LEVEL argument must be a constant integer.

     On some machines it may be impossible to determine the return
     address of any function other than the current one; in such cases,
     or when the top of the stack has been reached, this function
     returns '0' or a random value.  In addition,
     '__builtin_frame_address' may be used to determine if the top of
     the stack has been reached.

     Additional post-processing of the returned value may be needed, see
     '__builtin_extract_return_addr'.

     This function should only be used with a nonzero argument for
     debugging purposes.

 -- Built-in Function: void * __builtin_extract_return_addr (void *ADDR)
     The address as returned by '__builtin_return_address' may have to
     be fed through this function to get the actual encoded address.
     For example, on the 31-bit S/390 platform the highest bit has to be
     masked out, or on SPARC platforms an offset has to be added for the
     true next instruction to be executed.

     If no fixup is needed, this function simply passes through ADDR.

 -- Built-in Function: void * __builtin_frob_return_address (void *ADDR)
     This function does the reverse of '__builtin_extract_return_addr'.

 -- Built-in Function: void * __builtin_frame_address (unsigned int
          LEVEL)
     This function is similar to '__builtin_return_address', but it
     returns the address of the function frame rather than the return
     address of the function.  Calling '__builtin_frame_address' with a
     value of '0' yields the frame address of the current function, a
     value of '1' yields the frame address of the caller of the current
     function, and so forth.

     The frame is the area on the stack that holds local variables and
     saved registers.  The frame address is normally the address of the
     first word pushed on to the stack by the function.  However, the
     exact definition depends upon the processor and the calling
     convention.  If the processor has a dedicated frame pointer
     register, and the function has a frame, then
     '__builtin_frame_address' returns the value of the frame pointer
     register.

     On some machines it may be impossible to determine the frame
     address of any function other than the current one; in such cases,
     or when the top of the stack has been reached, this function
     returns '0' if the first frame pointer is properly initialized by
     the startup code.

     This function should only be used with a nonzero argument for
     debugging purposes.


File: llvm.info,  Node: Vector Extensions,  Next: Offsetof,  Prev: Return Address,  Up: C Extensions

6.48 Using Vector Instructions through Built-in Functions
=========================================================

On some targets, the instruction set contains SIMD vector instructions
which operate on multiple values contained in one large register at the
same time.  For example, on the x86 the MMX, 3DNow! and SSE extensions
can be used this way.

 The first step in using these extensions is to provide the necessary
data types.  This should be done using an appropriate 'typedef':

     typedef int v4si __attribute__ ((vector_size (16)));

The 'int' type specifies the base type, while the attribute specifies
the vector size for the variable, measured in bytes.  For example, the
declaration above causes the compiler to set the mode for the 'v4si'
type to be 16 bytes wide and divided into 'int' sized units.  For a
32-bit 'int' this means a vector of 4 units of 4 bytes, and the
corresponding mode of 'foo' is V4SI.

 The 'vector_size' attribute is only applicable to integral and float
scalars, although arrays, pointers, and function return values are
allowed in conjunction with this construct.  Only sizes that are a power
of two are currently allowed.

 All the basic integer types can be used as base types, both as signed
and as unsigned: 'char', 'short', 'int', 'long', 'long long'.  In
addition, 'float' and 'double' can be used to build floating-point
vector types.

 Specifying a combination that is not valid for the current architecture
causes GCC to synthesize the instructions using a narrower mode.  For
example, if you specify a variable of type 'V4SI' and your architecture
does not allow for this specific SIMD type, GCC produces code that uses
4 'SIs'.

 The types defined in this manner can be used with a subset of normal C
operations.  Currently, GCC allows using the following operators on
these types: '+, -, *, /, unary minus, ^, |, &, ~, %'.

 The operations behave like C++ 'valarrays'.  Addition is defined as the
addition of the corresponding elements of the operands.  For example, in
the code below, each of the 4 elements in A is added to the
corresponding 4 elements in B and the resulting vector is stored in C.

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a, b, c;

     c = a + b;

 Subtraction, multiplication, division, and the logical operations
operate in a similar manner.  Likewise, the result of using the unary
minus or complement operators on a vector type is a vector whose
elements are the negative or complemented values of the corresponding
elements in the operand.

 It is possible to use shifting operators '<<', '>>' on integer-type
vectors.  The operation is defined as following: '{a0, a1, ..., an} >>
{b0, b1, ..., bn} == {a0 >> b0, a1 >> b1, ..., an >> bn}'.  Vector
operands must have the same number of elements.

 For convenience, it is allowed to use a binary vector operation where
one operand is a scalar.  In that case the compiler transforms the
scalar operand into a vector where each element is the scalar from the
operation.  The transformation happens only if the scalar could be
safely converted to the vector-element type.  Consider the following
code.

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a, b, c;
     long l;

     a = b + 1;    /* a = b + {1,1,1,1}; */
     a = 2 * b;    /* a = {2,2,2,2} * b; */

     a = l + a;    /* Error, cannot convert long to int. */

 Vectors can be subscripted as if the vector were an array with the same
number of elements and base type.  Out of bound accesses invoke
undefined behavior at run time.  Warnings for out of bound accesses for
vector subscription can be enabled with '-Warray-bounds'.

 Vector comparison is supported with standard comparison operators: '==,
!=, <, <=, >, >='.  Comparison operands can be vector expressions of
integer-type or real-type.  Comparison between integer-type vectors and
real-type vectors are not supported.  The result of the comparison is a
vector of the same width and number of elements as the comparison
operands with a signed integral element type.

 Vectors are compared element-wise producing 0 when comparison is false
and -1 (constant of the appropriate type where all bits are set)
otherwise.  Consider the following example.

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a = {1,2,3,4};
     v4si b = {3,2,1,4};
     v4si c;

     c = a >  b;     /* The result would be {0, 0,-1, 0}  */
     c = a == b;     /* The result would be {0,-1, 0,-1}  */

 In C++, the ternary operator '?:' is available.  'a?b:c', where 'b' and
'c' are vectors of the same type and 'a' is an integer vector with the
same number of elements of the same size as 'b' and 'c', computes all
three arguments and creates a vector '{a[0]?b[0]:c[0], a[1]?b[1]:c[1],
...}'.  Note that unlike in OpenCL, 'a' is thus interpreted as 'a != 0'
and not 'a < 0'.  As in the case of binary operations, this syntax is
also accepted when one of 'b' or 'c' is a scalar that is then
transformed into a vector.  If both 'b' and 'c' are scalars and the type
of 'true?b:c' has the same size as the element type of 'a', then 'b' and
'c' are converted to a vector type whose elements have this type and
with the same number of elements as 'a'.

 In C++, the logic operators '!, &&, ||' are available for vectors.
'!v' is equivalent to 'v == 0', 'a && b' is equivalent to 'a!=0 & b!=0'
and 'a || b' is equivalent to 'a!=0 | b!=0'.  For mixed operations
between a scalar 's' and a vector 'v', 's && v' is equivalent to
's?v!=0:0' (the evaluation is short-circuit) and 'v && s' is equivalent
to 'v!=0 & (s?-1:0)'.

 Vector shuffling is available using functions '__builtin_shuffle (vec,
mask)' and '__builtin_shuffle (vec0, vec1, mask)'.  Both functions
construct a permutation of elements from one or two vectors and return a
vector of the same type as the input vector(s).  The MASK is an integral
vector with the same width (W) and element count (N) as the output
vector.

 The elements of the input vectors are numbered in memory ordering of
VEC0 beginning at 0 and VEC1 beginning at N.  The elements of MASK are
considered modulo N in the single-operand case and modulo 2*N in the
two-operand case.

 Consider the following example,

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a = {1,2,3,4};
     v4si b = {5,6,7,8};
     v4si mask1 = {0,1,1,3};
     v4si mask2 = {0,4,2,5};
     v4si res;

     res = __builtin_shuffle (a, mask1);       /* res is {1,2,2,4}  */
     res = __builtin_shuffle (a, b, mask2);    /* res is {1,5,3,6}  */

 Note that '__builtin_shuffle' is intentionally semantically compatible
with the OpenCL 'shuffle' and 'shuffle2' functions.

 You can declare variables and use them in function calls and returns,
as well as in assignments and some casts.  You can specify a vector type
as a return type for a function.  Vector types can also be used as
function arguments.  It is possible to cast from one vector type to
another, provided they are of the same size (in fact, you can also cast
vectors to and from other datatypes of the same size).

 You cannot operate between vectors of different lengths or different
signedness without a cast.


File: llvm.info,  Node: Offsetof,  Next: __sync Builtins,  Prev: Vector Extensions,  Up: C Extensions

6.49 Support for 'offsetof'
===========================

GCC implements for both C and C++ a syntactic extension to implement the
'offsetof' macro.

     primary:
             "__builtin_offsetof" "(" typename "," offsetof_member_designator ")"

     offsetof_member_designator:
               identifier
             | offsetof_member_designator "." identifier
             | offsetof_member_designator "[" expr "]"

 This extension is sufficient such that

     #define offsetof(TYPE, MEMBER)  __builtin_offsetof (TYPE, MEMBER)

is a suitable definition of the 'offsetof' macro.  In C++, TYPE may be
dependent.  In either case, MEMBER may consist of a single identifier,
or a sequence of member accesses and array references.


File: llvm.info,  Node: __sync Builtins,  Next: __atomic Builtins,  Prev: Offsetof,  Up: C Extensions

6.50 Legacy '__sync' Built-in Functions for Atomic Memory Access
================================================================

The following built-in functions are intended to be compatible with
those described in the 'Intel Itanium Processor-specific Application
Binary Interface', section 7.4.  As such, they depart from the normal
GCC practice of using the '__builtin_' prefix, and further that they are
overloaded such that they work on multiple types.

 The definition given in the Intel documentation allows only for the use
of the types 'int', 'long', 'long long' as well as their unsigned
counterparts.  GCC allows any integral scalar or pointer type that is 1,
2, 4 or 8 bytes in length.

 Not all operations are supported by all target processors.  If a
particular operation cannot be implemented on the target processor, a
warning is generated and a call an external function is generated.  The
external function carries the same name as the built-in version, with an
additional suffix '_N' where N is the size of the data type.

 In most cases, these built-in functions are considered a "full
barrier".  That is, no memory operand is moved across the operation,
either forward or backward.  Further, instructions are issued as
necessary to prevent the processor from speculating loads across the
operation and from queuing stores after the operation.

 All of the routines are described in the Intel documentation to take
"an optional list of variables protected by the memory barrier".  It's
not clear what is meant by that; it could mean that _only_ the following
variables are protected, or it could mean that these variables should in
addition be protected.  At present GCC ignores this list and protects
all variables that are globally accessible.  If in the future we make
some use of this list, an empty list will continue to mean all globally
accessible variables.

'TYPE __sync_fetch_and_add (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_sub (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_or (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_and (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_xor (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_nand (TYPE *ptr, TYPE value, ...)'
     These built-in functions perform the operation suggested by the
     name, and returns the value that had previously been in memory.
     That is,

          { tmp = *ptr; *ptr OP= value; return tmp; }
          { tmp = *ptr; *ptr = ~(tmp & value); return tmp; }   // nand

     _Note:_ GCC 4.4 and later implement '__sync_fetch_and_nand' as
     '*ptr = ~(tmp & value)' instead of '*ptr = ~tmp & value'.

'TYPE __sync_add_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_sub_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_or_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_and_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_xor_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_nand_and_fetch (TYPE *ptr, TYPE value, ...)'
     These built-in functions perform the operation suggested by the
     name, and return the new value.  That is,

          { *ptr OP= value; return *ptr; }
          { *ptr = ~(*ptr & value); return *ptr; }   // nand

     _Note:_ GCC 4.4 and later implement '__sync_nand_and_fetch' as
     '*ptr = ~(*ptr & value)' instead of '*ptr = ~*ptr & value'.

'bool __sync_bool_compare_and_swap (TYPE *ptr, TYPE oldval, TYPE newval, ...)'
'TYPE __sync_val_compare_and_swap (TYPE *ptr, TYPE oldval, TYPE newval, ...)'
     These built-in functions perform an atomic compare and swap.  That
     is, if the current value of '*PTR' is OLDVAL, then write NEWVAL
     into '*PTR'.

     The "bool" version returns true if the comparison is successful and
     NEWVAL is written.  The "val" version returns the contents of
     '*PTR' before the operation.

'__sync_synchronize (...)'
     This built-in function issues a full memory barrier.

'TYPE __sync_lock_test_and_set (TYPE *ptr, TYPE value, ...)'
     This built-in function, as described by Intel, is not a traditional
     test-and-set operation, but rather an atomic exchange operation.
     It writes VALUE into '*PTR', and returns the previous contents of
     '*PTR'.

     Many targets have only minimal support for such locks, and do not
     support a full exchange operation.  In this case, a target may
     support reduced functionality here by which the _only_ valid value
     to store is the immediate constant 1.  The exact value actually
     stored in '*PTR' is implementation defined.

     This built-in function is not a full barrier, but rather an
     "acquire barrier".  This means that references after the operation
     cannot move to (or be speculated to) before the operation, but
     previous memory stores may not be globally visible yet, and
     previous memory loads may not yet be satisfied.

'void __sync_lock_release (TYPE *ptr, ...)'
     This built-in function releases the lock acquired by
     '__sync_lock_test_and_set'.  Normally this means writing the
     constant 0 to '*PTR'.

     This built-in function is not a full barrier, but rather a "release
     barrier".  This means that all previous memory stores are globally
     visible, and all previous memory loads have been satisfied, but
     following memory reads are not prevented from being speculated to
     before the barrier.


File: llvm.info,  Node: __atomic Builtins,  Next: Integer Overflow Builtins,  Prev: __sync Builtins,  Up: C Extensions

6.51 Built-in Functions for Memory Model Aware Atomic Operations
================================================================

The following built-in functions approximately match the requirements
for C++11 memory model.  Many are similar to the '__sync' prefixed
built-in functions, but all also have a memory model parameter.  These
are all identified by being prefixed with '__atomic', and most are
overloaded such that they work with multiple types.

 GCC allows any integral scalar or pointer type that is 1, 2, 4, or 8
bytes in length.  16-byte integral types are also allowed if '__int128'
(*note __int128::) is supported by the architecture.

 Target architectures are encouraged to provide their own patterns for
each of these built-in functions.  If no target is provided, the
original non-memory model set of '__sync' atomic built-in functions are
utilized, along with any required synchronization fences surrounding it
in order to achieve the proper behavior.  Execution in this case is
subject to the same restrictions as those built-in functions.

 If there is no pattern or mechanism to provide a lock free instruction
sequence, a call is made to an external routine with the same parameters
to be resolved at run time.

 The four non-arithmetic functions (load, store, exchange, and
compare_exchange) all have a generic version as well.  This generic
version works on any data type.  If the data type size maps to one of
the integral sizes that may have lock free support, the generic version
utilizes the lock free built-in function.  Otherwise an external call is
left to be resolved at run time.  This external call is the same format
with the addition of a 'size_t' parameter inserted as the first
parameter indicating the size of the object being pointed to.  All
objects must be the same size.

 There are 6 different memory models that can be specified.  These map
to the same names in the C++11 standard.  Refer there or to the GCC wiki
on atomic synchronization
(http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync) for more detailed
definitions.  These memory models integrate both barriers to code motion
as well as synchronization requirements with other threads.  These are
listed in approximately ascending order of strength.  It is also
possible to use target specific flags for memory model flags, like
Hardware Lock Elision.

'__ATOMIC_RELAXED'
     No barriers or synchronization.
'__ATOMIC_CONSUME'
     Data dependency only for both barrier and synchronization with
     another thread.
'__ATOMIC_ACQUIRE'
     Barrier to hoisting of code and synchronizes with release (or
     stronger) semantic stores from another thread.
'__ATOMIC_RELEASE'
     Barrier to sinking of code and synchronizes with acquire (or
     stronger) semantic loads from another thread.
'__ATOMIC_ACQ_REL'
     Full barrier in both directions and synchronizes with acquire loads
     and release stores in another thread.
'__ATOMIC_SEQ_CST'
     Full barrier in both directions and synchronizes with acquire loads
     and release stores in all threads.

 When implementing patterns for these built-in functions, the memory
model parameter can be ignored as long as the pattern implements the
most restrictive '__ATOMIC_SEQ_CST' model.  Any of the other memory
models execute correctly with this memory model but they may not execute
as efficiently as they could with a more appropriate implementation of
the relaxed requirements.

 Note that the C++11 standard allows for the memory model parameter to
be determined at run time rather than at compile time.  These built-in
functions map any run-time value to '__ATOMIC_SEQ_CST' rather than
invoke a runtime library call or inline a switch statement.  This is
standard compliant, safe, and the simplest approach for now.

 The memory model parameter is a signed int, but only the lower 8 bits
are reserved for the memory model.  The remainder of the signed int is
reserved for future use and should be 0.  Use of the predefined atomic
values ensures proper usage.

 -- Built-in Function: TYPE __atomic_load_n (TYPE *ptr, int memmodel)
     This built-in function implements an atomic load operation.  It
     returns the contents of '*PTR'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', '__ATOMIC_ACQUIRE', and '__ATOMIC_CONSUME'.

 -- Built-in Function: void __atomic_load (TYPE *ptr, TYPE *ret, int
          memmodel)
     This is the generic version of an atomic load.  It returns the
     contents of '*PTR' in '*RET'.

 -- Built-in Function: void __atomic_store_n (TYPE *ptr, TYPE val, int
          memmodel)
     This built-in function implements an atomic store operation.  It
     writes 'VAL' into '*PTR'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', and '__ATOMIC_RELEASE'.

 -- Built-in Function: void __atomic_store (TYPE *ptr, TYPE *val, int
          memmodel)
     This is the generic version of an atomic store.  It stores the
     value of '*VAL' into '*PTR'.

 -- Built-in Function: TYPE __atomic_exchange_n (TYPE *ptr, TYPE val,
          int memmodel)
     This built-in function implements an atomic exchange operation.  It
     writes VAL into '*PTR', and returns the previous contents of
     '*PTR'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', '__ATOMIC_ACQUIRE', '__ATOMIC_RELEASE', and
     '__ATOMIC_ACQ_REL'.

 -- Built-in Function: void __atomic_exchange (TYPE *ptr, TYPE *val,
          TYPE *ret, int memmodel)
     This is the generic version of an atomic exchange.  It stores the
     contents of '*VAL' into '*PTR'.  The original value of '*PTR' is
     copied into '*RET'.

 -- Built-in Function: bool __atomic_compare_exchange_n (TYPE *ptr, TYPE
          *expected, TYPE desired, bool weak, int success_memmodel, int
          failure_memmodel)
     This built-in function implements an atomic compare and exchange
     operation.  This compares the contents of '*PTR' with the contents
     of '*EXPECTED' and if equal, writes DESIRED into '*PTR'.  If they
     are not equal, the current contents of '*PTR' is written into
     '*EXPECTED'.  WEAK is true for weak compare_exchange, and false for
     the strong variation.  Many targets only offer the strong variation
     and ignore the parameter.  When in doubt, use the strong variation.

     True is returned if DESIRED is written into '*PTR' and the
     execution is considered to conform to the memory model specified by
     SUCCESS_MEMMODEL.  There are no restrictions on what memory model
     can be used here.

     False is returned otherwise, and the execution is considered to
     conform to FAILURE_MEMMODEL.  This memory model cannot be
     '__ATOMIC_RELEASE' nor '__ATOMIC_ACQ_REL'.  It also cannot be a
     stronger model than that specified by SUCCESS_MEMMODEL.

 -- Built-in Function: bool __atomic_compare_exchange (TYPE *ptr, TYPE
          *expected, TYPE *desired, bool weak, int success_memmodel, int
          failure_memmodel)
     This built-in function implements the generic version of
     '__atomic_compare_exchange'.  The function is virtually identical
     to '__atomic_compare_exchange_n', except the desired value is also
     a pointer.

 -- Built-in Function: TYPE __atomic_add_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_sub_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_and_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_xor_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_or_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_nand_fetch (TYPE *ptr, TYPE val,
          int memmodel)
     These built-in functions perform the operation suggested by the
     name, and return the result of the operation.  That is,

          { *ptr OP= val; return *ptr; }

     All memory models are valid.

 -- Built-in Function: TYPE __atomic_fetch_add (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_sub (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_and (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_xor (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_or (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_nand (TYPE *ptr, TYPE val,
          int memmodel)
     These built-in functions perform the operation suggested by the
     name, and return the value that had previously been in '*PTR'.
     That is,

          { tmp = *ptr; *ptr OP= val; return tmp; }

     All memory models are valid.

 -- Built-in Function: bool __atomic_test_and_set (void *ptr, int
          memmodel)

     This built-in function performs an atomic test-and-set operation on
     the byte at '*PTR'.  The byte is set to some implementation defined
     nonzero "set" value and the return value is 'true' if and only if
     the previous contents were "set".  It should be only used for
     operands of type 'bool' or 'char'.  For other types only part of
     the value may be set.

     All memory models are valid.

 -- Built-in Function: void __atomic_clear (bool *ptr, int memmodel)

     This built-in function performs an atomic clear operation on
     '*PTR'.  After the operation, '*PTR' contains 0.  It should be only
     used for operands of type 'bool' or 'char' and in conjunction with
     '__atomic_test_and_set'.  For other types it may only clear
     partially.  If the type is not 'bool' prefer using
     '__atomic_store'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', and '__ATOMIC_RELEASE'.

 -- Built-in Function: void __atomic_thread_fence (int memmodel)

     This built-in function acts as a synchronization fence between
     threads based on the specified memory model.

     All memory orders are valid.

 -- Built-in Function: void __atomic_signal_fence (int memmodel)

     This built-in function acts as a synchronization fence between a
     thread and signal handlers based in the same thread.

     All memory orders are valid.

 -- Built-in Function: bool __atomic_always_lock_free (size_t size, void
          *ptr)

     This built-in function returns true if objects of SIZE bytes always
     generate lock free atomic instructions for the target architecture.
     SIZE must resolve to a compile-time constant and the result also
     resolves to a compile-time constant.

     PTR is an optional pointer to the object that may be used to
     determine alignment.  A value of 0 indicates typical alignment
     should be used.  The compiler may also ignore this parameter.

          if (_atomic_always_lock_free (sizeof (long long), 0))

 -- Built-in Function: bool __atomic_is_lock_free (size_t size, void
          *ptr)

     This built-in function returns true if objects of SIZE bytes always
     generate lock free atomic instructions for the target architecture.
     If it is not known to be lock free a call is made to a runtime
     routine named '__atomic_is_lock_free'.

     PTR is an optional pointer to the object that may be used to
     determine alignment.  A value of 0 indicates typical alignment
     should be used.  The compiler may also ignore this parameter.


File: llvm.info,  Node: Integer Overflow Builtins,  Next: x86 specific memory model extensions for transactional memory,  Prev: __atomic Builtins,  Up: C Extensions

6.52 Built-in Functions to Perform Arithmetic with Overflow Checking
====================================================================

The following built-in functions allow performing simple arithmetic
operations together with checking whether the operations overflowed.

 -- Built-in Function: bool __builtin_add_overflow (TYPE1 a, TYPE2 b,
          TYPE3 *res)
 -- Built-in Function: bool __builtin_sadd_overflow (int a, int b, int
          *res)
 -- Built-in Function: bool __builtin_saddl_overflow (long int a, long
          int b, long int *res)
 -- Built-in Function: bool __builtin_saddll_overflow (long long int a,
          long long int b, long int *res)
 -- Built-in Function: bool __builtin_uadd_overflow (unsigned int a,
          unsigned int b, unsigned int *res)
 -- Built-in Function: bool __builtin_uaddl_overflow (unsigned long int
          a, unsigned long int b, unsigned long int *res)
 -- Built-in Function: bool __builtin_uaddll_overflow (unsigned long
          long int a, unsigned long long int b, unsigned long int *res)

     These built-in functions promote the first two operands into
     infinite precision signed type and perform addition on those
     promoted operands.  The result is then cast to the type the third
     pointer argument points to and stored there.  If the stored result
     is equal to the infinite precision result, the built-in functions
     return false, otherwise they return true.  As the addition is
     performed in infinite signed precision, these built-in functions
     have fully defined behavior for all argument values.

     The first built-in function allows arbitrary integral types for
     operands and the result type must be pointer to some integer type,
     the rest of the built-in functions have explicit integer types.

     The compiler will attempt to use hardware instructions to implement
     these built-in functions where possible, like conditional jump on
     overflow after addition, conditional jump on carry etc.

 -- Built-in Function: bool __builtin_sub_overflow (TYPE1 a, TYPE2 b,
          TYPE3 *res)
 -- Built-in Function: bool __builtin_ssub_overflow (int a, int b, int
          *res)
 -- Built-in Function: bool __builtin_ssubl_overflow (long int a, long
          int b, long int *res)
 -- Built-in Function: bool __builtin_ssubll_overflow (long long int a,
          long long int b, long int *res)
 -- Built-in Function: bool __builtin_usub_overflow (unsigned int a,
          unsigned int b, unsigned int *res)
 -- Built-in Function: bool __builtin_usubl_overflow (unsigned long int
          a, unsigned long int b, unsigned long int *res)
 -- Built-in Function: bool __builtin_usubll_overflow (unsigned long
          long int a, unsigned long long int b, unsigned long int *res)

     These built-in functions are similar to the add overflow checking
     built-in functions above, except they perform subtraction, subtract
     the second argument from the first one, instead of addition.

 -- Built-in Function: bool __builtin_mul_overflow (TYPE1 a, TYPE2 b,
          TYPE3 *res)
 -- Built-in Function: bool __builtin_smul_overflow (int a, int b, int
          *res)
 -- Built-in Function: bool __builtin_smull_overflow (long int a, long
          int b, long int *res)
 -- Built-in Function: bool __builtin_smulll_overflow (long long int a,
          long long int b, long int *res)
 -- Built-in Function: bool __builtin_umul_overflow (unsigned int a,
          unsigned int b, unsigned int *res)
 -- Built-in Function: bool __builtin_umull_overflow (unsigned long int
          a, unsigned long int b, unsigned long int *res)
 -- Built-in Function: bool __builtin_umulll_overflow (unsigned long
          long int a, unsigned long long int b, unsigned long int *res)

     These built-in functions are similar to the add overflow checking
     built-in functions above, except they perform multiplication,
     instead of addition.


File: llvm.info,  Node: x86 specific memory model extensions for transactional memory,  Next: Object Size Checking,  Prev: Integer Overflow Builtins,  Up: C Extensions

6.53 x86-Specific Memory Model Extensions for Transactional Memory
==================================================================

The x86 architecture supports additional memory ordering flags to mark
lock critical sections for hardware lock elision.  These must be
specified in addition to an existing memory model to atomic intrinsics.

'__ATOMIC_HLE_ACQUIRE'
     Start lock elision on a lock variable.  Memory model must be
     '__ATOMIC_ACQUIRE' or stronger.
'__ATOMIC_HLE_RELEASE'
     End lock elision on a lock variable.  Memory model must be
     '__ATOMIC_RELEASE' or stronger.

 When a lock acquire fails it is required for good performance to abort
the transaction quickly.  This can be done with a '_mm_pause'

     #include <immintrin.h> // For _mm_pause

     int lockvar;

     /* Acquire lock with lock elision */
     while (__atomic_exchange_n(&lockvar, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))
         _mm_pause(); /* Abort failed transaction */
     ...
     /* Free lock with lock elision */
     __atomic_store_n(&lockvar, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);


File: llvm.info,  Node: Object Size Checking,  Next: Pointer Bounds Checker builtins,  Prev: x86 specific memory model extensions for transactional memory,  Up: C Extensions

6.54 Object Size Checking Built-in Functions
============================================

GCC implements a limited buffer overflow protection mechanism that can
prevent some buffer overflow attacks.

 -- Built-in Function: size_t __builtin_object_size (void * PTR, int
          TYPE)
     is a built-in construct that returns a constant number of bytes
     from PTR to the end of the object PTR pointer points to (if known
     at compile time).  '__builtin_object_size' never evaluates its
     arguments for side-effects.  If there are any side-effects in them,
     it returns '(size_t) -1' for TYPE 0 or 1 and '(size_t) 0' for TYPE
     2 or 3.  If there are multiple objects PTR can point to and all of
     them are known at compile time, the returned number is the maximum
     of remaining byte counts in those objects if TYPE & 2 is 0 and
     minimum if nonzero.  If it is not possible to determine which
     objects PTR points to at compile time, '__builtin_object_size'
     should return '(size_t) -1' for TYPE 0 or 1 and '(size_t) 0' for
     TYPE 2 or 3.

     TYPE is an integer constant from 0 to 3.  If the least significant
     bit is clear, objects are whole variables, if it is set, a closest
     surrounding subobject is considered the object a pointer points to.
     The second bit determines if maximum or minimum of remaining bytes
     is computed.

          struct V { char buf1[10]; int b; char buf2[10]; } var;
          char *p = &var.buf1[1], *q = &var.b;

          /* Here the object p points to is var.  */
          assert (__builtin_object_size (p, 0) == sizeof (var) - 1);
          /* The subobject p points to is var.buf1.  */
          assert (__builtin_object_size (p, 1) == sizeof (var.buf1) - 1);
          /* The object q points to is var.  */
          assert (__builtin_object_size (q, 0)
                  == (char *) (&var + 1) - (char *) &var.b);
          /* The subobject q points to is var.b.  */
          assert (__builtin_object_size (q, 1) == sizeof (var.b));

 There are built-in functions added for many common string operation
functions, e.g., for 'memcpy' '__builtin___memcpy_chk' built-in is
provided.  This built-in has an additional last argument, which is the
number of bytes remaining in object the DEST argument points to or
'(size_t) -1' if the size is not known.

 The built-in functions are optimized into the normal string functions
like 'memcpy' if the last argument is '(size_t) -1' or if it is known at
compile time that the destination object will not be overflown.  If the
compiler can determine at compile time the object will be always
overflown, it issues a warning.

 The intended use can be e.g.

     #undef memcpy
     #define bos0(dest) __builtin_object_size (dest, 0)
     #define memcpy(dest, src, n) \
       __builtin___memcpy_chk (dest, src, n, bos0 (dest))

     char *volatile p;
     char buf[10];
     /* It is unknown what object p points to, so this is optimized
        into plain memcpy - no checking is possible.  */
     memcpy (p, "abcde", n);
     /* Destination is known and length too.  It is known at compile
        time there will be no overflow.  */
     memcpy (&buf[5], "abcde", 5);
     /* Destination is known, but the length is not known at compile time.
        This will result in __memcpy_chk call that can check for overflow
        at run time.  */
     memcpy (&buf[5], "abcde", n);
     /* Destination is known and it is known at compile time there will
        be overflow.  There will be a warning and __memcpy_chk call that
        will abort the program at run time.  */
     memcpy (&buf[6], "abcde", 5);

 Such built-in functions are provided for 'memcpy', 'mempcpy',
'memmove', 'memset', 'strcpy', 'stpcpy', 'strncpy', 'strcat' and
'strncat'.

 There are also checking built-in functions for formatted output
functions.
     int __builtin___sprintf_chk (char *s, int flag, size_t os, const char *fmt, ...);
     int __builtin___snprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                                   const char *fmt, ...);
     int __builtin___vsprintf_chk (char *s, int flag, size_t os, const char *fmt,
                                   va_list ap);
     int __builtin___vsnprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                                    const char *fmt, va_list ap);

 The added FLAG argument is passed unchanged to '__sprintf_chk' etc.
functions and can contain implementation specific flags on what
additional security measures the checking function might take, such as
handling '%n' differently.

 The OS argument is the object size S points to, like in the other
built-in functions.  There is a small difference in the behavior though,
if OS is '(size_t) -1', the built-in functions are optimized into the
non-checking functions only if FLAG is 0, otherwise the checking
function is called with OS argument set to '(size_t) -1'.

 In addition to this, there are checking built-in functions
'__builtin___printf_chk', '__builtin___vprintf_chk',
'__builtin___fprintf_chk' and '__builtin___vfprintf_chk'.  These have
just one additional argument, FLAG, right before format string FMT.  If
the compiler is able to optimize them to 'fputc' etc. functions, it
does, otherwise the checking function is called and the FLAG argument
passed to it.


File: llvm.info,  Node: Pointer Bounds Checker builtins,  Next: Cilk Plus Builtins,  Prev: Object Size Checking,  Up: C Extensions

6.55 Pointer Bounds Checker Built-in Functions
==============================================

GCC provides a set of built-in functions to control Pointer Bounds
Checker instrumentation.  Note that all Pointer Bounds Checker builtins
are allowed to use even if you compile with Pointer Bounds Checker off.
The builtins behavior may differ in such case as documented below.

 -- Built-in Function: void * __builtin___bnd_set_ptr_bounds (const void
          * Q, size_t SIZE)

     This built-in function returns a new pointer with the value of Q,
     and associate it with the bounds [Q, Q+SIZE-1].  With Pointer
     Bounds Checker off built-in function just returns the first
     argument.

          extern void *__wrap_malloc (size_t n)
          {
            void *p = (void *)__real_malloc (n);
            if (!p) return __builtin___bnd_null_ptr_bounds (p);
            return __builtin___bnd_set_ptr_bounds (p, n);
          }

 -- Built-in Function: void * __builtin___bnd_narrow_ptr_bounds (const
          void * P, const void * Q, size_t SIZE)

     This built-in function returns a new pointer with the value of P
     and associate it with the narrowed bounds formed by the
     intersection of bounds associated with Q and the [P, P + SIZE - 1].
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

          void init_objects (object *objs, size_t size)
          {
            size_t i;
            /* Initialize objects one-by-one passing pointers with bounds of an object,
               not the full array of objects.  */
            for (i = 0; i < size; i++)
              init_object (__builtin___bnd_narrow_ptr_bounds (objs + i, objs, sizeof(object)));
          }

 -- Built-in Function: void * __builtin___bnd_copy_ptr_bounds (const
          void * Q, const void * R)

     This built-in function returns a new pointer with the value of Q,
     and associate it with the bounds already associated with pointer R.
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

          /* Here is a way to get pointer to object's field but
             still with the full object's bounds.  */
          int *field_ptr = __builtin___bnd_copy_ptr_bounds (&objptr->int_filed, objptr);

 -- Built-in Function: void * __builtin___bnd_init_ptr_bounds (const
          void * Q)

     This built-in function returns a new pointer with the value of Q,
     and associate it with INIT (allowing full memory access) bounds.
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

 -- Built-in Function: void * __builtin___bnd_null_ptr_bounds (const
          void * Q)

     This built-in function returns a new pointer with the value of Q,
     and associate it with NULL (allowing no memory access) bounds.
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

 -- Built-in Function: void __builtin___bnd_store_ptr_bounds (const void
          ** PTR_ADDR, const void * PTR_VAL)

     This built-in function stores the bounds associated with pointer
     PTR_VAL and location PTR_ADDR into Bounds Table.  This can be
     useful to propagate bounds from legacy code without touching the
     associated pointer's memory when pointers were copied as integers.
     With Pointer Bounds Checker off built-in function call is ignored.

 -- Built-in Function: void __builtin___bnd_chk_ptr_lbounds (const void
          * Q)

     This built-in function checks if the pointer Q is within the lower
     bound of its associated bounds.  With Pointer Bounds Checker off
     built-in function call is ignored.

          extern void *__wrap_memset (void *dst, int c, size_t len)
          {
            if (len > 0)
              {
                __builtin___bnd_chk_ptr_lbounds (dst);
                __builtin___bnd_chk_ptr_ubounds ((char *)dst + len - 1);
                __real_memset (dst, c, len);
              }
            return dst;
          }

 -- Built-in Function: void __builtin___bnd_chk_ptr_ubounds (const void
          * Q)

     This built-in function checks if the pointer Q is within the upper
     bound of its associated bounds.  With Pointer Bounds Checker off
     built-in function call is ignored.

 -- Built-in Function: void __builtin___bnd_chk_ptr_bounds (const void *
          Q, size_t SIZE)

     This built-in function checks if [Q, Q + SIZE - 1] is within the
     lower and upper bounds associated with Q.  With Pointer Bounds
     Checker off built-in function call is ignored.

          extern void *__wrap_memcpy (void *dst, const void *src, size_t n)
          {
            if (n > 0)
              {
                __bnd_chk_ptr_bounds (dst, n);
                __bnd_chk_ptr_bounds (src, n);
                __real_memcpy (dst, src, n);
              }
            return dst;
          }

 -- Built-in Function: const void * __builtin___bnd_get_ptr_lbound
          (const void * Q)

     This built-in function returns the lower bound (which is a pointer)
     associated with the pointer Q.  This is at least useful for
     debugging using printf.  With Pointer Bounds Checker off built-in
     function returns 0.

          void *lb = __builtin___bnd_get_ptr_lbound (q);
          void *ub = __builtin___bnd_get_ptr_ubound (q);
          printf ("q = %p  lb(q) = %p  ub(q) = %p", q, lb, ub);

 -- Built-in Function: const void * __builtin___bnd_get_ptr_ubound
          (const void * Q)

     This built-in function returns the upper bound (which is a pointer)
     associated with the pointer Q.  With Pointer Bounds Checker off
     built-in function returns -1.


File: llvm.info,  Node: Cilk Plus Builtins,  Next: Other Builtins,  Prev: Pointer Bounds Checker builtins,  Up: C Extensions

6.56 Cilk Plus C/C++ Language Extension Built-in Functions
==========================================================

GCC provides support for the following built-in reduction functions if
Cilk Plus is enabled.  Cilk Plus can be enabled using the '-fcilkplus'
flag.

   * __sec_implicit_index
   * __sec_reduce
   * __sec_reduce_add
   * __sec_reduce_all_nonzero
   * __sec_reduce_all_zero
   * __sec_reduce_any_nonzero
   * __sec_reduce_any_zero
   * __sec_reduce_max
   * __sec_reduce_min
   * __sec_reduce_max_ind
   * __sec_reduce_min_ind
   * __sec_reduce_mul
   * __sec_reduce_mutating

 Further details and examples about these built-in functions are
described in the Cilk Plus language manual which can be found at
<http://www.cilkplus.org>.


File: llvm.info,  Node: Other Builtins,  Next: Target Builtins,  Prev: Cilk Plus Builtins,  Up: C Extensions

6.57 Other Built-in Functions Provided by GCC
=============================================

GCC provides a large number of built-in functions other than the ones
mentioned above.  Some of these are for internal use in the processing
of exceptions or variable-length argument lists and are not documented
here because they may change from time to time; we do not recommend
general use of these functions.

 The remaining functions are provided for optimization purposes.

 GCC includes built-in versions of many of the functions in the standard
C library.  The versions prefixed with '__builtin_' are always treated
as having the same meaning as the C library function even if you specify
the '-fno-builtin' option.  (*note C Dialect Options::) Many of these
functions are only optimized in certain cases; if they are not optimized
in a particular case, a call to the library function is emitted.

 Outside strict ISO C mode ('-ansi', '-std=c90', '-std=c99' or
'-std=c11'), the functions '_exit', 'alloca', 'bcmp', 'bzero',
'dcgettext', 'dgettext', 'dremf', 'dreml', 'drem', 'exp10f', 'exp10l',
'exp10', 'ffsll', 'ffsl', 'ffs', 'fprintf_unlocked', 'fputs_unlocked',
'gammaf', 'gammal', 'gamma', 'gammaf_r', 'gammal_r', 'gamma_r',
'gettext', 'index', 'isascii', 'j0f', 'j0l', 'j0', 'j1f', 'j1l', 'j1',
'jnf', 'jnl', 'jn', 'lgammaf_r', 'lgammal_r', 'lgamma_r', 'mempcpy',
'pow10f', 'pow10l', 'pow10', 'printf_unlocked', 'rindex', 'scalbf',
'scalbl', 'scalb', 'signbit', 'signbitf', 'signbitl', 'signbitd32',
'signbitd64', 'signbitd128', 'significandf', 'significandl',
'significand', 'sincosf', 'sincosl', 'sincos', 'stpcpy', 'stpncpy',
'strcasecmp', 'strdup', 'strfmon', 'strncasecmp', 'strndup', 'toascii',
'y0f', 'y0l', 'y0', 'y1f', 'y1l', 'y1', 'ynf', 'ynl' and 'yn' may be
handled as built-in functions.  All these functions have corresponding
versions prefixed with '__builtin_', which may be used even in strict
C90 mode.

 The ISO C99 functions '_Exit', 'acoshf', 'acoshl', 'acosh', 'asinhf',
'asinhl', 'asinh', 'atanhf', 'atanhl', 'atanh', 'cabsf', 'cabsl',
'cabs', 'cacosf', 'cacoshf', 'cacoshl', 'cacosh', 'cacosl', 'cacos',
'cargf', 'cargl', 'carg', 'casinf', 'casinhf', 'casinhl', 'casinh',
'casinl', 'casin', 'catanf', 'catanhf', 'catanhl', 'catanh', 'catanl',
'catan', 'cbrtf', 'cbrtl', 'cbrt', 'ccosf', 'ccoshf', 'ccoshl', 'ccosh',
'ccosl', 'ccos', 'cexpf', 'cexpl', 'cexp', 'cimagf', 'cimagl', 'cimag',
'clogf', 'clogl', 'clog', 'conjf', 'conjl', 'conj', 'copysignf',
'copysignl', 'copysign', 'cpowf', 'cpowl', 'cpow', 'cprojf', 'cprojl',
'cproj', 'crealf', 'creall', 'creal', 'csinf', 'csinhf', 'csinhl',
'csinh', 'csinl', 'csin', 'csqrtf', 'csqrtl', 'csqrt', 'ctanf',
'ctanhf', 'ctanhl', 'ctanh', 'ctanl', 'ctan', 'erfcf', 'erfcl', 'erfc',
'erff', 'erfl', 'erf', 'exp2f', 'exp2l', 'exp2', 'expm1f', 'expm1l',
'expm1', 'fdimf', 'fdiml', 'fdim', 'fmaf', 'fmal', 'fmaxf', 'fmaxl',
'fmax', 'fma', 'fminf', 'fminl', 'fmin', 'hypotf', 'hypotl', 'hypot',
'ilogbf', 'ilogbl', 'ilogb', 'imaxabs', 'isblank', 'iswblank',
'lgammaf', 'lgammal', 'lgamma', 'llabs', 'llrintf', 'llrintl', 'llrint',
'llroundf', 'llroundl', 'llround', 'log1pf', 'log1pl', 'log1p', 'log2f',
'log2l', 'log2', 'logbf', 'logbl', 'logb', 'lrintf', 'lrintl', 'lrint',
'lroundf', 'lroundl', 'lround', 'nearbyintf', 'nearbyintl', 'nearbyint',
'nextafterf', 'nextafterl', 'nextafter', 'nexttowardf', 'nexttowardl',
'nexttoward', 'remainderf', 'remainderl', 'remainder', 'remquof',
'remquol', 'remquo', 'rintf', 'rintl', 'rint', 'roundf', 'roundl',
'round', 'scalblnf', 'scalblnl', 'scalbln', 'scalbnf', 'scalbnl',
'scalbn', 'snprintf', 'tgammaf', 'tgammal', 'tgamma', 'truncf',
'truncl', 'trunc', 'vfscanf', 'vscanf', 'vsnprintf' and 'vsscanf' are
handled as built-in functions except in strict ISO C90 mode ('-ansi' or
'-std=c90').

 There are also built-in versions of the ISO C99 functions 'acosf',
'acosl', 'asinf', 'asinl', 'atan2f', 'atan2l', 'atanf', 'atanl',
'ceilf', 'ceill', 'cosf', 'coshf', 'coshl', 'cosl', 'expf', 'expl',
'fabsf', 'fabsl', 'floorf', 'floorl', 'fmodf', 'fmodl', 'frexpf',
'frexpl', 'ldexpf', 'ldexpl', 'log10f', 'log10l', 'logf', 'logl',
'modfl', 'modf', 'powf', 'powl', 'sinf', 'sinhf', 'sinhl', 'sinl',
'sqrtf', 'sqrtl', 'tanf', 'tanhf', 'tanhl' and 'tanl' that are
recognized in any mode since ISO C90 reserves these names for the
purpose to which ISO C99 puts them.  All these functions have
corresponding versions prefixed with '__builtin_'.

 The ISO C94 functions 'iswalnum', 'iswalpha', 'iswcntrl', 'iswdigit',
'iswgraph', 'iswlower', 'iswprint', 'iswpunct', 'iswspace', 'iswupper',
'iswxdigit', 'towlower' and 'towupper' are handled as built-in functions
except in strict ISO C90 mode ('-ansi' or '-std=c90').

 The ISO C90 functions 'abort', 'abs', 'acos', 'asin', 'atan2', 'atan',
'calloc', 'ceil', 'cosh', 'cos', 'exit', 'exp', 'fabs', 'floor', 'fmod',
'fprintf', 'fputs', 'frexp', 'fscanf', 'isalnum', 'isalpha', 'iscntrl',
'isdigit', 'isgraph', 'islower', 'isprint', 'ispunct', 'isspace',
'isupper', 'isxdigit', 'tolower', 'toupper', 'labs', 'ldexp', 'log10',
'log', 'malloc', 'memchr', 'memcmp', 'memcpy', 'memset', 'modf', 'pow',
'printf', 'putchar', 'puts', 'scanf', 'sinh', 'sin', 'snprintf',
'sprintf', 'sqrt', 'sscanf', 'strcat', 'strchr', 'strcmp', 'strcpy',
'strcspn', 'strlen', 'strncat', 'strncmp', 'strncpy', 'strpbrk',
'strrchr', 'strspn', 'strstr', 'tanh', 'tan', 'vfprintf', 'vprintf' and
'vsprintf' are all recognized as built-in functions unless
'-fno-builtin' is specified (or '-fno-builtin-FUNCTION' is specified for
an individual function).  All of these functions have corresponding
versions prefixed with '__builtin_'.

 GCC provides built-in versions of the ISO C99 floating-point comparison
macros that avoid raising exceptions for unordered operands.  They have
the same names as the standard macros ( 'isgreater', 'isgreaterequal',
'isless', 'islessequal', 'islessgreater', and 'isunordered') , with
'__builtin_' prefixed.  We intend for a library implementor to be able
to simply '#define' each standard macro to its built-in equivalent.  In
the same fashion, GCC provides 'fpclassify', 'isfinite', 'isinf_sign'
and 'isnormal' built-ins used with '__builtin_' prefixed.  The 'isinf'
and 'isnan' built-in functions appear both with and without the
'__builtin_' prefix.

 -- Built-in Function: int __builtin_types_compatible_p (TYPE1, TYPE2)

     You can use the built-in function '__builtin_types_compatible_p' to
     determine whether two types are the same.

     This built-in function returns 1 if the unqualified versions of the
     types TYPE1 and TYPE2 (which are types, not expressions) are
     compatible, 0 otherwise.  The result of this built-in function can
     be used in integer constant expressions.

     This built-in function ignores top level qualifiers (e.g., 'const',
     'volatile').  For example, 'int' is equivalent to 'const int'.

     The type 'int[]' and 'int[5]' are compatible.  On the other hand,
     'int' and 'char *' are not compatible, even if the size of their
     types, on the particular architecture are the same.  Also, the
     amount of pointer indirection is taken into account when
     determining similarity.  Consequently, 'short *' is not similar to
     'short **'.  Furthermore, two types that are typedefed are
     considered compatible if their underlying types are compatible.

     An 'enum' type is not considered to be compatible with another
     'enum' type even if both are compatible with the same integer type;
     this is what the C standard specifies.  For example, 'enum {foo,
     bar}' is not similar to 'enum {hot, dog}'.

     You typically use this function in code whose execution varies
     depending on the arguments' types.  For example:

          #define foo(x)                                                  \
            ({                                                           \
              typeof (x) tmp = (x);                                       \
              if (__builtin_types_compatible_p (typeof (x), long double)) \
                tmp = foo_long_double (tmp);                              \
              else if (__builtin_types_compatible_p (typeof (x), double)) \
                tmp = foo_double (tmp);                                   \
              else if (__builtin_types_compatible_p (typeof (x), float))  \
                tmp = foo_float (tmp);                                    \
              else                                                        \
                abort ();                                                 \
              tmp;                                                        \
            })

     _Note:_ This construct is only available for C.

 -- Built-in Function: TYPE __builtin_call_with_static_chain (CALL_EXP,
          POINTER_EXP)

     The CALL_EXP expression must be a function call, and the
     POINTER_EXP expression must be a pointer.  The POINTER_EXP is
     passed to the function call in the target's static chain location.
     The result of builtin is the result of the function call.

     _Note:_ This builtin is only available for C.  This builtin can be
     used to call Go closures from C.

 -- Built-in Function: TYPE __builtin_choose_expr (CONST_EXP, EXP1,
          EXP2)

     You can use the built-in function '__builtin_choose_expr' to
     evaluate code depending on the value of a constant expression.
     This built-in function returns EXP1 if CONST_EXP, which is an
     integer constant expression, is nonzero.  Otherwise it returns
     EXP2.

     This built-in function is analogous to the '? :' operator in C,
     except that the expression returned has its type unaltered by
     promotion rules.  Also, the built-in function does not evaluate the
     expression that is not chosen.  For example, if CONST_EXP evaluates
     to true, EXP2 is not evaluated even if it has side-effects.

     This built-in function can return an lvalue if the chosen argument
     is an lvalue.

     If EXP1 is returned, the return type is the same as EXP1's type.
     Similarly, if EXP2 is returned, its return type is the same as
     EXP2.

     Example:

          #define foo(x)                                                    \
            __builtin_choose_expr (                                         \
              __builtin_types_compatible_p (typeof (x), double),            \
              foo_double (x),                                               \
              __builtin_choose_expr (                                       \
                __builtin_types_compatible_p (typeof (x), float),           \
                foo_float (x),                                              \
                /* The void expression results in a compile-time error  \
                   when assigning the result to something.  */          \
                (void)0))

     _Note:_ This construct is only available for C.  Furthermore, the
     unused expression (EXP1 or EXP2 depending on the value of
     CONST_EXP) may still generate syntax errors.  This may change in
     future revisions.

 -- Built-in Function: TYPE __builtin_complex (REAL, IMAG)

     The built-in function '__builtin_complex' is provided for use in
     implementing the ISO C11 macros 'CMPLXF', 'CMPLX' and 'CMPLXL'.
     REAL and IMAG must have the same type, a real binary floating-point
     type, and the result has the corresponding complex type with real
     and imaginary parts REAL and IMAG.  Unlike 'REAL + I * IMAG', this
     works even when infinities, NaNs and negative zeros are involved.

 -- Built-in Function: int __builtin_constant_p (EXP)
     You can use the built-in function '__builtin_constant_p' to
     determine if a value is known to be constant at compile time and
     hence that GCC can perform constant-folding on expressions
     involving that value.  The argument of the function is the value to
     test.  The function returns the integer 1 if the argument is known
     to be a compile-time constant and 0 if it is not known to be a
     compile-time constant.  A return of 0 does not indicate that the
     value is _not_ a constant, but merely that GCC cannot prove it is a
     constant with the specified value of the '-O' option.

     You typically use this function in an embedded application where
     memory is a critical resource.  If you have some complex
     calculation, you may want it to be folded if it involves constants,
     but need to call a function if it does not.  For example:

          #define Scale_Value(X)      \
            (__builtin_constant_p (X) \
            ? ((X) * SCALE + OFFSET) : Scale (X))

     You may use this built-in function in either a macro or an inline
     function.  However, if you use it in an inlined function and pass
     an argument of the function as the argument to the built-in, GCC
     never returns 1 when you call the inline function with a string
     constant or compound literal (*note Compound Literals::) and does
     not return 1 when you pass a constant numeric value to the inline
     function unless you specify the '-O' option.

     You may also use '__builtin_constant_p' in initializers for static
     data.  For instance, you can write

          static const int table[] = {
             __builtin_constant_p (EXPRESSION) ? (EXPRESSION) : -1,
             /* ... */
          };

     This is an acceptable initializer even if EXPRESSION is not a
     constant expression, including the case where
     '__builtin_constant_p' returns 1 because EXPRESSION can be folded
     to a constant but EXPRESSION contains operands that are not
     otherwise permitted in a static initializer (for example, '0 && foo
     ()').  GCC must be more conservative about evaluating the built-in
     in this case, because it has no opportunity to perform
     optimization.

 -- Built-in Function: long __builtin_expect (long EXP, long C)
     You may use '__builtin_expect' to provide the compiler with branch
     prediction information.  In general, you should prefer to use
     actual profile feedback for this ('-fprofile-arcs'), as programmers
     are notoriously bad at predicting how their programs actually
     perform.  However, there are applications in which this data is
     hard to collect.

     The return value is the value of EXP, which should be an integral
     expression.  The semantics of the built-in are that it is expected
     that EXP == C.  For example:

          if (__builtin_expect (x, 0))
            foo ();

     indicates that we do not expect to call 'foo', since we expect 'x'
     to be zero.  Since you are limited to integral expressions for EXP,
     you should use constructions such as

          if (__builtin_expect (ptr != NULL, 1))
            foo (*ptr);

     when testing pointer or floating-point values.

 -- Built-in Function: void __builtin_trap (void)
     This function causes the program to exit abnormally.  GCC
     implements this function by using a target-dependent mechanism
     (such as intentionally executing an illegal instruction) or by
     calling 'abort'.  The mechanism used may vary from release to
     release so you should not rely on any particular implementation.

 -- Built-in Function: void __builtin_unreachable (void)
     If control flow reaches the point of the '__builtin_unreachable',
     the program is undefined.  It is useful in situations where the
     compiler cannot deduce the unreachability of the code.

     One such case is immediately following an 'asm' statement that
     either never terminates, or one that transfers control elsewhere
     and never returns.  In this example, without the
     '__builtin_unreachable', GCC issues a warning that control reaches
     the end of a non-void function.  It also generates code to return
     after the 'asm'.

          int f (int c, int v)
          {
            if (c)
              {
                return v;
              }
            else
              {
                asm("jmp error_handler");
                __builtin_unreachable ();
              }
          }

     Because the 'asm' statement unconditionally transfers control out
     of the function, control never reaches the end of the function
     body.  The '__builtin_unreachable' is in fact unreachable and
     communicates this fact to the compiler.

     Another use for '__builtin_unreachable' is following a call a
     function that never returns but that is not declared
     '__attribute__((noreturn))', as in this example:

          void function_that_never_returns (void);

          int g (int c)
          {
            if (c)
              {
                return 1;
              }
            else
              {
                function_that_never_returns ();
                __builtin_unreachable ();
              }
          }

 -- Built-in Function: void *__builtin_assume_aligned (const void *EXP,
          size_t ALIGN, ...)
     This function returns its first argument, and allows the compiler
     to assume that the returned pointer is at least ALIGN bytes
     aligned.  This built-in can have either two or three arguments, if
     it has three, the third argument should have integer type, and if
     it is nonzero means misalignment offset.  For example:

          void *x = __builtin_assume_aligned (arg, 16);

     means that the compiler can assume 'x', set to 'arg', is at least
     16-byte aligned, while:

          void *x = __builtin_assume_aligned (arg, 32, 8);

     means that the compiler can assume for 'x', set to 'arg', that
     '(char *) x - 8' is 32-byte aligned.

 -- Built-in Function: int __builtin_LINE ()
     This function is the equivalent to the preprocessor '__LINE__'
     macro and returns the line number of the invocation of the
     built-in.  In a C++ default argument for a function F, it gets the
     line number of the call to F.

 -- Built-in Function: const char * __builtin_FUNCTION ()
     This function is the equivalent to the preprocessor '__FUNCTION__'
     macro and returns the function name the invocation of the built-in
     is in.

 -- Built-in Function: const char * __builtin_FILE ()
     This function is the equivalent to the preprocessor '__FILE__'
     macro and returns the file name the invocation of the built-in is
     in.  In a C++ default argument for a function F, it gets the file
     name of the call to F.

 -- Built-in Function: void __builtin___clear_cache (char *BEGIN, char
          *END)
     This function is used to flush the processor's instruction cache
     for the region of memory between BEGIN inclusive and END exclusive.
     Some targets require that the instruction cache be flushed, after
     modifying memory containing code, in order to obtain deterministic
     behavior.

     If the target does not require instruction cache flushes,
     '__builtin___clear_cache' has no effect.  Otherwise either
     instructions are emitted in-line to clear the instruction cache or
     a call to the '__clear_cache' function in libgcc is made.

 -- Built-in Function: void __builtin_prefetch (const void *ADDR, ...)
     This function is used to minimize cache-miss latency by moving data
     into a cache before it is accessed.  You can insert calls to
     '__builtin_prefetch' into code for which you know addresses of data
     in memory that is likely to be accessed soon.  If the target
     supports them, data prefetch instructions are generated.  If the
     prefetch is done early enough before the access then the data will
     be in the cache by the time it is accessed.

     The value of ADDR is the address of the memory to prefetch.  There
     are two optional arguments, RW and LOCALITY.  The value of RW is a
     compile-time constant one or zero; one means that the prefetch is
     preparing for a write to the memory address and zero, the default,
     means that the prefetch is preparing for a read.  The value
     LOCALITY must be a compile-time constant integer between zero and
     three.  A value of zero means that the data has no temporal
     locality, so it need not be left in the cache after the access.  A
     value of three means that the data has a high degree of temporal
     locality and should be left in all levels of cache possible.
     Values of one and two mean, respectively, a low or moderate degree
     of temporal locality.  The default is three.

          for (i = 0; i < n; i++)
            {
              a[i] = a[i] + b[i];
              __builtin_prefetch (&a[i+j], 1, 1);
              __builtin_prefetch (&b[i+j], 0, 1);
              /* ... */
            }

     Data prefetch does not generate faults if ADDR is invalid, but the
     address expression itself must be valid.  For example, a prefetch
     of 'p->next' does not fault if 'p->next' is not a valid address,
     but evaluation faults if 'p' is not a valid address.

     If the target does not support data prefetch, the address
     expression is evaluated if it includes side effects but no other
     code is generated and GCC does not issue a warning.

 -- Built-in Function: double __builtin_huge_val (void)
     Returns a positive infinity, if supported by the floating-point
     format, else 'DBL_MAX'.  This function is suitable for implementing
     the ISO C macro 'HUGE_VAL'.

 -- Built-in Function: float __builtin_huge_valf (void)
     Similar to '__builtin_huge_val', except the return type is 'float'.

 -- Built-in Function: long double __builtin_huge_vall (void)
     Similar to '__builtin_huge_val', except the return type is 'long
     double'.

 -- Built-in Function: int __builtin_fpclassify (int, int, int, int,
          int, ...)
     This built-in implements the C99 fpclassify functionality.  The
     first five int arguments should be the target library's notion of
     the possible FP classes and are used for return values.  They must
     be constant values and they must appear in this order: 'FP_NAN',
     'FP_INFINITE', 'FP_NORMAL', 'FP_SUBNORMAL' and 'FP_ZERO'.  The
     ellipsis is for exactly one floating-point value to classify.  GCC
     treats the last argument as type-generic, which means it does not
     do default promotion from float to double.

 -- Built-in Function: double __builtin_inf (void)
     Similar to '__builtin_huge_val', except a warning is generated if
     the target floating-point format does not support infinities.

 -- Built-in Function: _Decimal32 __builtin_infd32 (void)
     Similar to '__builtin_inf', except the return type is '_Decimal32'.

 -- Built-in Function: _Decimal64 __builtin_infd64 (void)
     Similar to '__builtin_inf', except the return type is '_Decimal64'.

 -- Built-in Function: _Decimal128 __builtin_infd128 (void)
     Similar to '__builtin_inf', except the return type is
     '_Decimal128'.

 -- Built-in Function: float __builtin_inff (void)
     Similar to '__builtin_inf', except the return type is 'float'.
     This function is suitable for implementing the ISO C99 macro
     'INFINITY'.

 -- Built-in Function: long double __builtin_infl (void)
     Similar to '__builtin_inf', except the return type is 'long
     double'.

 -- Built-in Function: int __builtin_isinf_sign (...)
     Similar to 'isinf', except the return value is -1 for an argument
     of '-Inf' and 1 for an argument of '+Inf'.  Note while the
     parameter list is an ellipsis, this function only accepts exactly
     one floating-point argument.  GCC treats this parameter as
     type-generic, which means it does not do default promotion from
     float to double.

 -- Built-in Function: double __builtin_nan (const char *str)
     This is an implementation of the ISO C99 function 'nan'.

     Since ISO C99 defines this function in terms of 'strtod', which we
     do not implement, a description of the parsing is in order.  The
     string is parsed as by 'strtol'; that is, the base is recognized by
     leading '0' or '0x' prefixes.  The number parsed is placed in the
     significand such that the least significant bit of the number is at
     the least significant bit of the significand.  The number is
     truncated to fit the significand field provided.  The significand
     is forced to be a quiet NaN.

     This function, if given a string literal all of which would have
     been consumed by 'strtol', is evaluated early enough that it is
     considered a compile-time constant.

 -- Built-in Function: _Decimal32 __builtin_nand32 (const char *str)
     Similar to '__builtin_nan', except the return type is '_Decimal32'.

 -- Built-in Function: _Decimal64 __builtin_nand64 (const char *str)
     Similar to '__builtin_nan', except the return type is '_Decimal64'.

 -- Built-in Function: _Decimal128 __builtin_nand128 (const char *str)
     Similar to '__builtin_nan', except the return type is
     '_Decimal128'.

 -- Built-in Function: float __builtin_nanf (const char *str)
     Similar to '__builtin_nan', except the return type is 'float'.

 -- Built-in Function: long double __builtin_nanl (const char *str)
     Similar to '__builtin_nan', except the return type is 'long
     double'.

 -- Built-in Function: double __builtin_nans (const char *str)
     Similar to '__builtin_nan', except the significand is forced to be
     a signaling NaN.  The 'nans' function is proposed by WG14 N965.

 -- Built-in Function: float __builtin_nansf (const char *str)
     Similar to '__builtin_nans', except the return type is 'float'.

 -- Built-in Function: long double __builtin_nansl (const char *str)
     Similar to '__builtin_nans', except the return type is 'long
     double'.

 -- Built-in Function: int __builtin_ffs (int x)
     Returns one plus the index of the least significant 1-bit of X, or
     if X is zero, returns zero.

 -- Built-in Function: int __builtin_clz (unsigned int x)
     Returns the number of leading 0-bits in X, starting at the most
     significant bit position.  If X is 0, the result is undefined.

 -- Built-in Function: int __builtin_ctz (unsigned int x)
     Returns the number of trailing 0-bits in X, starting at the least
     significant bit position.  If X is 0, the result is undefined.

 -- Built-in Function: int __builtin_clrsb (int x)
     Returns the number of leading redundant sign bits in X, i.e. the
     number of bits following the most significant bit that are
     identical to it.  There are no special cases for 0 or other values.

 -- Built-in Function: int __builtin_popcount (unsigned int x)
     Returns the number of 1-bits in X.

 -- Built-in Function: int __builtin_parity (unsigned int x)
     Returns the parity of X, i.e. the number of 1-bits in X modulo 2.

 -- Built-in Function: int __builtin_ffsl (long)
     Similar to '__builtin_ffs', except the argument type is 'long'.

 -- Built-in Function: int __builtin_clzl (unsigned long)
     Similar to '__builtin_clz', except the argument type is 'unsigned
     long'.

 -- Built-in Function: int __builtin_ctzl (unsigned long)
     Similar to '__builtin_ctz', except the argument type is 'unsigned
     long'.

 -- Built-in Function: int __builtin_clrsbl (long)
     Similar to '__builtin_clrsb', except the argument type is 'long'.

 -- Built-in Function: int __builtin_popcountl (unsigned long)
     Similar to '__builtin_popcount', except the argument type is
     'unsigned long'.

 -- Built-in Function: int __builtin_parityl (unsigned long)
     Similar to '__builtin_parity', except the argument type is
     'unsigned long'.

 -- Built-in Function: int __builtin_ffsll (long long)
     Similar to '__builtin_ffs', except the argument type is 'long
     long'.

 -- Built-in Function: int __builtin_clzll (unsigned long long)
     Similar to '__builtin_clz', except the argument type is 'unsigned
     long long'.

 -- Built-in Function: int __builtin_ctzll (unsigned long long)
     Similar to '__builtin_ctz', except the argument type is 'unsigned
     long long'.

 -- Built-in Function: int __builtin_clrsbll (long long)
     Similar to '__builtin_clrsb', except the argument type is 'long
     long'.

 -- Built-in Function: int __builtin_popcountll (unsigned long long)
     Similar to '__builtin_popcount', except the argument type is
     'unsigned long long'.

 -- Built-in Function: int __builtin_parityll (unsigned long long)
     Similar to '__builtin_parity', except the argument type is
     'unsigned long long'.

 -- Built-in Function: double __builtin_powi (double, int)
     Returns the first argument raised to the power of the second.
     Unlike the 'pow' function no guarantees about precision and
     rounding are made.

 -- Built-in Function: float __builtin_powif (float, int)
     Similar to '__builtin_powi', except the argument and return types
     are 'float'.

 -- Built-in Function: long double __builtin_powil (long double, int)
     Similar to '__builtin_powi', except the argument and return types
     are 'long double'.

 -- Built-in Function: uint16_t __builtin_bswap16 (uint16_t x)
     Returns X with the order of the bytes reversed; for example,
     '0xaabb' becomes '0xbbaa'.  Byte here always means exactly 8 bits.

 -- Built-in Function: uint32_t __builtin_bswap32 (uint32_t x)
     Similar to '__builtin_bswap16', except the argument and return
     types are 32 bit.

 -- Built-in Function: uint64_t __builtin_bswap64 (uint64_t x)
     Similar to '__builtin_bswap32', except the argument and return
     types are 64 bit.


File: llvm.info,  Node: Target Builtins,  Next: Target Format Checks,  Prev: Other Builtins,  Up: C Extensions

6.58 Built-in Functions Specific to Particular Target Machines
==============================================================

On some target machines, GCC supports many built-in functions specific
to those machines.  Generally these generate calls to specific machine
instructions, but allow the compiler to schedule those calls.

* Menu:

* AArch64 Built-in Functions::
* Alpha Built-in Functions::
* Altera Nios II Built-in Functions::
* ARC Built-in Functions::
* ARC SIMD Built-in Functions::
* ARM iWMMXt Built-in Functions::
* ARM C Language Extensions (ACLE)::
* ARM Floating Point Status and Control Intrinsics::
* AVR Built-in Functions::
* Blackfin Built-in Functions::
* FR-V Built-in Functions::
* MIPS DSP Built-in Functions::
* MIPS Paired-Single Support::
* MIPS Loongson Built-in Functions::
* Other MIPS Built-in Functions::
* MSP430 Built-in Functions::
* NDS32 Built-in Functions::
* picoChip Built-in Functions::
* PowerPC Built-in Functions::
* PowerPC AltiVec/VSX Built-in Functions::
* PowerPC Hardware Transactional Memory Built-in Functions::
* RX Built-in Functions::
* S/390 System z Built-in Functions::
* SH Built-in Functions::
* SPARC VIS Built-in Functions::
* SPU Built-in Functions::
* TI C6X Built-in Functions::
* TILE-Gx Built-in Functions::
* TILEPro Built-in Functions::
* x86 Built-in Functions::
* x86 transactional memory intrinsics::


File: llvm.info,  Node: AArch64 Built-in Functions,  Next: Alpha Built-in Functions,  Up: Target Builtins

6.58.1 AArch64 Built-in Functions
---------------------------------

These built-in functions are available for the AArch64 family of
processors.
     unsigned int __builtin_aarch64_get_fpcr ()
     void __builtin_aarch64_set_fpcr (unsigned int)
     unsigned int __builtin_aarch64_get_fpsr ()
     void __builtin_aarch64_set_fpsr (unsigned int)


File: llvm.info,  Node: Alpha Built-in Functions,  Next: Altera Nios II Built-in Functions,  Prev: AArch64 Built-in Functions,  Up: Target Builtins

6.58.2 Alpha Built-in Functions
-------------------------------

These built-in functions are available for the Alpha family of
processors, depending on the command-line switches used.

 The following built-in functions are always available.  They all
generate the machine instruction that is part of the name.

     long __builtin_alpha_implver (void)
     long __builtin_alpha_rpcc (void)
     long __builtin_alpha_amask (long)
     long __builtin_alpha_cmpbge (long, long)
     long __builtin_alpha_extbl (long, long)
     long __builtin_alpha_extwl (long, long)
     long __builtin_alpha_extll (long, long)
     long __builtin_alpha_extql (long, long)
     long __builtin_alpha_extwh (long, long)
     long __builtin_alpha_extlh (long, long)
     long __builtin_alpha_extqh (long, long)
     long __builtin_alpha_insbl (long, long)
     long __builtin_alpha_inswl (long, long)
     long __builtin_alpha_insll (long, long)
     long __builtin_alpha_insql (long, long)
     long __builtin_alpha_inswh (long, long)
     long __builtin_alpha_inslh (long, long)
     long __builtin_alpha_insqh (long, long)
     long __builtin_alpha_mskbl (long, long)
     long __builtin_alpha_mskwl (long, long)
     long __builtin_alpha_mskll (long, long)
     long __builtin_alpha_mskql (long, long)
     long __builtin_alpha_mskwh (long, long)
     long __builtin_alpha_msklh (long, long)
     long __builtin_alpha_mskqh (long, long)
     long __builtin_alpha_umulh (long, long)
     long __builtin_alpha_zap (long, long)
     long __builtin_alpha_zapnot (long, long)

 The following built-in functions are always with '-mmax' or '-mcpu=CPU'
where CPU is 'pca56' or later.  They all generate the machine
instruction that is part of the name.

     long __builtin_alpha_pklb (long)
     long __builtin_alpha_pkwb (long)
     long __builtin_alpha_unpkbl (long)
     long __builtin_alpha_unpkbw (long)
     long __builtin_alpha_minub8 (long, long)
     long __builtin_alpha_minsb8 (long, long)
     long __builtin_alpha_minuw4 (long, long)
     long __builtin_alpha_minsw4 (long, long)
     long __builtin_alpha_maxub8 (long, long)
     long __builtin_alpha_maxsb8 (long, long)
     long __builtin_alpha_maxuw4 (long, long)
     long __builtin_alpha_maxsw4 (long, long)
     long __builtin_alpha_perr (long, long)

 The following built-in functions are always with '-mcix' or '-mcpu=CPU'
where CPU is 'ev67' or later.  They all generate the machine instruction
that is part of the name.

     long __builtin_alpha_cttz (long)
     long __builtin_alpha_ctlz (long)
     long __builtin_alpha_ctpop (long)

 The following built-in functions are available on systems that use the
OSF/1 PALcode.  Normally they invoke the 'rduniq' and 'wruniq' PAL
calls, but when invoked with '-mtls-kernel', they invoke 'rdval' and
'wrval'.

     void *__builtin_thread_pointer (void)
     void __builtin_set_thread_pointer (void *)


File: llvm.info,  Node: Altera Nios II Built-in Functions,  Next: ARC Built-in Functions,  Prev: Alpha Built-in Functions,  Up: Target Builtins

6.58.3 Altera Nios II Built-in Functions
----------------------------------------

These built-in functions are available for the Altera Nios II family of
processors.

 The following built-in functions are always available.  They all
generate the machine instruction that is part of the name.

     int __builtin_ldbio (volatile const void *)
     int __builtin_ldbuio (volatile const void *)
     int __builtin_ldhio (volatile const void *)
     int __builtin_ldhuio (volatile const void *)
     int __builtin_ldwio (volatile const void *)
     void __builtin_stbio (volatile void *, int)
     void __builtin_sthio (volatile void *, int)
     void __builtin_stwio (volatile void *, int)
     void __builtin_sync (void)
     int __builtin_rdctl (int)
     void __builtin_wrctl (int, int)

 The following built-in functions are always available.  They all
generate a Nios II Custom Instruction.  The name of the function
represents the types that the function takes and returns.  The letter
before the 'n' is the return type or void if absent.  The 'n' represents
the first parameter to all the custom instructions, the custom
instruction number.  The two letters after the 'n' represent the up to
two parameters to the function.

 The letters represent the following data types:
'<no letter>'
     'void' for return type and no parameter for parameter types.

'i'
     'int' for return type and parameter type

'f'
     'float' for return type and parameter type

'p'
     'void *' for return type and parameter type

 And the function names are:
     void __builtin_custom_n (void)
     void __builtin_custom_ni (int)
     void __builtin_custom_nf (float)
     void __builtin_custom_np (void *)
     void __builtin_custom_nii (int, int)
     void __builtin_custom_nif (int, float)
     void __builtin_custom_nip (int, void *)
     void __builtin_custom_nfi (float, int)
     void __builtin_custom_nff (float, float)
     void __builtin_custom_nfp (float, void *)
     void __builtin_custom_npi (void *, int)
     void __builtin_custom_npf (void *, float)
     void __builtin_custom_npp (void *, void *)
     int __builtin_custom_in (void)
     int __builtin_custom_ini (int)
     int __builtin_custom_inf (float)
     int __builtin_custom_inp (void *)
     int __builtin_custom_inii (int, int)
     int __builtin_custom_inif (int, float)
     int __builtin_custom_inip (int, void *)
     int __builtin_custom_infi (float, int)
     int __builtin_custom_inff (float, float)
     int __builtin_custom_infp (float, void *)
     int __builtin_custom_inpi (void *, int)
     int __builtin_custom_inpf (void *, float)
     int __builtin_custom_inpp (void *, void *)
     float __builtin_custom_fn (void)
     float __builtin_custom_fni (int)
     float __builtin_custom_fnf (float)
     float __builtin_custom_fnp (void *)
     float __builtin_custom_fnii (int, int)
     float __builtin_custom_fnif (int, float)
     float __builtin_custom_fnip (int, void *)
     float __builtin_custom_fnfi (float, int)
     float __builtin_custom_fnff (float, float)
     float __builtin_custom_fnfp (float, void *)
     float __builtin_custom_fnpi (void *, int)
     float __builtin_custom_fnpf (void *, float)
     float __builtin_custom_fnpp (void *, void *)
     void * __builtin_custom_pn (void)
     void * __builtin_custom_pni (int)
     void * __builtin_custom_pnf (float)
     void * __builtin_custom_pnp (void *)
     void * __builtin_custom_pnii (int, int)
     void * __builtin_custom_pnif (int, float)
     void * __builtin_custom_pnip (int, void *)
     void * __builtin_custom_pnfi (float, int)
     void * __builtin_custom_pnff (float, float)
     void * __builtin_custom_pnfp (float, void *)
     void * __builtin_custom_pnpi (void *, int)
     void * __builtin_custom_pnpf (void *, float)
     void * __builtin_custom_pnpp (void *, void *)


File: llvm.info,  Node: ARC Built-in Functions,  Next: ARC SIMD Built-in Functions,  Prev: Altera Nios II Built-in Functions,  Up: Target Builtins

6.58.4 ARC Built-in Functions
-----------------------------

The following built-in functions are provided for ARC targets.  The
built-ins generate the corresponding assembly instructions.  In the
examples given below, the generated code often requires an operand or
result to be in a register.  Where necessary further code will be
generated to ensure this is true, but for brevity this is not described
in each case.

 _Note:_ Using a built-in to generate an instruction not supported by a
target may cause problems.  At present the compiler is not guaranteed to
detect such misuse, and as a result an internal compiler error may be
generated.

 -- Built-in Function: int __builtin_arc_aligned (void *VAL, int
          ALIGNVAL)
     Return 1 if VAL is known to have the byte alignment given by
     ALIGNVAL, otherwise return 0.  Note that this is different from
          __alignof__(*(char *)VAL) >= alignval
     because __alignof__ sees only the type of the dereference, whereas
     __builtin_arc_align uses alignment information from the pointer as
     well as from the pointed-to type.  The information available will
     depend on optimization level.

 -- Built-in Function: void __builtin_arc_brk (void)
     Generates
          brk

 -- Built-in Function: unsigned int __builtin_arc_core_read (unsigned
          int REGNO)
     The operand is the number of a register to be read.  Generates:
          mov  DEST, rREGNO
     where the value in DEST will be the result returned from the
     built-in.

 -- Built-in Function: void __builtin_arc_core_write (unsigned int
          REGNO, unsigned int VAL)
     The first operand is the number of a register to be written, the
     second operand is a compile time constant to write into that
     register.  Generates:
          mov  rREGNO, VAL

 -- Built-in Function: int __builtin_arc_divaw (int A, int B)
     Only available if either '-mcpu=ARC700' or '-meA' is set.
     Generates:
          divaw  DEST, A, B
     where the value in DEST will be the result returned from the
     built-in.

 -- Built-in Function: void __builtin_arc_flag (unsigned int A)
     Generates
          flag  A

 -- Built-in Function: unsigned int __builtin_arc_lr (unsigned int AUXR)
     The operand, AUXV, is the address of an auxiliary register and must
     be a compile time constant.  Generates:
          lr  DEST, [AUXR]
     Where the value in DEST will be the result returned from the
     built-in.

 -- Built-in Function: void __builtin_arc_mul64 (int A, int B)
     Only available with '-mmul64'.  Generates:
          mul64  A, B

 -- Built-in Function: void __builtin_arc_mulu64 (unsigned int A,
          unsigned int B)
     Only available with '-mmul64'.  Generates:
          mulu64  A, B

 -- Built-in Function: void __builtin_arc_nop (void)
     Generates:
          nop

 -- Built-in Function: int __builtin_arc_norm (int SRC)
     Only valid if the 'norm' instruction is available through the
     '-mnorm' option or by default with '-mcpu=ARC700'.  Generates:
          norm  DEST, SRC
     Where the value in DEST will be the result returned from the
     built-in.

 -- Built-in Function: short int __builtin_arc_normw (short int SRC)
     Only valid if the 'normw' instruction is available through the
     '-mnorm' option or by default with '-mcpu=ARC700'.  Generates:
          normw  DEST, SRC
     Where the value in DEST will be the result returned from the
     built-in.

 -- Built-in Function: void __builtin_arc_rtie (void)
     Generates:
          rtie

 -- Built-in Function: void __builtin_arc_sleep (int A
     Generates:
          sleep  A

 -- Built-in Function: void __builtin_arc_sr (unsigned int AUXR,
          unsigned int VAL)
     The first argument, AUXV, is the address of an auxiliary register,
     the second argument, VAL, is a compile time constant to be written
     to the register.  Generates:
          sr  AUXR, [VAL]

 -- Built-in Function: int __builtin_arc_swap (int SRC)
     Only valid with '-mswap'.  Generates:
          swap  DEST, SRC
     Where the value in DEST will be the result returned from the
     built-in.

 -- Built-in Function: void __builtin_arc_swi (void)
     Generates:
          swi

 -- Built-in Function: void __builtin_arc_sync (void)
     Only available with '-mcpu=ARC700'.  Generates:
          sync

 -- Built-in Function: void __builtin_arc_trap_s (unsigned int C)
     Only available with '-mcpu=ARC700'.  Generates:
          trap_s  C

 -- Built-in Function: void __builtin_arc_unimp_s (void)
     Only available with '-mcpu=ARC700'.  Generates:
          unimp_s

 The instructions generated by the following builtins are not considered
as candidates for scheduling.  They are not moved around by the compiler
during scheduling, and thus can be expected to appear where they are put
in the C code:
     __builtin_arc_brk()
     __builtin_arc_core_read()
     __builtin_arc_core_write()
     __builtin_arc_flag()
     __builtin_arc_lr()
     __builtin_arc_sleep()
     __builtin_arc_sr()
     __builtin_arc_swi()


File: llvm.info,  Node: ARC SIMD Built-in Functions,  Next: ARM iWMMXt Built-in Functions,  Prev: ARC Built-in Functions,  Up: Target Builtins

6.58.5 ARC SIMD Built-in Functions
----------------------------------

SIMD builtins provided by the compiler can be used to generate the
vector instructions.  This section describes the available builtins and
their usage in programs.  With the '-msimd' option, the compiler
provides 128-bit vector types, which can be specified using the
'vector_size' attribute.  The header file 'arc-simd.h' can be included
to use the following predefined types:
     typedef int __v4si   __attribute__((vector_size(16)));
     typedef short __v8hi __attribute__((vector_size(16)));

 These types can be used to define 128-bit variables.  The built-in
functions listed in the following section can be used on these variables
to generate the vector operations.

 For all builtins, '__builtin_arc_SOMEINSN', the header file
'arc-simd.h' also provides equivalent macros called '_SOMEINSN' that can
be used for programming ease and improved readability.  The following
macros for DMA control are also provided:
     #define _setup_dma_in_channel_reg _vdiwr
     #define _setup_dma_out_channel_reg _vdowr

 The following is a complete list of all the SIMD built-ins provided for
ARC, grouped by calling signature.

 The following take two '__v8hi' arguments and return a '__v8hi' result:
     __v8hi __builtin_arc_vaddaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vaddw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vand (__v8hi, __v8hi)
     __v8hi __builtin_arc_vandaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vavb (__v8hi, __v8hi)
     __v8hi __builtin_arc_vavrb (__v8hi, __v8hi)
     __v8hi __builtin_arc_vbic (__v8hi, __v8hi)
     __v8hi __builtin_arc_vbicaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vdifaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vdifw (__v8hi, __v8hi)
     __v8hi __builtin_arc_veqw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vh264f (__v8hi, __v8hi)
     __v8hi __builtin_arc_vh264ft (__v8hi, __v8hi)
     __v8hi __builtin_arc_vh264fw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vlew (__v8hi, __v8hi)
     __v8hi __builtin_arc_vltw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmaxaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmaxw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vminaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vminw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr1aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr1w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr2aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr2w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr3aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr3w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr4aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr4w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr5aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr5w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr6aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr6w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr7aw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmr7w (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmrb (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmulaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmulfaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmulfw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vmulw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vnew (__v8hi, __v8hi)
     __v8hi __builtin_arc_vor (__v8hi, __v8hi)
     __v8hi __builtin_arc_vsubaw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vsubw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vsummw (__v8hi, __v8hi)
     __v8hi __builtin_arc_vvc1f (__v8hi, __v8hi)
     __v8hi __builtin_arc_vvc1ft (__v8hi, __v8hi)
     __v8hi __builtin_arc_vxor (__v8hi, __v8hi)
     __v8hi __builtin_arc_vxoraw (__v8hi, __v8hi)

 The following take one '__v8hi' and one 'int' argument and return a
'__v8hi' result:

     __v8hi __builtin_arc_vbaddw (__v8hi, int)
     __v8hi __builtin_arc_vbmaxw (__v8hi, int)
     __v8hi __builtin_arc_vbminw (__v8hi, int)
     __v8hi __builtin_arc_vbmulaw (__v8hi, int)
     __v8hi __builtin_arc_vbmulfw (__v8hi, int)
     __v8hi __builtin_arc_vbmulw (__v8hi, int)
     __v8hi __builtin_arc_vbrsubw (__v8hi, int)
     __v8hi __builtin_arc_vbsubw (__v8hi, int)

 The following take one '__v8hi' argument and one 'int' argument which
must be a 3-bit compile time constant indicating a register number
I0-I7.  They return a '__v8hi' result.
     __v8hi __builtin_arc_vasrw (__v8hi, const int)
     __v8hi __builtin_arc_vsr8 (__v8hi, const int)
     __v8hi __builtin_arc_vsr8aw (__v8hi, const int)

 The following take one '__v8hi' argument and one 'int' argument which
must be a 6-bit compile time constant.  They return a '__v8hi' result.
     __v8hi __builtin_arc_vasrpwbi (__v8hi, const int)
     __v8hi __builtin_arc_vasrrpwbi (__v8hi, const int)
     __v8hi __builtin_arc_vasrrwi (__v8hi, const int)
     __v8hi __builtin_arc_vasrsrwi (__v8hi, const int)
     __v8hi __builtin_arc_vasrwi (__v8hi, const int)
     __v8hi __builtin_arc_vsr8awi (__v8hi, const int)
     __v8hi __builtin_arc_vsr8i (__v8hi, const int)

 The following take one '__v8hi' argument and one 'int' argument which
must be a 8-bit compile time constant.  They return a '__v8hi' result.
     __v8hi __builtin_arc_vd6tapf (__v8hi, const int)
     __v8hi __builtin_arc_vmvaw (__v8hi, const int)
     __v8hi __builtin_arc_vmvw (__v8hi, const int)
     __v8hi __builtin_arc_vmvzw (__v8hi, const int)

 The following take two 'int' arguments, the second of which which must
be a 8-bit compile time constant.  They return a '__v8hi' result:
     __v8hi __builtin_arc_vmovaw (int, const int)
     __v8hi __builtin_arc_vmovw (int, const int)
     __v8hi __builtin_arc_vmovzw (int, const int)

 The following take a single '__v8hi' argument and return a '__v8hi'
result:
     __v8hi __builtin_arc_vabsaw (__v8hi)
     __v8hi __builtin_arc_vabsw (__v8hi)
     __v8hi __builtin_arc_vaddsuw (__v8hi)
     __v8hi __builtin_arc_vexch1 (__v8hi)
     __v8hi __builtin_arc_vexch2 (__v8hi)
     __v8hi __builtin_arc_vexch4 (__v8hi)
     __v8hi __builtin_arc_vsignw (__v8hi)
     __v8hi __builtin_arc_vupbaw (__v8hi)
     __v8hi __builtin_arc_vupbw (__v8hi)
     __v8hi __builtin_arc_vupsbaw (__v8hi)
     __v8hi __builtin_arc_vupsbw (__v8hi)

 The following take two 'int' arguments and return no result:
     void __builtin_arc_vdirun (int, int)
     void __builtin_arc_vdorun (int, int)

 The following take two 'int' arguments and return no result.  The first
argument must a 3-bit compile time constant indicating one of the
DR0-DR7 DMA setup channels:
     void __builtin_arc_vdiwr (const int, int)
     void __builtin_arc_vdowr (const int, int)

 The following take an 'int' argument and return no result:
     void __builtin_arc_vendrec (int)
     void __builtin_arc_vrec (int)
     void __builtin_arc_vrecrun (int)
     void __builtin_arc_vrun (int)

 The following take a '__v8hi' argument and two 'int' arguments and
return a '__v8hi' result.  The second argument must be a 3-bit compile
time constants, indicating one the registers I0-I7, and the third
argument must be an 8-bit compile time constant.

 _Note:_ Although the equivalent hardware instructions do not take an
SIMD register as an operand, these builtins overwrite the relevant bits
of the '__v8hi' register provided as the first argument with the value
loaded from the '[Ib, u8]' location in the SDM.

     __v8hi __builtin_arc_vld32 (__v8hi, const int, const int)
     __v8hi __builtin_arc_vld32wh (__v8hi, const int, const int)
     __v8hi __builtin_arc_vld32wl (__v8hi, const int, const int)
     __v8hi __builtin_arc_vld64 (__v8hi, const int, const int)

 The following take two 'int' arguments and return a '__v8hi' result.
The first argument must be a 3-bit compile time constants, indicating
one the registers I0-I7, and the second argument must be an 8-bit
compile time constant.

     __v8hi __builtin_arc_vld128 (const int, const int)
     __v8hi __builtin_arc_vld64w (const int, const int)

 The following take a '__v8hi' argument and two 'int' arguments and
return no result.  The second argument must be a 3-bit compile time
constants, indicating one the registers I0-I7, and the third argument
must be an 8-bit compile time constant.

     void __builtin_arc_vst128 (__v8hi, const int, const int)
     void __builtin_arc_vst64 (__v8hi, const int, const int)

 The following take a '__v8hi' argument and three 'int' arguments and
return no result.  The second argument must be a 3-bit compile-time
constant, identifying the 16-bit sub-register to be stored, the third
argument must be a 3-bit compile time constants, indicating one the
registers I0-I7, and the fourth argument must be an 8-bit compile time
constant.

     void __builtin_arc_vst16_n (__v8hi, const int, const int, const int)
     void __builtin_arc_vst32_n (__v8hi, const int, const int, const int)


File: llvm.info,  Node: ARM iWMMXt Built-in Functions,  Next: ARM C Language Extensions (ACLE),  Prev: ARC SIMD Built-in Functions,  Up: Target Builtins

6.58.6 ARM iWMMXt Built-in Functions
------------------------------------

These built-in functions are available for the ARM family of processors
when the '-mcpu=iwmmxt' switch is used:

     typedef int v2si __attribute__ ((vector_size (8)));
     typedef short v4hi __attribute__ ((vector_size (8)));
     typedef char v8qi __attribute__ ((vector_size (8)));

     int __builtin_arm_getwcgr0 (void)
     void __builtin_arm_setwcgr0 (int)
     int __builtin_arm_getwcgr1 (void)
     void __builtin_arm_setwcgr1 (int)
     int __builtin_arm_getwcgr2 (void)
     void __builtin_arm_setwcgr2 (int)
     int __builtin_arm_getwcgr3 (void)
     void __builtin_arm_setwcgr3 (int)
     int __builtin_arm_textrmsb (v8qi, int)
     int __builtin_arm_textrmsh (v4hi, int)
     int __builtin_arm_textrmsw (v2si, int)
     int __builtin_arm_textrmub (v8qi, int)
     int __builtin_arm_textrmuh (v4hi, int)
     int __builtin_arm_textrmuw (v2si, int)
     v8qi __builtin_arm_tinsrb (v8qi, int, int)
     v4hi __builtin_arm_tinsrh (v4hi, int, int)
     v2si __builtin_arm_tinsrw (v2si, int, int)
     long long __builtin_arm_tmia (long long, int, int)
     long long __builtin_arm_tmiabb (long long, int, int)
     long long __builtin_arm_tmiabt (long long, int, int)
     long long __builtin_arm_tmiaph (long long, int, int)
     long long __builtin_arm_tmiatb (long long, int, int)
     long long __builtin_arm_tmiatt (long long, int, int)
     int __builtin_arm_tmovmskb (v8qi)
     int __builtin_arm_tmovmskh (v4hi)
     int __builtin_arm_tmovmskw (v2si)
     long long __builtin_arm_waccb (v8qi)
     long long __builtin_arm_wacch (v4hi)
     long long __builtin_arm_waccw (v2si)
     v8qi __builtin_arm_waddb (v8qi, v8qi)
     v8qi __builtin_arm_waddbss (v8qi, v8qi)
     v8qi __builtin_arm_waddbus (v8qi, v8qi)
     v4hi __builtin_arm_waddh (v4hi, v4hi)
     v4hi __builtin_arm_waddhss (v4hi, v4hi)
     v4hi __builtin_arm_waddhus (v4hi, v4hi)
     v2si __builtin_arm_waddw (v2si, v2si)
     v2si __builtin_arm_waddwss (v2si, v2si)
     v2si __builtin_arm_waddwus (v2si, v2si)
     v8qi __builtin_arm_walign (v8qi, v8qi, int)
     long long __builtin_arm_wand(long long, long long)
     long long __builtin_arm_wandn (long long, long long)
     v8qi __builtin_arm_wavg2b (v8qi, v8qi)
     v8qi __builtin_arm_wavg2br (v8qi, v8qi)
     v4hi __builtin_arm_wavg2h (v4hi, v4hi)
     v4hi __builtin_arm_wavg2hr (v4hi, v4hi)
     v8qi __builtin_arm_wcmpeqb (v8qi, v8qi)
     v4hi __builtin_arm_wcmpeqh (v4hi, v4hi)
     v2si __builtin_arm_wcmpeqw (v2si, v2si)
     v8qi __builtin_arm_wcmpgtsb (v8qi, v8qi)
     v4hi __builtin_arm_wcmpgtsh (v4hi, v4hi)
     v2si __builtin_arm_wcmpgtsw (v2si, v2si)
     v8qi __builtin_arm_wcmpgtub (v8qi, v8qi)
     v4hi __builtin_arm_wcmpgtuh (v4hi, v4hi)
     v2si __builtin_arm_wcmpgtuw (v2si, v2si)
     long long __builtin_arm_wmacs (long long, v4hi, v4hi)
     long long __builtin_arm_wmacsz (v4hi, v4hi)
     long long __builtin_arm_wmacu (long long, v4hi, v4hi)
     long long __builtin_arm_wmacuz (v4hi, v4hi)
     v4hi __builtin_arm_wmadds (v4hi, v4hi)
     v4hi __builtin_arm_wmaddu (v4hi, v4hi)
     v8qi __builtin_arm_wmaxsb (v8qi, v8qi)
     v4hi __builtin_arm_wmaxsh (v4hi, v4hi)
     v2si __builtin_arm_wmaxsw (v2si, v2si)
     v8qi __builtin_arm_wmaxub (v8qi, v8qi)
     v4hi __builtin_arm_wmaxuh (v4hi, v4hi)
     v2si __builtin_arm_wmaxuw (v2si, v2si)
     v8qi __builtin_arm_wminsb (v8qi, v8qi)
     v4hi __builtin_arm_wminsh (v4hi, v4hi)
     v2si __builtin_arm_wminsw (v2si, v2si)
     v8qi __builtin_arm_wminub (v8qi, v8qi)
     v4hi __builtin_arm_wminuh (v4hi, v4hi)
     v2si __builtin_arm_wminuw (v2si, v2si)
     v4hi __builtin_arm_wmulsm (v4hi, v4hi)
     v4hi __builtin_arm_wmulul (v4hi, v4hi)
     v4hi __builtin_arm_wmulum (v4hi, v4hi)
     long long __builtin_arm_wor (long long, long long)
     v2si __builtin_arm_wpackdss (long long, long long)
     v2si __builtin_arm_wpackdus (long long, long long)
     v8qi __builtin_arm_wpackhss (v4hi, v4hi)
     v8qi __builtin_arm_wpackhus (v4hi, v4hi)
     v4hi __builtin_arm_wpackwss (v2si, v2si)
     v4hi __builtin_arm_wpackwus (v2si, v2si)
     long long __builtin_arm_wrord (long long, long long)
     long long __builtin_arm_wrordi (long long, int)
     v4hi __builtin_arm_wrorh (v4hi, long long)
     v4hi __builtin_arm_wrorhi (v4hi, int)
     v2si __builtin_arm_wrorw (v2si, long long)
     v2si __builtin_arm_wrorwi (v2si, int)
     v2si __builtin_arm_wsadb (v2si, v8qi, v8qi)
     v2si __builtin_arm_wsadbz (v8qi, v8qi)
     v2si __builtin_arm_wsadh (v2si, v4hi, v4hi)
     v2si __builtin_arm_wsadhz (v4hi, v4hi)
     v4hi __builtin_arm_wshufh (v4hi, int)
     long long __builtin_arm_wslld (long long, long long)
     long long __builtin_arm_wslldi (long long, int)
     v4hi __builtin_arm_wsllh (v4hi, long long)
     v4hi __builtin_arm_wsllhi (v4hi, int)
     v2si __builtin_arm_wsllw (v2si, long long)
     v2si __builtin_arm_wsllwi (v2si, int)
     long long __builtin_arm_wsrad (long long, long long)
     long long __builtin_arm_wsradi (long long, int)
     v4hi __builtin_arm_wsrah (v4hi, long long)
     v4hi __builtin_arm_wsrahi (v4hi, int)
     v2si __builtin_arm_wsraw (v2si, long long)
     v2si __builtin_arm_wsrawi (v2si, int)
     long long __builtin_arm_wsrld (long long, long long)
     long long __builtin_arm_wsrldi (long long, int)
     v4hi __builtin_arm_wsrlh (v4hi, long long)
     v4hi __builtin_arm_wsrlhi (v4hi, int)
     v2si __builtin_arm_wsrlw (v2si, long long)
     v2si __builtin_arm_wsrlwi (v2si, int)
     v8qi __builtin_arm_wsubb (v8qi, v8qi)
     v8qi __builtin_arm_wsubbss (v8qi, v8qi)
     v8qi __builtin_arm_wsubbus (v8qi, v8qi)
     v4hi __builtin_arm_wsubh (v4hi, v4hi)
     v4hi __builtin_arm_wsubhss (v4hi, v4hi)
     v4hi __builtin_arm_wsubhus (v4hi, v4hi)
     v2si __builtin_arm_wsubw (v2si, v2si)
     v2si __builtin_arm_wsubwss (v2si, v2si)
     v2si __builtin_arm_wsubwus (v2si, v2si)
     v4hi __builtin_arm_wunpckehsb (v8qi)
     v2si __builtin_arm_wunpckehsh (v4hi)
     long long __builtin_arm_wunpckehsw (v2si)
     v4hi __builtin_arm_wunpckehub (v8qi)
     v2si __builtin_arm_wunpckehuh (v4hi)
     long long __builtin_arm_wunpckehuw (v2si)
     v4hi __builtin_arm_wunpckelsb (v8qi)
     v2si __builtin_arm_wunpckelsh (v4hi)
     long long __builtin_arm_wunpckelsw (v2si)
     v4hi __builtin_arm_wunpckelub (v8qi)
     v2si __builtin_arm_wunpckeluh (v4hi)
     long long __builtin_arm_wunpckeluw (v2si)
     v8qi __builtin_arm_wunpckihb (v8qi, v8qi)
     v4hi __builtin_arm_wunpckihh (v4hi, v4hi)
     v2si __builtin_arm_wunpckihw (v2si, v2si)
     v8qi __builtin_arm_wunpckilb (v8qi, v8qi)
     v4hi __builtin_arm_wunpckilh (v4hi, v4hi)
     v2si __builtin_arm_wunpckilw (v2si, v2si)
     long long __builtin_arm_wxor (long long, long long)
     long long __builtin_arm_wzero ()


File: llvm.info,  Node: ARM C Language Extensions (ACLE),  Next: ARM Floating Point Status and Control Intrinsics,  Prev: ARM iWMMXt Built-in Functions,  Up: Target Builtins

6.58.7 ARM C Language Extensions (ACLE)
---------------------------------------

GCC implements extensions for C as described in the ARM C Language
Extensions (ACLE) specification, which can be found at
<http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf>.

 As a part of ACLE, GCC implements extensions for Advanced SIMD as
described in the ARM C Language Extensions Specification.  The complete
list of Advanced SIMD intrinsics can be found at
<http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf>.
The built-in intrinsics for the Advanced SIMD extension are available
when NEON is enabled.

 Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully.
Both back ends support CRC32 intrinsics from 'arm_acle.h'.  The ARM back
end's 16-bit floating-point Advanced SIMD intrinsics currently comply to
ACLE v1.1.  AArch64's back end does not have support for 16-bit floating
point Advanced SIMD intrinsics yet.

 See *note ARM Options:: and *note AArch64 Options:: for more
information on the availability of extensions.


File: llvm.info,  Node: ARM Floating Point Status and Control Intrinsics,  Next: AVR Built-in Functions,  Prev: ARM C Language Extensions (ACLE),  Up: Target Builtins

6.58.8 ARM Floating Point Status and Control Intrinsics
-------------------------------------------------------

These built-in functions are available for the ARM family of processors
with floating-point unit.

     unsigned int __builtin_arm_get_fpscr ()
     void __builtin_arm_set_fpscr (unsigned int)


File: llvm.info,  Node: AVR Built-in Functions,  Next: Blackfin Built-in Functions,  Prev: ARM Floating Point Status and Control Intrinsics,  Up: Target Builtins

6.58.9 AVR Built-in Functions
-----------------------------

For each built-in function for AVR, there is an equally named, uppercase
built-in macro defined.  That way users can easily query if or if not a
specific built-in is implemented or not.  For example, if
'__builtin_avr_nop' is available the macro '__BUILTIN_AVR_NOP' is
defined to '1' and undefined otherwise.

 The following built-in functions map to the respective machine
instruction, i.e. 'nop', 'sei', 'cli', 'sleep', 'wdr', 'swap', 'fmul',
'fmuls' resp.  'fmulsu'.  The three 'fmul*' built-ins are implemented as
library call if no hardware multiplier is available.

     void __builtin_avr_nop (void)
     void __builtin_avr_sei (void)
     void __builtin_avr_cli (void)
     void __builtin_avr_sleep (void)
     void __builtin_avr_wdr (void)
     unsigned char __builtin_avr_swap (unsigned char)
     unsigned int __builtin_avr_fmul (unsigned char, unsigned char)
     int __builtin_avr_fmuls (char, char)
     int __builtin_avr_fmulsu (char, unsigned char)

 In order to delay execution for a specific number of cycles, GCC
implements
     void __builtin_avr_delay_cycles (unsigned long ticks)

'ticks' is the number of ticks to delay execution.  Note that this
built-in does not take into account the effect of interrupts that might
increase delay time.  'ticks' must be a compile-time integer constant;
delays with a variable number of cycles are not supported.

     char __builtin_avr_flash_segment (const __memx void*)

This built-in takes a byte address to the 24-bit *note address space:
AVR Named Address Spaces. '__memx' and returns the number of the flash
segment (the 64 KiB chunk) where the address points to.  Counting starts
at '0'.  If the address does not point to flash memory, return '-1'.

     unsigned char __builtin_avr_insert_bits (unsigned long map, unsigned char bits, unsigned char val)

Insert bits from BITS into VAL and return the resulting value.  The
nibbles of MAP determine how the insertion is performed: Let X be the
N-th nibble of MAP
  1. If X is '0xf', then the N-th bit of VAL is returned unaltered.

  2. If X is in the range 0...7, then the N-th result bit is set to the
     X-th bit of BITS

  3. If X is in the range 8...'0xe', then the N-th result bit is
     undefined.

One typical use case for this built-in is adjusting input and output
values to non-contiguous port layouts.  Some examples:

     // same as val, bits is unused
     __builtin_avr_insert_bits (0xffffffff, bits, val)

     // same as bits, val is unused
     __builtin_avr_insert_bits (0x76543210, bits, val)

     // same as rotating bits by 4
     __builtin_avr_insert_bits (0x32107654, bits, 0)

     // high nibble of result is the high nibble of val
     // low nibble of result is the low nibble of bits
     __builtin_avr_insert_bits (0xffff3210, bits, val)

     // reverse the bit order of bits
     __builtin_avr_insert_bits (0x01234567, bits, 0)


File: llvm.info,  Node: Blackfin Built-in Functions,  Next: FR-V Built-in Functions,  Prev: AVR Built-in Functions,  Up: Target Builtins

6.58.10 Blackfin Built-in Functions
-----------------------------------

Currently, there are two Blackfin-specific built-in functions.  These
are used for generating 'CSYNC' and 'SSYNC' machine insns without using
inline assembly; by using these built-in functions the compiler can
automatically add workarounds for hardware errata involving these
instructions.  These functions are named as follows:

     void __builtin_bfin_csync (void)
     void __builtin_bfin_ssync (void)


File: llvm.info,  Node: FR-V Built-in Functions,  Next: MIPS DSP Built-in Functions,  Prev: Blackfin Built-in Functions,  Up: Target Builtins

6.58.11 FR-V Built-in Functions
-------------------------------

GCC provides many FR-V-specific built-in functions.  In general, these
functions are intended to be compatible with those described by 'FR-V
Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor'.  The
two exceptions are '__MDUNPACKH' and '__MBTOHE', the GCC forms of which
pass 128-bit values by pointer rather than by value.

 Most of the functions are named after specific FR-V instructions.  Such
functions are said to be "directly mapped" and are summarized here in
tabular form.

* Menu:

* Argument Types::
* Directly-mapped Integer Functions::
* Directly-mapped Media Functions::
* Raw read/write Functions::
* Other Built-in Functions::


File: llvm.info,  Node: Argument Types,  Next: Directly-mapped Integer Functions,  Up: FR-V Built-in Functions

6.58.11.1 Argument Types
........................

The arguments to the built-in functions can be divided into three
groups: register numbers, compile-time constants and run-time values.
In order to make this classification clear at a glance, the arguments
and return values are given the following pseudo types:

Pseudo type    Real C type            Constant?   Description
'uh'           'unsigned short'       No          an unsigned halfword
'uw1'          'unsigned int'         No          an unsigned word
'sw1'          'int'                  No          a signed word
'uw2'          'unsigned long long'   No          an unsigned doubleword
'sw2'          'long long'            No          a signed doubleword
'const'        'int'                  Yes         an integer constant
'acc'          'int'                  Yes         an ACC register number
'iacc'         'int'                  Yes         an IACC register number

 These pseudo types are not defined by GCC, they are simply a notational
convenience used in this manual.

 Arguments of type 'uh', 'uw1', 'sw1', 'uw2' and 'sw2' are evaluated at
run time.  They correspond to register operands in the underlying FR-V
instructions.

 'const' arguments represent immediate operands in the underlying FR-V
instructions.  They must be compile-time constants.

 'acc' arguments are evaluated at compile time and specify the number of
an accumulator register.  For example, an 'acc' argument of 2 selects
the ACC2 register.

 'iacc' arguments are similar to 'acc' arguments but specify the number
of an IACC register.  See *note Other Built-in Functions:: for more
details.


File: llvm.info,  Node: Directly-mapped Integer Functions,  Next: Directly-mapped Media Functions,  Prev: Argument Types,  Up: FR-V Built-in Functions

6.58.11.2 Directly-Mapped Integer Functions
...........................................

The functions listed below map directly to FR-V I-type instructions.

Function prototype               Example usage           Assembly output
'sw1 __ADDSS (sw1, sw1)'         'C = __ADDSS (A, B)'    'ADDSS A,B,C'
'sw1 __SCAN (sw1, sw1)'          'C = __SCAN (A, B)'     'SCAN A,B,C'
'sw1 __SCUTSS (sw1)'             'B = __SCUTSS (A)'      'SCUTSS A,B'
'sw1 __SLASS (sw1, sw1)'         'C = __SLASS (A, B)'    'SLASS A,B,C'
'void __SMASS (sw1, sw1)'        '__SMASS (A, B)'        'SMASS A,B'
'void __SMSSS (sw1, sw1)'        '__SMSSS (A, B)'        'SMSSS A,B'
'void __SMU (sw1, sw1)'          '__SMU (A, B)'          'SMU A,B'
'sw2 __SMUL (sw1, sw1)'          'C = __SMUL (A, B)'     'SMUL A,B,C'
'sw1 __SUBSS (sw1, sw1)'         'C = __SUBSS (A, B)'    'SUBSS A,B,C'
'uw2 __UMUL (uw1, uw1)'          'C = __UMUL (A, B)'     'UMUL A,B,C'


File: llvm.info,  Node: Directly-mapped Media Functions,  Next: Raw read/write Functions,  Prev: Directly-mapped Integer Functions,  Up: FR-V Built-in Functions

6.58.11.3 Directly-Mapped Media Functions
.........................................

The functions listed below map directly to FR-V M-type instructions.

Function prototype               Example usage           Assembly output
'uw1 __MABSHS (sw1)'             'B = __MABSHS (A)'      'MABSHS A,B'
'void __MADDACCS (acc, acc)'     '__MADDACCS (B, A)'     'MADDACCS A,B'
'sw1 __MADDHSS (sw1, sw1)'       'C = __MADDHSS (A,      'MADDHSS A,B,C'
                                 B)'
'uw1 __MADDHUS (uw1, uw1)'       'C = __MADDHUS (A,      'MADDHUS A,B,C'
                                 B)'
'uw1 __MAND (uw1, uw1)'          'C = __MAND (A, B)'     'MAND A,B,C'
'void __MASACCS (acc, acc)'      '__MASACCS (B, A)'      'MASACCS A,B'
'uw1 __MAVEH (uw1, uw1)'         'C = __MAVEH (A, B)'    'MAVEH A,B,C'
'uw2 __MBTOH (uw1)'              'B = __MBTOH (A)'       'MBTOH A,B'
'void __MBTOHE (uw1 *, uw1)'     '__MBTOHE (&B, A)'      'MBTOHE A,B'
'void __MCLRACC (acc)'           '__MCLRACC (A)'         'MCLRACC A'
'void __MCLRACCA (void)'         '__MCLRACCA ()'         'MCLRACCA'
'uw1 __Mcop1 (uw1, uw1)'         'C = __Mcop1 (A, B)'    'Mcop1 A,B,C'
'uw1 __Mcop2 (uw1, uw1)'         'C = __Mcop2 (A, B)'    'Mcop2 A,B,C'
'uw1 __MCPLHI (uw2, const)'      'C = __MCPLHI (A, B)'   'MCPLHI A,#B,C'
'uw1 __MCPLI (uw2, const)'       'C = __MCPLI (A, B)'    'MCPLI A,#B,C'
'void __MCPXIS (acc, sw1,        '__MCPXIS (C, A, B)'    'MCPXIS A,B,C'
sw1)'
'void __MCPXIU (acc, uw1,        '__MCPXIU (C, A, B)'    'MCPXIU A,B,C'
uw1)'
'void __MCPXRS (acc, sw1,        '__MCPXRS (C, A, B)'    'MCPXRS A,B,C'
sw1)'
'void __MCPXRU (acc, uw1,        '__MCPXRU (C, A, B)'    'MCPXRU A,B,C'
uw1)'
'uw1 __MCUT (acc, uw1)'          'C = __MCUT (A, B)'     'MCUT A,B,C'
'uw1 __MCUTSS (acc, sw1)'        'C = __MCUTSS (A, B)'   'MCUTSS A,B,C'
'void __MDADDACCS (acc, acc)'    '__MDADDACCS (B, A)'    'MDADDACCS A,B'
'void __MDASACCS (acc, acc)'     '__MDASACCS (B, A)'     'MDASACCS A,B'
'uw2 __MDCUTSSI (acc, const)'    'C = __MDCUTSSI (A,     'MDCUTSSI
                                 B)'                     A,#B,C'
'uw2 __MDPACKH (uw2, uw2)'       'C = __MDPACKH (A,      'MDPACKH A,B,C'
                                 B)'
'uw2 __MDROTLI (uw2, const)'     'C = __MDROTLI (A,      'MDROTLI
                                 B)'                     A,#B,C'
'void __MDSUBACCS (acc, acc)'    '__MDSUBACCS (B, A)'    'MDSUBACCS A,B'
'void __MDUNPACKH (uw1 *,        '__MDUNPACKH (&B, A)'   'MDUNPACKH A,B'
uw2)'
'uw2 __MEXPDHD (uw1, const)'     'C = __MEXPDHD (A,      'MEXPDHD
                                 B)'                     A,#B,C'
'uw1 __MEXPDHW (uw1, const)'     'C = __MEXPDHW (A,      'MEXPDHW
                                 B)'                     A,#B,C'
'uw1 __MHDSETH (uw1, const)'     'C = __MHDSETH (A,      'MHDSETH
                                 B)'                     A,#B,C'
'sw1 __MHDSETS (const)'          'B = __MHDSETS (A)'     'MHDSETS #A,B'
'uw1 __MHSETHIH (uw1, const)'    'B = __MHSETHIH (B,     'MHSETHIH #A,B'
                                 A)'
'sw1 __MHSETHIS (sw1, const)'    'B = __MHSETHIS (B,     'MHSETHIS #A,B'
                                 A)'
'uw1 __MHSETLOH (uw1, const)'    'B = __MHSETLOH (B,     'MHSETLOH #A,B'
                                 A)'
'sw1 __MHSETLOS (sw1, const)'    'B = __MHSETLOS (B,     'MHSETLOS #A,B'
                                 A)'
'uw1 __MHTOB (uw2)'              'B = __MHTOB (A)'       'MHTOB A,B'
'void __MMACHS (acc, sw1,        '__MMACHS (C, A, B)'    'MMACHS A,B,C'
sw1)'
'void __MMACHU (acc, uw1,        '__MMACHU (C, A, B)'    'MMACHU A,B,C'
uw1)'
'void __MMRDHS (acc, sw1,        '__MMRDHS (C, A, B)'    'MMRDHS A,B,C'
sw1)'
'void __MMRDHU (acc, uw1,        '__MMRDHU (C, A, B)'    'MMRDHU A,B,C'
uw1)'
'void __MMULHS (acc, sw1,        '__MMULHS (C, A, B)'    'MMULHS A,B,C'
sw1)'
'void __MMULHU (acc, uw1,        '__MMULHU (C, A, B)'    'MMULHU A,B,C'
uw1)'
'void __MMULXHS (acc, sw1,       '__MMULXHS (C, A, B)'   'MMULXHS A,B,C'
sw1)'
'void __MMULXHU (acc, uw1,       '__MMULXHU (C, A, B)'   'MMULXHU A,B,C'
uw1)'
'uw1 __MNOT (uw1)'               'B = __MNOT (A)'        'MNOT A,B'
'uw1 __MOR (uw1, uw1)'           'C = __MOR (A, B)'      'MOR A,B,C'
'uw1 __MPACKH (uh, uh)'          'C = __MPACKH (A, B)'   'MPACKH A,B,C'
'sw2 __MQADDHSS (sw2, sw2)'      'C = __MQADDHSS (A,     'MQADDHSS
                                 B)'                     A,B,C'
'uw2 __MQADDHUS (uw2, uw2)'      'C = __MQADDHUS (A,     'MQADDHUS
                                 B)'                     A,B,C'
'void __MQCPXIS (acc, sw2,       '__MQCPXIS (C, A, B)'   'MQCPXIS A,B,C'
sw2)'
'void __MQCPXIU (acc, uw2,       '__MQCPXIU (C, A, B)'   'MQCPXIU A,B,C'
uw2)'
'void __MQCPXRS (acc, sw2,       '__MQCPXRS (C, A, B)'   'MQCPXRS A,B,C'
sw2)'
'void __MQCPXRU (acc, uw2,       '__MQCPXRU (C, A, B)'   'MQCPXRU A,B,C'
uw2)'
'sw2 __MQLCLRHS (sw2, sw2)'      'C = __MQLCLRHS (A,     'MQLCLRHS
                                 B)'                     A,B,C'
'sw2 __MQLMTHS (sw2, sw2)'       'C = __MQLMTHS (A,      'MQLMTHS A,B,C'
                                 B)'
'void __MQMACHS (acc, sw2,       '__MQMACHS (C, A, B)'   'MQMACHS A,B,C'
sw2)'
'void __MQMACHU (acc, uw2,       '__MQMACHU (C, A, B)'   'MQMACHU A,B,C'
uw2)'
'void __MQMACXHS (acc, sw2,      '__MQMACXHS (C, A,      'MQMACXHS
sw2)'                            B)'                     A,B,C'
'void __MQMULHS (acc, sw2,       '__MQMULHS (C, A, B)'   'MQMULHS A,B,C'
sw2)'
'void __MQMULHU (acc, uw2,       '__MQMULHU (C, A, B)'   'MQMULHU A,B,C'
uw2)'
'void __MQMULXHS (acc, sw2,      '__MQMULXHS (C, A,      'MQMULXHS
sw2)'                            B)'                     A,B,C'
'void __MQMULXHU (acc, uw2,      '__MQMULXHU (C, A,      'MQMULXHU
uw2)'                            B)'                     A,B,C'
'sw2 __MQSATHS (sw2, sw2)'       'C = __MQSATHS (A,      'MQSATHS A,B,C'
                                 B)'
'uw2 __MQSLLHI (uw2, int)'       'C = __MQSLLHI (A,      'MQSLLHI A,B,C'
                                 B)'
'sw2 __MQSRAHI (sw2, int)'       'C = __MQSRAHI (A,      'MQSRAHI A,B,C'
                                 B)'
'sw2 __MQSUBHSS (sw2, sw2)'      'C = __MQSUBHSS (A,     'MQSUBHSS
                                 B)'                     A,B,C'
'uw2 __MQSUBHUS (uw2, uw2)'      'C = __MQSUBHUS (A,     'MQSUBHUS
                                 B)'                     A,B,C'
'void __MQXMACHS (acc, sw2,      '__MQXMACHS (C, A,      'MQXMACHS
sw2)'                            B)'                     A,B,C'
'void __MQXMACXHS (acc, sw2,     '__MQXMACXHS (C, A,     'MQXMACXHS
sw2)'                            B)'                     A,B,C'
'uw1 __MRDACC (acc)'             'B = __MRDACC (A)'      'MRDACC A,B'
'uw1 __MRDACCG (acc)'            'B = __MRDACCG (A)'     'MRDACCG A,B'
'uw1 __MROTLI (uw1, const)'      'C = __MROTLI (A, B)'   'MROTLI A,#B,C'
'uw1 __MROTRI (uw1, const)'      'C = __MROTRI (A, B)'   'MROTRI A,#B,C'
'sw1 __MSATHS (sw1, sw1)'        'C = __MSATHS (A, B)'   'MSATHS A,B,C'
'uw1 __MSATHU (uw1, uw1)'        'C = __MSATHU (A, B)'   'MSATHU A,B,C'
'uw1 __MSLLHI (uw1, const)'      'C = __MSLLHI (A, B)'   'MSLLHI A,#B,C'
'sw1 __MSRAHI (sw1, const)'      'C = __MSRAHI (A, B)'   'MSRAHI A,#B,C'
'uw1 __MSRLHI (uw1, const)'      'C = __MSRLHI (A, B)'   'MSRLHI A,#B,C'
'void __MSUBACCS (acc, acc)'     '__MSUBACCS (B, A)'     'MSUBACCS A,B'
'sw1 __MSUBHSS (sw1, sw1)'       'C = __MSUBHSS (A,      'MSUBHSS A,B,C'
                                 B)'
'uw1 __MSUBHUS (uw1, uw1)'       'C = __MSUBHUS (A,      'MSUBHUS A,B,C'
                                 B)'
'void __MTRAP (void)'            '__MTRAP ()'            'MTRAP'
'uw2 __MUNPACKH (uw1)'           'B = __MUNPACKH (A)'    'MUNPACKH A,B'
'uw1 __MWCUT (uw2, uw1)'         'C = __MWCUT (A, B)'    'MWCUT A,B,C'
'void __MWTACC (acc, uw1)'       '__MWTACC (B, A)'       'MWTACC A,B'
'void __MWTACCG (acc, uw1)'      '__MWTACCG (B, A)'      'MWTACCG A,B'
'uw1 __MXOR (uw1, uw1)'          'C = __MXOR (A, B)'     'MXOR A,B,C'


File: llvm.info,  Node: Raw read/write Functions,  Next: Other Built-in Functions,  Prev: Directly-mapped Media Functions,  Up: FR-V Built-in Functions

6.58.11.4 Raw Read/Write Functions
..................................

This sections describes built-in functions related to read and write
instructions to access memory.  These functions generate 'membar'
instructions to flush the I/O load and stores where appropriate, as
described in Fujitsu's manual described above.

'unsigned char __builtin_read8 (void *DATA)'
'unsigned short __builtin_read16 (void *DATA)'
'unsigned long __builtin_read32 (void *DATA)'
'unsigned long long __builtin_read64 (void *DATA)'

'void __builtin_write8 (void *DATA, unsigned char DATUM)'
'void __builtin_write16 (void *DATA, unsigned short DATUM)'
'void __builtin_write32 (void *DATA, unsigned long DATUM)'
'void __builtin_write64 (void *DATA, unsigned long long DATUM)'


File: llvm.info,  Node: Other Built-in Functions,  Prev: Raw read/write Functions,  Up: FR-V Built-in Functions

6.58.11.5 Other Built-in Functions
..................................

This section describes built-in functions that are not named after a
specific FR-V instruction.

'sw2 __IACCreadll (iacc REG)'
     Return the full 64-bit value of IACC0.  The REG argument is
     reserved for future expansion and must be 0.

'sw1 __IACCreadl (iacc REG)'
     Return the value of IACC0H if REG is 0 and IACC0L if REG is 1.
     Other values of REG are rejected as invalid.

'void __IACCsetll (iacc REG, sw2 X)'
     Set the full 64-bit value of IACC0 to X.  The REG argument is
     reserved for future expansion and must be 0.

'void __IACCsetl (iacc REG, sw1 X)'
     Set IACC0H to X if REG is 0 and IACC0L to X if REG is 1.  Other
     values of REG are rejected as invalid.

'void __data_prefetch0 (const void *X)'
     Use the 'dcpl' instruction to load the contents of address X into
     the data cache.

'void __data_prefetch (const void *X)'
     Use the 'nldub' instruction to load the contents of address X into
     the data cache.  The instruction is issued in slot I1.


File: llvm.info,  Node: MIPS DSP Built-in Functions,  Next: MIPS Paired-Single Support,  Prev: FR-V Built-in Functions,  Up: Target Builtins

6.58.12 MIPS DSP Built-in Functions
-----------------------------------

The MIPS DSP Application-Specific Extension (ASE) includes new
instructions that are designed to improve the performance of DSP and
media applications.  It provides instructions that operate on packed
8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.

 GCC supports MIPS DSP operations using both the generic vector
extensions (*note Vector Extensions::) and a collection of MIPS-specific
built-in functions.  Both kinds of support are enabled by the '-mdsp'
command-line option.

 Revision 2 of the ASE was introduced in the second half of 2006.  This
revision adds extra instructions to the original ASE, but is otherwise
backwards-compatible with it.  You can select revision 2 using the
command-line option '-mdspr2'; this option implies '-mdsp'.

 The SCOUNT and POS bits of the DSP control register are global.  The
WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and POS
bits.  During optimization, the compiler does not delete these
instructions and it does not delete calls to functions containing these
instructions.

 At present, GCC only provides support for operations on 32-bit vectors.
The vector type associated with 8-bit integer data is usually called
'v4i8', the vector type associated with Q7 is usually called 'v4q7', the
vector type associated with 16-bit integer data is usually called
'v2i16', and the vector type associated with Q15 is usually called
'v2q15'.  They can be defined in C as follows:

     typedef signed char v4i8 __attribute__ ((vector_size(4)));
     typedef signed char v4q7 __attribute__ ((vector_size(4)));
     typedef short v2i16 __attribute__ ((vector_size(4)));
     typedef short v2q15 __attribute__ ((vector_size(4)));

 'v4i8', 'v4q7', 'v2i16' and 'v2q15' values are initialized in the same
way as aggregates.  For example:

     v4i8 a = {1, 2, 3, 4};
     v4i8 b;
     b = (v4i8) {5, 6, 7, 8};

     v2q15 c = {0x0fcb, 0x3a75};
     v2q15 d;
     d = (v2q15) {0.1234 * 0x1.0p15, 0.4567 * 0x1.0p15};

 _Note:_ The CPU's endianness determines the order in which values are
packed.  On little-endian targets, the first value is the least
significant and the last value is the most significant.  The opposite
order applies to big-endian targets.  For example, the code above sets
the lowest byte of 'a' to '1' on little-endian targets and '4' on
big-endian targets.

 _Note:_ Q7, Q15 and Q31 values must be initialized with their integer
representation.  As shown in this example, the integer representation of
a Q7 value can be obtained by multiplying the fractional value by
'0x1.0p7'.  The equivalent for Q15 values is to multiply by '0x1.0p15'.
The equivalent for Q31 values is to multiply by '0x1.0p31'.

 The table below lists the 'v4i8' and 'v2q15' operations for which
hardware support exists.  'a' and 'b' are 'v4i8' values, and 'c' and 'd'
are 'v2q15' values.

C code                               MIPS instruction
'a + b'                              'addu.qb'
'c + d'                              'addq.ph'
'a - b'                              'subu.qb'
'c - d'                              'subq.ph'

 The table below lists the 'v2i16' operation for which hardware support
exists for the DSP ASE REV 2.  'e' and 'f' are 'v2i16' values.

C code                               MIPS instruction
'e * f'                              'mul.ph'

 It is easier to describe the DSP built-in functions if we first define
the following types:

     typedef int q31;
     typedef int i32;
     typedef unsigned int ui32;
     typedef long long a64;

 'q31' and 'i32' are actually the same as 'int', but we use 'q31' to
indicate a Q31 fractional value and 'i32' to indicate a 32-bit integer
value.  Similarly, 'a64' is the same as 'long long', but we use 'a64' to
indicate values that are placed in one of the four DSP accumulators
('$ac0', '$ac1', '$ac2' or '$ac3').

 Also, some built-in functions prefer or require immediate numbers as
parameters, because the corresponding DSP instructions accept both
immediate numbers and register operands, or accept immediate numbers
only.  The immediate parameters are listed as follows.

     imm0_3: 0 to 3.
     imm0_7: 0 to 7.
     imm0_15: 0 to 15.
     imm0_31: 0 to 31.
     imm0_63: 0 to 63.
     imm0_255: 0 to 255.
     imm_n32_31: -32 to 31.
     imm_n512_511: -512 to 511.

 The following built-in functions map directly to a particular MIPS DSP
instruction.  Please refer to the architecture specification for details
on what each instruction does.

     v2q15 __builtin_mips_addq_ph (v2q15, v2q15)
     v2q15 __builtin_mips_addq_s_ph (v2q15, v2q15)
     q31 __builtin_mips_addq_s_w (q31, q31)
     v4i8 __builtin_mips_addu_qb (v4i8, v4i8)
     v4i8 __builtin_mips_addu_s_qb (v4i8, v4i8)
     v2q15 __builtin_mips_subq_ph (v2q15, v2q15)
     v2q15 __builtin_mips_subq_s_ph (v2q15, v2q15)
     q31 __builtin_mips_subq_s_w (q31, q31)
     v4i8 __builtin_mips_subu_qb (v4i8, v4i8)
     v4i8 __builtin_mips_subu_s_qb (v4i8, v4i8)
     i32 __builtin_mips_addsc (i32, i32)
     i32 __builtin_mips_addwc (i32, i32)
     i32 __builtin_mips_modsub (i32, i32)
     i32 __builtin_mips_raddu_w_qb (v4i8)
     v2q15 __builtin_mips_absq_s_ph (v2q15)
     q31 __builtin_mips_absq_s_w (q31)
     v4i8 __builtin_mips_precrq_qb_ph (v2q15, v2q15)
     v2q15 __builtin_mips_precrq_ph_w (q31, q31)
     v2q15 __builtin_mips_precrq_rs_ph_w (q31, q31)
     v4i8 __builtin_mips_precrqu_s_qb_ph (v2q15, v2q15)
     q31 __builtin_mips_preceq_w_phl (v2q15)
     q31 __builtin_mips_preceq_w_phr (v2q15)
     v2q15 __builtin_mips_precequ_ph_qbl (v4i8)
     v2q15 __builtin_mips_precequ_ph_qbr (v4i8)
     v2q15 __builtin_mips_precequ_ph_qbla (v4i8)
     v2q15 __builtin_mips_precequ_ph_qbra (v4i8)
     v2q15 __builtin_mips_preceu_ph_qbl (v4i8)
     v2q15 __builtin_mips_preceu_ph_qbr (v4i8)
     v2q15 __builtin_mips_preceu_ph_qbla (v4i8)
     v2q15 __builtin_mips_preceu_ph_qbra (v4i8)
     v4i8 __builtin_mips_shll_qb (v4i8, imm0_7)
     v4i8 __builtin_mips_shll_qb (v4i8, i32)
     v2q15 __builtin_mips_shll_ph (v2q15, imm0_15)
     v2q15 __builtin_mips_shll_ph (v2q15, i32)
     v2q15 __builtin_mips_shll_s_ph (v2q15, imm0_15)
     v2q15 __builtin_mips_shll_s_ph (v2q15, i32)
     q31 __builtin_mips_shll_s_w (q31, imm0_31)
     q31 __builtin_mips_shll_s_w (q31, i32)
     v4i8 __builtin_mips_shrl_qb (v4i8, imm0_7)
     v4i8 __builtin_mips_shrl_qb (v4i8, i32)
     v2q15 __builtin_mips_shra_ph (v2q15, imm0_15)
     v2q15 __builtin_mips_shra_ph (v2q15, i32)
     v2q15 __builtin_mips_shra_r_ph (v2q15, imm0_15)
     v2q15 __builtin_mips_shra_r_ph (v2q15, i32)
     q31 __builtin_mips_shra_r_w (q31, imm0_31)
     q31 __builtin_mips_shra_r_w (q31, i32)
     v2q15 __builtin_mips_muleu_s_ph_qbl (v4i8, v2q15)
     v2q15 __builtin_mips_muleu_s_ph_qbr (v4i8, v2q15)
     v2q15 __builtin_mips_mulq_rs_ph (v2q15, v2q15)
     q31 __builtin_mips_muleq_s_w_phl (v2q15, v2q15)
     q31 __builtin_mips_muleq_s_w_phr (v2q15, v2q15)
     a64 __builtin_mips_dpau_h_qbl (a64, v4i8, v4i8)
     a64 __builtin_mips_dpau_h_qbr (a64, v4i8, v4i8)
     a64 __builtin_mips_dpsu_h_qbl (a64, v4i8, v4i8)
     a64 __builtin_mips_dpsu_h_qbr (a64, v4i8, v4i8)
     a64 __builtin_mips_dpaq_s_w_ph (a64, v2q15, v2q15)
     a64 __builtin_mips_dpaq_sa_l_w (a64, q31, q31)
     a64 __builtin_mips_dpsq_s_w_ph (a64, v2q15, v2q15)
     a64 __builtin_mips_dpsq_sa_l_w (a64, q31, q31)
     a64 __builtin_mips_mulsaq_s_w_ph (a64, v2q15, v2q15)
     a64 __builtin_mips_maq_s_w_phl (a64, v2q15, v2q15)
     a64 __builtin_mips_maq_s_w_phr (a64, v2q15, v2q15)
     a64 __builtin_mips_maq_sa_w_phl (a64, v2q15, v2q15)
     a64 __builtin_mips_maq_sa_w_phr (a64, v2q15, v2q15)
     i32 __builtin_mips_bitrev (i32)
     i32 __builtin_mips_insv (i32, i32)
     v4i8 __builtin_mips_repl_qb (imm0_255)
     v4i8 __builtin_mips_repl_qb (i32)
     v2q15 __builtin_mips_repl_ph (imm_n512_511)
     v2q15 __builtin_mips_repl_ph (i32)
     void __builtin_mips_cmpu_eq_qb (v4i8, v4i8)
     void __builtin_mips_cmpu_lt_qb (v4i8, v4i8)
     void __builtin_mips_cmpu_le_qb (v4i8, v4i8)
     i32 __builtin_mips_cmpgu_eq_qb (v4i8, v4i8)
     i32 __builtin_mips_cmpgu_lt_qb (v4i8, v4i8)
     i32 __builtin_mips_cmpgu_le_qb (v4i8, v4i8)
     void __builtin_mips_cmp_eq_ph (v2q15, v2q15)
     void __builtin_mips_cmp_lt_ph (v2q15, v2q15)
     void __builtin_mips_cmp_le_ph (v2q15, v2q15)
     v4i8 __builtin_mips_pick_qb (v4i8, v4i8)
     v2q15 __builtin_mips_pick_ph (v2q15, v2q15)
     v2q15 __builtin_mips_packrl_ph (v2q15, v2q15)
     i32 __builtin_mips_extr_w (a64, imm0_31)
     i32 __builtin_mips_extr_w (a64, i32)
     i32 __builtin_mips_extr_r_w (a64, imm0_31)
     i32 __builtin_mips_extr_s_h (a64, i32)
     i32 __builtin_mips_extr_rs_w (a64, imm0_31)
     i32 __builtin_mips_extr_rs_w (a64, i32)
     i32 __builtin_mips_extr_s_h (a64, imm0_31)
     i32 __builtin_mips_extr_r_w (a64, i32)
     i32 __builtin_mips_extp (a64, imm0_31)
     i32 __builtin_mips_extp (a64, i32)
     i32 __builtin_mips_extpdp (a64, imm0_31)
     i32 __builtin_mips_extpdp (a64, i32)
     a64 __builtin_mips_shilo (a64, imm_n32_31)
     a64 __builtin_mips_shilo (a64, i32)
     a64 __builtin_mips_mthlip (a64, i32)
     void __builtin_mips_wrdsp (i32, imm0_63)
     i32 __builtin_mips_rddsp (imm0_63)
     i32 __builtin_mips_lbux (void *, i32)
     i32 __builtin_mips_lhx (void *, i32)
     i32 __builtin_mips_lwx (void *, i32)
     a64 __builtin_mips_ldx (void *, i32) [MIPS64 only]
     i32 __builtin_mips_bposge32 (void)
     a64 __builtin_mips_madd (a64, i32, i32);
     a64 __builtin_mips_maddu (a64, ui32, ui32);
     a64 __builtin_mips_msub (a64, i32, i32);
     a64 __builtin_mips_msubu (a64, ui32, ui32);
     a64 __builtin_mips_mult (i32, i32);
     a64 __builtin_mips_multu (ui32, ui32);

 The following built-in functions map directly to a particular MIPS DSP
REV 2 instruction.  Please refer to the architecture specification for
details on what each instruction does.

     v4q7 __builtin_mips_absq_s_qb (v4q7);
     v2i16 __builtin_mips_addu_ph (v2i16, v2i16);
     v2i16 __builtin_mips_addu_s_ph (v2i16, v2i16);
     v4i8 __builtin_mips_adduh_qb (v4i8, v4i8);
     v4i8 __builtin_mips_adduh_r_qb (v4i8, v4i8);
     i32 __builtin_mips_append (i32, i32, imm0_31);
     i32 __builtin_mips_balign (i32, i32, imm0_3);
     i32 __builtin_mips_cmpgdu_eq_qb (v4i8, v4i8);
     i32 __builtin_mips_cmpgdu_lt_qb (v4i8, v4i8);
     i32 __builtin_mips_cmpgdu_le_qb (v4i8, v4i8);
     a64 __builtin_mips_dpa_w_ph (a64, v2i16, v2i16);
     a64 __builtin_mips_dps_w_ph (a64, v2i16, v2i16);
     v2i16 __builtin_mips_mul_ph (v2i16, v2i16);
     v2i16 __builtin_mips_mul_s_ph (v2i16, v2i16);
     q31 __builtin_mips_mulq_rs_w (q31, q31);
     v2q15 __builtin_mips_mulq_s_ph (v2q15, v2q15);
     q31 __builtin_mips_mulq_s_w (q31, q31);
     a64 __builtin_mips_mulsa_w_ph (a64, v2i16, v2i16);
     v4i8 __builtin_mips_precr_qb_ph (v2i16, v2i16);
     v2i16 __builtin_mips_precr_sra_ph_w (i32, i32, imm0_31);
     v2i16 __builtin_mips_precr_sra_r_ph_w (i32, i32, imm0_31);
     i32 __builtin_mips_prepend (i32, i32, imm0_31);
     v4i8 __builtin_mips_shra_qb (v4i8, imm0_7);
     v4i8 __builtin_mips_shra_r_qb (v4i8, imm0_7);
     v4i8 __builtin_mips_shra_qb (v4i8, i32);
     v4i8 __builtin_mips_shra_r_qb (v4i8, i32);
     v2i16 __builtin_mips_shrl_ph (v2i16, imm0_15);
     v2i16 __builtin_mips_shrl_ph (v2i16, i32);
     v2i16 __builtin_mips_subu_ph (v2i16, v2i16);
     v2i16 __builtin_mips_subu_s_ph (v2i16, v2i16);
     v4i8 __builtin_mips_subuh_qb (v4i8, v4i8);
     v4i8 __builtin_mips_subuh_r_qb (v4i8, v4i8);
     v2q15 __builtin_mips_addqh_ph (v2q15, v2q15);
     v2q15 __builtin_mips_addqh_r_ph (v2q15, v2q15);
     q31 __builtin_mips_addqh_w (q31, q31);
     q31 __builtin_mips_addqh_r_w (q31, q31);
     v2q15 __builtin_mips_subqh_ph (v2q15, v2q15);
     v2q15 __builtin_mips_subqh_r_ph (v2q15, v2q15);
     q31 __builtin_mips_subqh_w (q31, q31);
     q31 __builtin_mips_subqh_r_w (q31, q31);
     a64 __builtin_mips_dpax_w_ph (a64, v2i16, v2i16);
     a64 __builtin_mips_dpsx_w_ph (a64, v2i16, v2i16);
     a64 __builtin_mips_dpaqx_s_w_ph (a64, v2q15, v2q15);
     a64 __builtin_mips_dpaqx_sa_w_ph (a64, v2q15, v2q15);
     a64 __builtin_mips_dpsqx_s_w_ph (a64, v2q15, v2q15);
     a64 __builtin_mips_dpsqx_sa_w_ph (a64, v2q15, v2q15);


File: llvm.info,  Node: MIPS Paired-Single Support,  Next: MIPS Loongson Built-in Functions,  Prev: MIPS DSP Built-in Functions,  Up: Target Builtins

6.58.13 MIPS Paired-Single Support
----------------------------------

The MIPS64 architecture includes a number of instructions that operate
on pairs of single-precision floating-point values.  Each pair is packed
into a 64-bit floating-point register, with one element being designated
the "upper half" and the other being designated the "lower half".

 GCC supports paired-single operations using both the generic vector
extensions (*note Vector Extensions::) and a collection of MIPS-specific
built-in functions.  Both kinds of support are enabled by the
'-mpaired-single' command-line option.

 The vector type associated with paired-single values is usually called
'v2sf'.  It can be defined in C as follows:

     typedef float v2sf __attribute__ ((vector_size (8)));

 'v2sf' values are initialized in the same way as aggregates.  For
example:

     v2sf a = {1.5, 9.1};
     v2sf b;
     float e, f;
     b = (v2sf) {e, f};

 _Note:_ The CPU's endianness determines which value is stored in the
upper half of a register and which value is stored in the lower half.
On little-endian targets, the first value is the lower one and the
second value is the upper one.  The opposite order applies to big-endian
targets.  For example, the code above sets the lower half of 'a' to
'1.5' on little-endian targets and '9.1' on big-endian targets.


File: llvm.info,  Node: MIPS Loongson Built-in Functions,  Next: Other MIPS Built-in Functions,  Prev: MIPS Paired-Single Support,  Up: Target Builtins

6.58.14 MIPS Loongson Built-in Functions
----------------------------------------

GCC provides intrinsics to access the SIMD instructions provided by the
ST Microelectronics Loongson-2E and -2F processors.  These intrinsics,
available after inclusion of the 'loongson.h' header file, operate on
the following 64-bit vector types:

   * 'uint8x8_t', a vector of eight unsigned 8-bit integers;
   * 'uint16x4_t', a vector of four unsigned 16-bit integers;
   * 'uint32x2_t', a vector of two unsigned 32-bit integers;
   * 'int8x8_t', a vector of eight signed 8-bit integers;
   * 'int16x4_t', a vector of four signed 16-bit integers;
   * 'int32x2_t', a vector of two signed 32-bit integers.

 The intrinsics provided are listed below; each is named after the
machine instruction to which it corresponds, with suffixes added as
appropriate to distinguish intrinsics that expand to the same machine
instruction yet have different argument types.  Refer to the
architecture documentation for a description of the functionality of
each instruction.

     int16x4_t packsswh (int32x2_t s, int32x2_t t);
     int8x8_t packsshb (int16x4_t s, int16x4_t t);
     uint8x8_t packushb (uint16x4_t s, uint16x4_t t);
     uint32x2_t paddw_u (uint32x2_t s, uint32x2_t t);
     uint16x4_t paddh_u (uint16x4_t s, uint16x4_t t);
     uint8x8_t paddb_u (uint8x8_t s, uint8x8_t t);
     int32x2_t paddw_s (int32x2_t s, int32x2_t t);
     int16x4_t paddh_s (int16x4_t s, int16x4_t t);
     int8x8_t paddb_s (int8x8_t s, int8x8_t t);
     uint64_t paddd_u (uint64_t s, uint64_t t);
     int64_t paddd_s (int64_t s, int64_t t);
     int16x4_t paddsh (int16x4_t s, int16x4_t t);
     int8x8_t paddsb (int8x8_t s, int8x8_t t);
     uint16x4_t paddush (uint16x4_t s, uint16x4_t t);
     uint8x8_t paddusb (uint8x8_t s, uint8x8_t t);
     uint64_t pandn_ud (uint64_t s, uint64_t t);
     uint32x2_t pandn_uw (uint32x2_t s, uint32x2_t t);
     uint16x4_t pandn_uh (uint16x4_t s, uint16x4_t t);
     uint8x8_t pandn_ub (uint8x8_t s, uint8x8_t t);
     int64_t pandn_sd (int64_t s, int64_t t);
     int32x2_t pandn_sw (int32x2_t s, int32x2_t t);
     int16x4_t pandn_sh (int16x4_t s, int16x4_t t);
     int8x8_t pandn_sb (int8x8_t s, int8x8_t t);
     uint16x4_t pavgh (uint16x4_t s, uint16x4_t t);
     uint8x8_t pavgb (uint8x8_t s, uint8x8_t t);
     uint32x2_t pcmpeqw_u (uint32x2_t s, uint32x2_t t);
     uint16x4_t pcmpeqh_u (uint16x4_t s, uint16x4_t t);
     uint8x8_t pcmpeqb_u (uint8x8_t s, uint8x8_t t);
     int32x2_t pcmpeqw_s (int32x2_t s, int32x2_t t);
     int16x4_t pcmpeqh_s (int16x4_t s, int16x4_t t);
     int8x8_t pcmpeqb_s (int8x8_t s, int8x8_t t);
     uint32x2_t pcmpgtw_u (uint32x2_t s, uint32x2_t t);
     uint16x4_t pcmpgth_u (uint16x4_t s, uint16x4_t t);
     uint8x8_t pcmpgtb_u (uint8x8_t s, uint8x8_t t);
     int32x2_t pcmpgtw_s (int32x2_t s, int32x2_t t);
     int16x4_t pcmpgth_s (int16x4_t s, int16x4_t t);
     int8x8_t pcmpgtb_s (int8x8_t s, int8x8_t t);
     uint16x4_t pextrh_u (uint16x4_t s, int field);
     int16x4_t pextrh_s (int16x4_t s, int field);
     uint16x4_t pinsrh_0_u (uint16x4_t s, uint16x4_t t);
     uint16x4_t pinsrh_1_u (uint16x4_t s, uint16x4_t t);
     uint16x4_t pinsrh_2_u (uint16x4_t s, uint16x4_t t);
     uint16x4_t pinsrh_3_u (uint16x4_t s, uint16x4_t t);
     int16x4_t pinsrh_0_s (int16x4_t s, int16x4_t t);
     int16x4_t pinsrh_1_s (int16x4_t s, int16x4_t t);
     int16x4_t pinsrh_2_s (int16x4_t s, int16x4_t t);
     int16x4_t pinsrh_3_s (int16x4_t s, int16x4_t t);
     int32x2_t pmaddhw (int16x4_t s, int16x4_t t);
     int16x4_t pmaxsh (int16x4_t s, int16x4_t t);
     uint8x8_t pmaxub (uint8x8_t s, uint8x8_t t);
     int16x4_t pminsh (int16x4_t s, int16x4_t t);
     uint8x8_t pminub (uint8x8_t s, uint8x8_t t);
     uint8x8_t pmovmskb_u (uint8x8_t s);
     int8x8_t pmovmskb_s (int8x8_t s);
     uint16x4_t pmulhuh (uint16x4_t s, uint16x4_t t);
     int16x4_t pmulhh (int16x4_t s, int16x4_t t);
     int16x4_t pmullh (int16x4_t s, int16x4_t t);
     int64_t pmuluw (uint32x2_t s, uint32x2_t t);
     uint8x8_t pasubub (uint8x8_t s, uint8x8_t t);
     uint16x4_t biadd (uint8x8_t s);
     uint16x4_t psadbh (uint8x8_t s, uint8x8_t t);
     uint16x4_t pshufh_u (uint16x4_t dest, uint16x4_t s, uint8_t order);
     int16x4_t pshufh_s (int16x4_t dest, int16x4_t s, uint8_t order);
     uint16x4_t psllh_u (uint16x4_t s, uint8_t amount);
     int16x4_t psllh_s (int16x4_t s, uint8_t amount);
     uint32x2_t psllw_u (uint32x2_t s, uint8_t amount);
     int32x2_t psllw_s (int32x2_t s, uint8_t amount);
     uint16x4_t psrlh_u (uint16x4_t s, uint8_t amount);
     int16x4_t psrlh_s (int16x4_t s, uint8_t amount);
     uint32x2_t psrlw_u (uint32x2_t s, uint8_t amount);
     int32x2_t psrlw_s (int32x2_t s, uint8_t amount);
     uint16x4_t psrah_u (uint16x4_t s, uint8_t amount);
     int16x4_t psrah_s (int16x4_t s, uint8_t amount);
     uint32x2_t psraw_u (uint32x2_t s, uint8_t amount);
     int32x2_t psraw_s (int32x2_t s, uint8_t amount);
     uint32x2_t psubw_u (uint32x2_t s, uint32x2_t t);
     uint16x4_t psubh_u (uint16x4_t s, uint16x4_t t);
     uint8x8_t psubb_u (uint8x8_t s, uint8x8_t t);
     int32x2_t psubw_s (int32x2_t s, int32x2_t t);
     int16x4_t psubh_s (int16x4_t s, int16x4_t t);
     int8x8_t psubb_s (int8x8_t s, int8x8_t t);
     uint64_t psubd_u (uint64_t s, uint64_t t);
     int64_t psubd_s (int64_t s, int64_t t);
     int16x4_t psubsh (int16x4_t s, int16x4_t t);
     int8x8_t psubsb (int8x8_t s, int8x8_t t);
     uint16x4_t psubush (uint16x4_t s, uint16x4_t t);
     uint8x8_t psubusb (uint8x8_t s, uint8x8_t t);
     uint32x2_t punpckhwd_u (uint32x2_t s, uint32x2_t t);
     uint16x4_t punpckhhw_u (uint16x4_t s, uint16x4_t t);
     uint8x8_t punpckhbh_u (uint8x8_t s, uint8x8_t t);
     int32x2_t punpckhwd_s (int32x2_t s, int32x2_t t);
     int16x4_t punpckhhw_s (int16x4_t s, int16x4_t t);
     int8x8_t punpckhbh_s (int8x8_t s, int8x8_t t);
     uint32x2_t punpcklwd_u (uint32x2_t s, uint32x2_t t);
     uint16x4_t punpcklhw_u (uint16x4_t s, uint16x4_t t);
     uint8x8_t punpcklbh_u (uint8x8_t s, uint8x8_t t);
     int32x2_t punpcklwd_s (int32x2_t s, int32x2_t t);
     int16x4_t punpcklhw_s (int16x4_t s, int16x4_t t);
     int8x8_t punpcklbh_s (int8x8_t s, int8x8_t t);

* Menu:

* Paired-Single Arithmetic::
* Paired-Single Built-in Functions::
* MIPS-3D Built-in Functions::


File: llvm.info,  Node: Paired-Single Arithmetic,  Next: Paired-Single Built-in Functions,  Up: MIPS Loongson Built-in Functions

6.58.14.1 Paired-Single Arithmetic
..................................

The table below lists the 'v2sf' operations for which hardware support
exists.  'a', 'b' and 'c' are 'v2sf' values and 'x' is an integral
value.

C code                               MIPS instruction
'a + b'                              'add.ps'
'a - b'                              'sub.ps'
'-a'                                 'neg.ps'
'a * b'                              'mul.ps'
'a * b + c'                          'madd.ps'
'a * b - c'                          'msub.ps'
'-(a * b + c)'                       'nmadd.ps'
'-(a * b - c)'                       'nmsub.ps'
'x ? a : b'                          'movn.ps'/'movz.ps'

 Note that the multiply-accumulate instructions can be disabled using
the command-line option '-mno-fused-madd'.


File: llvm.info,  Node: Paired-Single Built-in Functions,  Next: MIPS-3D Built-in Functions,  Prev: Paired-Single Arithmetic,  Up: MIPS Loongson Built-in Functions

6.58.14.2 Paired-Single Built-in Functions
..........................................

The following paired-single functions map directly to a particular MIPS
instruction.  Please refer to the architecture specification for details
on what each instruction does.

'v2sf __builtin_mips_pll_ps (v2sf, v2sf)'
     Pair lower lower ('pll.ps').

'v2sf __builtin_mips_pul_ps (v2sf, v2sf)'
     Pair upper lower ('pul.ps').

'v2sf __builtin_mips_plu_ps (v2sf, v2sf)'
     Pair lower upper ('plu.ps').

'v2sf __builtin_mips_puu_ps (v2sf, v2sf)'
     Pair upper upper ('puu.ps').

'v2sf __builtin_mips_cvt_ps_s (float, float)'
     Convert pair to paired single ('cvt.ps.s').

'float __builtin_mips_cvt_s_pl (v2sf)'
     Convert pair lower to single ('cvt.s.pl').

'float __builtin_mips_cvt_s_pu (v2sf)'
     Convert pair upper to single ('cvt.s.pu').

'v2sf __builtin_mips_abs_ps (v2sf)'
     Absolute value ('abs.ps').

'v2sf __builtin_mips_alnv_ps (v2sf, v2sf, int)'
     Align variable ('alnv.ps').

     _Note:_ The value of the third parameter must be 0 or 4 modulo 8,
     otherwise the result is unpredictable.  Please read the instruction
     description for details.

 The following multi-instruction functions are also available.  In each
case, COND can be any of the 16 floating-point conditions: 'f', 'un',
'eq', 'ueq', 'olt', 'ult', 'ole', 'ule', 'sf', 'ngle', 'seq', 'ngl',
'lt', 'nge', 'le' or 'ngt'.

'v2sf __builtin_mips_movt_c_COND_ps (v2sf A, v2sf B, v2sf C, v2sf D)'
'v2sf __builtin_mips_movf_c_COND_ps (v2sf A, v2sf B, v2sf C, v2sf D)'
     Conditional move based on floating-point comparison ('c.COND.ps',
     'movt.ps'/'movf.ps').

     The 'movt' functions return the value X computed by:

          c.COND.ps CC,A,B
          mov.ps X,C
          movt.ps X,D,CC

     The 'movf' functions are similar but use 'movf.ps' instead of
     'movt.ps'.

'int __builtin_mips_upper_c_COND_ps (v2sf A, v2sf B)'
'int __builtin_mips_lower_c_COND_ps (v2sf A, v2sf B)'
     Comparison of two paired-single values ('c.COND.ps',
     'bc1t'/'bc1f').

     These functions compare A and B using 'c.COND.ps' and return either
     the upper or lower half of the result.  For example:

          v2sf a, b;
          if (__builtin_mips_upper_c_eq_ps (a, b))
            upper_halves_are_equal ();
          else
            upper_halves_are_unequal ();

          if (__builtin_mips_lower_c_eq_ps (a, b))
            lower_halves_are_equal ();
          else
            lower_halves_are_unequal ();


File: llvm.info,  Node: MIPS-3D Built-in Functions,  Prev: Paired-Single Built-in Functions,  Up: MIPS Loongson Built-in Functions

6.58.14.3 MIPS-3D Built-in Functions
....................................

The MIPS-3D Application-Specific Extension (ASE) includes additional
paired-single instructions that are designed to improve the performance
of 3D graphics operations.  Support for these instructions is controlled
by the '-mips3d' command-line option.

 The functions listed below map directly to a particular MIPS-3D
instruction.  Please refer to the architecture specification for more
details on what each instruction does.

'v2sf __builtin_mips_addr_ps (v2sf, v2sf)'
     Reduction add ('addr.ps').

'v2sf __builtin_mips_mulr_ps (v2sf, v2sf)'
     Reduction multiply ('mulr.ps').

'v2sf __builtin_mips_cvt_pw_ps (v2sf)'
     Convert paired single to paired word ('cvt.pw.ps').

'v2sf __builtin_mips_cvt_ps_pw (v2sf)'
     Convert paired word to paired single ('cvt.ps.pw').

'float __builtin_mips_recip1_s (float)'
'double __builtin_mips_recip1_d (double)'
'v2sf __builtin_mips_recip1_ps (v2sf)'
     Reduced-precision reciprocal (sequence step 1) ('recip1.FMT').

'float __builtin_mips_recip2_s (float, float)'
'double __builtin_mips_recip2_d (double, double)'
'v2sf __builtin_mips_recip2_ps (v2sf, v2sf)'
     Reduced-precision reciprocal (sequence step 2) ('recip2.FMT').

'float __builtin_mips_rsqrt1_s (float)'
'double __builtin_mips_rsqrt1_d (double)'
'v2sf __builtin_mips_rsqrt1_ps (v2sf)'
     Reduced-precision reciprocal square root (sequence step 1)
     ('rsqrt1.FMT').

'float __builtin_mips_rsqrt2_s (float, float)'
'double __builtin_mips_rsqrt2_d (double, double)'
'v2sf __builtin_mips_rsqrt2_ps (v2sf, v2sf)'
     Reduced-precision reciprocal square root (sequence step 2)
     ('rsqrt2.FMT').

 The following multi-instruction functions are also available.  In each
case, COND can be any of the 16 floating-point conditions: 'f', 'un',
'eq', 'ueq', 'olt', 'ult', 'ole', 'ule', 'sf', 'ngle', 'seq', 'ngl',
'lt', 'nge', 'le' or 'ngt'.

'int __builtin_mips_cabs_COND_s (float A, float B)'
'int __builtin_mips_cabs_COND_d (double A, double B)'
     Absolute comparison of two scalar values ('cabs.COND.FMT',
     'bc1t'/'bc1f').

     These functions compare A and B using 'cabs.COND.s' or
     'cabs.COND.d' and return the result as a boolean value.  For
     example:

          float a, b;
          if (__builtin_mips_cabs_eq_s (a, b))
            true ();
          else
            false ();

'int __builtin_mips_upper_cabs_COND_ps (v2sf A, v2sf B)'
'int __builtin_mips_lower_cabs_COND_ps (v2sf A, v2sf B)'
     Absolute comparison of two paired-single values ('cabs.COND.ps',
     'bc1t'/'bc1f').

     These functions compare A and B using 'cabs.COND.ps' and return
     either the upper or lower half of the result.  For example:

          v2sf a, b;
          if (__builtin_mips_upper_cabs_eq_ps (a, b))
            upper_halves_are_equal ();
          else
            upper_halves_are_unequal ();

          if (__builtin_mips_lower_cabs_eq_ps (a, b))
            lower_halves_are_equal ();
          else
            lower_halves_are_unequal ();

'v2sf __builtin_mips_movt_cabs_COND_ps (v2sf A, v2sf B, v2sf C, v2sf D)'
'v2sf __builtin_mips_movf_cabs_COND_ps (v2sf A, v2sf B, v2sf C, v2sf D)'
     Conditional move based on absolute comparison ('cabs.COND.ps',
     'movt.ps'/'movf.ps').

     The 'movt' functions return the value X computed by:

          cabs.COND.ps CC,A,B
          mov.ps X,C
          movt.ps X,D,CC

     The 'movf' functions are similar but use 'movf.ps' instead of
     'movt.ps'.

'int __builtin_mips_any_c_COND_ps (v2sf A, v2sf B)'
'int __builtin_mips_all_c_COND_ps (v2sf A, v2sf B)'
'int __builtin_mips_any_cabs_COND_ps (v2sf A, v2sf B)'
'int __builtin_mips_all_cabs_COND_ps (v2sf A, v2sf B)'
     Comparison of two paired-single values ('c.COND.ps'/'cabs.COND.ps',
     'bc1any2t'/'bc1any2f').

     These functions compare A and B using 'c.COND.ps' or
     'cabs.COND.ps'.  The 'any' forms return true if either result is
     true and the 'all' forms return true if both results are true.  For
     example:

          v2sf a, b;
          if (__builtin_mips_any_c_eq_ps (a, b))
            one_is_true ();
          else
            both_are_false ();

          if (__builtin_mips_all_c_eq_ps (a, b))
            both_are_true ();
          else
            one_is_false ();

'int __builtin_mips_any_c_COND_4s (v2sf A, v2sf B, v2sf C, v2sf D)'
'int __builtin_mips_all_c_COND_4s (v2sf A, v2sf B, v2sf C, v2sf D)'
'int __builtin_mips_any_cabs_COND_4s (v2sf A, v2sf B, v2sf C, v2sf D)'
'int __builtin_mips_all_cabs_COND_4s (v2sf A, v2sf B, v2sf C, v2sf D)'
     Comparison of four paired-single values
     ('c.COND.ps'/'cabs.COND.ps', 'bc1any4t'/'bc1any4f').

     These functions use 'c.COND.ps' or 'cabs.COND.ps' to compare A with
     B and to compare C with D.  The 'any' forms return true if any of
     the four results are true and the 'all' forms return true if all
     four results are true.  For example:

          v2sf a, b, c, d;
          if (__builtin_mips_any_c_eq_4s (a, b, c, d))
            some_are_true ();
          else
            all_are_false ();

          if (__builtin_mips_all_c_eq_4s (a, b, c, d))
            all_are_true ();
          else
            some_are_false ();


File: llvm.info,  Node: Other MIPS Built-in Functions,  Next: MSP430 Built-in Functions,  Prev: MIPS Loongson Built-in Functions,  Up: Target Builtins

6.58.15 Other MIPS Built-in Functions
-------------------------------------

GCC provides other MIPS-specific built-in functions:

'void __builtin_mips_cache (int OP, const volatile void *ADDR)'
     Insert a 'cache' instruction with operands OP and ADDR.  GCC
     defines the preprocessor macro '___GCC_HAVE_BUILTIN_MIPS_CACHE'
     when this function is available.

'unsigned int __builtin_mips_get_fcsr (void)'
'void __builtin_mips_set_fcsr (unsigned int VALUE)'
     Get and set the contents of the floating-point control and status
     register (FPU control register 31).  These functions are only
     available in hard-float code but can be called in both MIPS16 and
     non-MIPS16 contexts.

     '__builtin_mips_set_fcsr' can be used to change any bit of the
     register except the condition codes, which GCC assumes are
     preserved.


File: llvm.info,  Node: MSP430 Built-in Functions,  Next: NDS32 Built-in Functions,  Prev: Other MIPS Built-in Functions,  Up: Target Builtins

6.58.16 MSP430 Built-in Functions
---------------------------------

GCC provides a couple of special builtin functions to aid in the writing
of interrupt handlers in C.

'__bic_SR_register_on_exit (int MASK)'
     This clears the indicated bits in the saved copy of the status
     register currently residing on the stack.  This only works inside
     interrupt handlers and the changes to the status register will only
     take affect once the handler returns.

'__bis_SR_register_on_exit (int MASK)'
     This sets the indicated bits in the saved copy of the status
     register currently residing on the stack.  This only works inside
     interrupt handlers and the changes to the status register will only
     take affect once the handler returns.

'__delay_cycles (long long CYCLES)'
     This inserts an instruction sequence that takes exactly CYCLES
     cycles (between 0 and about 17E9) to complete.  The inserted
     sequence may use jumps, loops, or no-ops, and does not interfere
     with any other instructions.  Note that CYCLES must be a
     compile-time constant integer - that is, you must pass a number,
     not a variable that may be optimized to a constant later.  The
     number of cycles delayed by this builtin is exact.


File: llvm.info,  Node: NDS32 Built-in Functions,  Next: picoChip Built-in Functions,  Prev: MSP430 Built-in Functions,  Up: Target Builtins

6.58.17 NDS32 Built-in Functions
--------------------------------

These built-in functions are available for the NDS32 target:

 -- Built-in Function: void __builtin_nds32_isync (int *ADDR)
     Insert an ISYNC instruction into the instruction stream where ADDR
     is an instruction address for serialization.

 -- Built-in Function: void __builtin_nds32_isb (void)
     Insert an ISB instruction into the instruction stream.

 -- Built-in Function: int __builtin_nds32_mfsr (int SR)
     Return the content of a system register which is mapped by SR.

 -- Built-in Function: int __builtin_nds32_mfusr (int USR)
     Return the content of a user space register which is mapped by USR.

 -- Built-in Function: void __builtin_nds32_mtsr (int VALUE, int SR)
     Move the VALUE to a system register which is mapped by SR.

 -- Built-in Function: void __builtin_nds32_mtusr (int VALUE, int USR)
     Move the VALUE to a user space register which is mapped by USR.

 -- Built-in Function: void __builtin_nds32_setgie_en (void)
     Enable global interrupt.

 -- Built-in Function: void __builtin_nds32_setgie_dis (void)
     Disable global interrupt.


File: llvm.info,  Node: picoChip Built-in Functions,  Next: PowerPC Built-in Functions,  Prev: NDS32 Built-in Functions,  Up: Target Builtins

6.58.18 picoChip Built-in Functions
-----------------------------------

GCC provides an interface to selected machine instructions from the
picoChip instruction set.

'int __builtin_sbc (int VALUE)'
     Sign bit count.  Return the number of consecutive bits in VALUE
     that have the same value as the sign bit.  The result is the number
     of leading sign bits minus one, giving the number of redundant sign
     bits in VALUE.

'int __builtin_byteswap (int VALUE)'
     Byte swap.  Return the result of swapping the upper and lower bytes
     of VALUE.

'int __builtin_brev (int VALUE)'
     Bit reversal.  Return the result of reversing the bits in VALUE.
     Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so
     on.

'int __builtin_adds (int X, int Y)'
     Saturating addition.  Return the result of adding X and Y, storing
     the value 32767 if the result overflows.

'int __builtin_subs (int X, int Y)'
     Saturating subtraction.  Return the result of subtracting Y from X,
     storing the value -32768 if the result overflows.

'void __builtin_halt (void)'
     Halt.  The processor stops execution.  This built-in is useful for
     implementing assertions.


File: llvm.info,  Node: PowerPC Built-in Functions,  Next: PowerPC AltiVec/VSX Built-in Functions,  Prev: picoChip Built-in Functions,  Up: Target Builtins

6.58.19 PowerPC Built-in Functions
----------------------------------

These built-in functions are available for the PowerPC family of
processors:
     float __builtin_recipdivf (float, float);
     float __builtin_rsqrtf (float);
     double __builtin_recipdiv (double, double);
     double __builtin_rsqrt (double);
     uint64_t __builtin_ppc_get_timebase ();
     unsigned long __builtin_ppc_mftb ();
     double __builtin_unpack_longdouble (long double, int);
     long double __builtin_pack_longdouble (double, double);

 The 'vec_rsqrt', '__builtin_rsqrt', and '__builtin_rsqrtf' functions
generate multiple instructions to implement the reciprocal sqrt
functionality using reciprocal sqrt estimate instructions.

 The '__builtin_recipdiv', and '__builtin_recipdivf' functions generate
multiple instructions to implement division using the reciprocal
estimate instructions.

 The '__builtin_ppc_get_timebase' and '__builtin_ppc_mftb' functions
generate instructions to read the Time Base Register.  The
'__builtin_ppc_get_timebase' function may generate multiple instructions
and always returns the 64 bits of the Time Base Register.  The
'__builtin_ppc_mftb' function always generates one instruction and
returns the Time Base Register value as an unsigned long, throwing away
the most significant word on 32-bit environments.

 The following built-in functions are available for the PowerPC family
of processors, starting with ISA 2.06 or later ('-mcpu=power7' or
'-mpopcntd'):
     long __builtin_bpermd (long, long);
     int __builtin_divwe (int, int);
     int __builtin_divweo (int, int);
     unsigned int __builtin_divweu (unsigned int, unsigned int);
     unsigned int __builtin_divweuo (unsigned int, unsigned int);
     long __builtin_divde (long, long);
     long __builtin_divdeo (long, long);
     unsigned long __builtin_divdeu (unsigned long, unsigned long);
     unsigned long __builtin_divdeuo (unsigned long, unsigned long);
     unsigned int cdtbcd (unsigned int);
     unsigned int cbcdtd (unsigned int);
     unsigned int addg6s (unsigned int, unsigned int);

 The '__builtin_divde', '__builtin_divdeo', '__builtin_divdeu',
'__builtin_divdeou' functions require a 64-bit environment support ISA
2.06 or later.

 The following built-in functions are available for the PowerPC family
of processors when hardware decimal floating point ('-mhard-dfp') is
available:
     _Decimal64 __builtin_dxex (_Decimal64);
     _Decimal128 __builtin_dxexq (_Decimal128);
     _Decimal64 __builtin_ddedpd (int, _Decimal64);
     _Decimal128 __builtin_ddedpdq (int, _Decimal128);
     _Decimal64 __builtin_denbcd (int, _Decimal64);
     _Decimal128 __builtin_denbcdq (int, _Decimal128);
     _Decimal64 __builtin_diex (_Decimal64, _Decimal64);
     _Decimal128 _builtin_diexq (_Decimal128, _Decimal128);
     _Decimal64 __builtin_dscli (_Decimal64, int);
     _Decimal128 __builtin_dscliq (_Decimal128, int);
     _Decimal64 __builtin_dscri (_Decimal64, int);
     _Decimal128 __builtin_dscriq (_Decimal128, int);
     unsigned long long __builtin_unpack_dec128 (_Decimal128, int);
     _Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);

 The following built-in functions are available for the PowerPC family
of processors when the Vector Scalar (vsx) instruction set is available:
     unsigned long long __builtin_unpack_vector_int128 (vector __int128_t, int);
     vector __int128_t __builtin_pack_vector_int128 (unsigned long long,
                                                     unsigned long long);


File: llvm.info,  Node: PowerPC AltiVec/VSX Built-in Functions,  Next: PowerPC Hardware Transactional Memory Built-in Functions,  Prev: PowerPC Built-in Functions,  Up: Target Builtins

6.58.20 PowerPC AltiVec Built-in Functions
------------------------------------------

GCC provides an interface for the PowerPC family of processors to access
the AltiVec operations described in Motorola's AltiVec Programming
Interface Manual.  The interface is made available by including
'<altivec.h>' and using '-maltivec' and '-mabi=altivec'.  The interface
supports the following vector types.

     vector unsigned char
     vector signed char
     vector bool char

     vector unsigned short
     vector signed short
     vector bool short
     vector pixel

     vector unsigned int
     vector signed int
     vector bool int
     vector float

 If '-mvsx' is used the following additional vector types are
implemented.

     vector unsigned long
     vector signed long
     vector double

 The long types are only implemented for 64-bit code generation, and the
long type is only used in the floating point/integer conversion
instructions.

 GCC's implementation of the high-level language interface available
from C and C++ code differs from Motorola's documentation in several
ways.

   * A vector constant is a list of constant expressions within curly
     braces.

   * A vector initializer requires no cast if the vector constant is of
     the same type as the variable it is initializing.

   * If 'signed' or 'unsigned' is omitted, the signedness of the vector
     type is the default signedness of the base type.  The default
     varies depending on the operating system, so a portable program
     should always specify the signedness.

   * Compiling with '-maltivec' adds keywords '__vector', 'vector',
     '__pixel', 'pixel', '__bool' and 'bool'.  When compiling ISO C, the
     context-sensitive substitution of the keywords 'vector', 'pixel'
     and 'bool' is disabled.  To use them, you must include
     '<altivec.h>' instead.

   * GCC allows using a 'typedef' name as the type specifier for a
     vector type.

   * For C, overloaded functions are implemented with macros so the
     following does not work:

            vec_add ((vector signed int){1, 2, 3, 4}, foo);

     Since 'vec_add' is a macro, the vector constant in the example is
     treated as four separate arguments.  Wrap the entire argument in
     parentheses for this to work.

 _Note:_ Only the '<altivec.h>' interface is supported.  Internally, GCC
uses built-in functions to achieve the functionality in the
aforementioned header file, but they are not supported and are subject
to change without notice.

 The following interfaces are supported for the generic and specific
AltiVec operations and the AltiVec predicates.  In cases where there is
a direct mapping between generic and specific operations, only the
generic names are shown here, although the specific operations can also
be used.

 Arguments that are documented as 'const int' require literal integral
values within the range required for that operation.

     vector signed char vec_abs (vector signed char);
     vector signed short vec_abs (vector signed short);
     vector signed int vec_abs (vector signed int);
     vector float vec_abs (vector float);

     vector signed char vec_abss (vector signed char);
     vector signed short vec_abss (vector signed short);
     vector signed int vec_abss (vector signed int);

     vector signed char vec_add (vector bool char, vector signed char);
     vector signed char vec_add (vector signed char, vector bool char);
     vector signed char vec_add (vector signed char, vector signed char);
     vector unsigned char vec_add (vector bool char, vector unsigned char);
     vector unsigned char vec_add (vector unsigned char, vector bool char);
     vector unsigned char vec_add (vector unsigned char,
                                   vector unsigned char);
     vector signed short vec_add (vector bool short, vector signed short);
     vector signed short vec_add (vector signed short, vector bool short);
     vector signed short vec_add (vector signed short, vector signed short);
     vector unsigned short vec_add (vector bool short,
                                    vector unsigned short);
     vector unsigned short vec_add (vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_add (vector unsigned short,
                                    vector unsigned short);
     vector signed int vec_add (vector bool int, vector signed int);
     vector signed int vec_add (vector signed int, vector bool int);
     vector signed int vec_add (vector signed int, vector signed int);
     vector unsigned int vec_add (vector bool int, vector unsigned int);
     vector unsigned int vec_add (vector unsigned int, vector bool int);
     vector unsigned int vec_add (vector unsigned int, vector unsigned int);
     vector float vec_add (vector float, vector float);

     vector float vec_vaddfp (vector float, vector float);

     vector signed int vec_vadduwm (vector bool int, vector signed int);
     vector signed int vec_vadduwm (vector signed int, vector bool int);
     vector signed int vec_vadduwm (vector signed int, vector signed int);
     vector unsigned int vec_vadduwm (vector bool int, vector unsigned int);
     vector unsigned int vec_vadduwm (vector unsigned int, vector bool int);
     vector unsigned int vec_vadduwm (vector unsigned int,
                                      vector unsigned int);

     vector signed short vec_vadduhm (vector bool short,
                                      vector signed short);
     vector signed short vec_vadduhm (vector signed short,
                                      vector bool short);
     vector signed short vec_vadduhm (vector signed short,
                                      vector signed short);
     vector unsigned short vec_vadduhm (vector bool short,
                                        vector unsigned short);
     vector unsigned short vec_vadduhm (vector unsigned short,
                                        vector bool short);
     vector unsigned short vec_vadduhm (vector unsigned short,
                                        vector unsigned short);

     vector signed char vec_vaddubm (vector bool char, vector signed char);
     vector signed char vec_vaddubm (vector signed char, vector bool char);
     vector signed char vec_vaddubm (vector signed char, vector signed char);
     vector unsigned char vec_vaddubm (vector bool char,
                                       vector unsigned char);
     vector unsigned char vec_vaddubm (vector unsigned char,
                                       vector bool char);
     vector unsigned char vec_vaddubm (vector unsigned char,
                                       vector unsigned char);

     vector unsigned int vec_addc (vector unsigned int, vector unsigned int);

     vector unsigned char vec_adds (vector bool char, vector unsigned char);
     vector unsigned char vec_adds (vector unsigned char, vector bool char);
     vector unsigned char vec_adds (vector unsigned char,
                                    vector unsigned char);
     vector signed char vec_adds (vector bool char, vector signed char);
     vector signed char vec_adds (vector signed char, vector bool char);
     vector signed char vec_adds (vector signed char, vector signed char);
     vector unsigned short vec_adds (vector bool short,
                                     vector unsigned short);
     vector unsigned short vec_adds (vector unsigned short,
                                     vector bool short);
     vector unsigned short vec_adds (vector unsigned short,
                                     vector unsigned short);
     vector signed short vec_adds (vector bool short, vector signed short);
     vector signed short vec_adds (vector signed short, vector bool short);
     vector signed short vec_adds (vector signed short, vector signed short);
     vector unsigned int vec_adds (vector bool int, vector unsigned int);
     vector unsigned int vec_adds (vector unsigned int, vector bool int);
     vector unsigned int vec_adds (vector unsigned int, vector unsigned int);
     vector signed int vec_adds (vector bool int, vector signed int);
     vector signed int vec_adds (vector signed int, vector bool int);
     vector signed int vec_adds (vector signed int, vector signed int);

     vector signed int vec_vaddsws (vector bool int, vector signed int);
     vector signed int vec_vaddsws (vector signed int, vector bool int);
     vector signed int vec_vaddsws (vector signed int, vector signed int);

     vector unsigned int vec_vadduws (vector bool int, vector unsigned int);
     vector unsigned int vec_vadduws (vector unsigned int, vector bool int);
     vector unsigned int vec_vadduws (vector unsigned int,
                                      vector unsigned int);

     vector signed short vec_vaddshs (vector bool short,
                                      vector signed short);
     vector signed short vec_vaddshs (vector signed short,
                                      vector bool short);
     vector signed short vec_vaddshs (vector signed short,
                                      vector signed short);

     vector unsigned short vec_vadduhs (vector bool short,
                                        vector unsigned short);
     vector unsigned short vec_vadduhs (vector unsigned short,
                                        vector bool short);
     vector unsigned short vec_vadduhs (vector unsigned short,
                                        vector unsigned short);

     vector signed char vec_vaddsbs (vector bool char, vector signed char);
     vector signed char vec_vaddsbs (vector signed char, vector bool char);
     vector signed char vec_vaddsbs (vector signed char, vector signed char);

     vector unsigned char vec_vaddubs (vector bool char,
                                       vector unsigned char);
     vector unsigned char vec_vaddubs (vector unsigned char,
                                       vector bool char);
     vector unsigned char vec_vaddubs (vector unsigned char,
                                       vector unsigned char);

     vector float vec_and (vector float, vector float);
     vector float vec_and (vector float, vector bool int);
     vector float vec_and (vector bool int, vector float);
     vector bool int vec_and (vector bool int, vector bool int);
     vector signed int vec_and (vector bool int, vector signed int);
     vector signed int vec_and (vector signed int, vector bool int);
     vector signed int vec_and (vector signed int, vector signed int);
     vector unsigned int vec_and (vector bool int, vector unsigned int);
     vector unsigned int vec_and (vector unsigned int, vector bool int);
     vector unsigned int vec_and (vector unsigned int, vector unsigned int);
     vector bool short vec_and (vector bool short, vector bool short);
     vector signed short vec_and (vector bool short, vector signed short);
     vector signed short vec_and (vector signed short, vector bool short);
     vector signed short vec_and (vector signed short, vector signed short);
     vector unsigned short vec_and (vector bool short,
                                    vector unsigned short);
     vector unsigned short vec_and (vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_and (vector unsigned short,
                                    vector unsigned short);
     vector signed char vec_and (vector bool char, vector signed char);
     vector bool char vec_and (vector bool char, vector bool char);
     vector signed char vec_and (vector signed char, vector bool char);
     vector signed char vec_and (vector signed char, vector signed char);
     vector unsigned char vec_and (vector bool char, vector unsigned char);
     vector unsigned char vec_and (vector unsigned char, vector bool char);
     vector unsigned char vec_and (vector unsigned char,
                                   vector unsigned char);

     vector float vec_andc (vector float, vector float);
     vector float vec_andc (vector float, vector bool int);
     vector float vec_andc (vector bool int, vector float);
     vector bool int vec_andc (vector bool int, vector bool int);
     vector signed int vec_andc (vector bool int, vector signed int);
     vector signed int vec_andc (vector signed int, vector bool int);
     vector signed int vec_andc (vector signed int, vector signed int);
     vector unsigned int vec_andc (vector bool int, vector unsigned int);
     vector unsigned int vec_andc (vector unsigned int, vector bool int);
     vector unsigned int vec_andc (vector unsigned int, vector unsigned int);
     vector bool short vec_andc (vector bool short, vector bool short);
     vector signed short vec_andc (vector bool short, vector signed short);
     vector signed short vec_andc (vector signed short, vector bool short);
     vector signed short vec_andc (vector signed short, vector signed short);
     vector unsigned short vec_andc (vector bool short,
                                     vector unsigned short);
     vector unsigned short vec_andc (vector unsigned short,
                                     vector bool short);
     vector unsigned short vec_andc (vector unsigned short,
                                     vector unsigned short);
     vector signed char vec_andc (vector bool char, vector signed char);
     vector bool char vec_andc (vector bool char, vector bool char);
     vector signed char vec_andc (vector signed char, vector bool char);
     vector signed char vec_andc (vector signed char, vector signed char);
     vector unsigned char vec_andc (vector bool char, vector unsigned char);
     vector unsigned char vec_andc (vector unsigned char, vector bool char);
     vector unsigned char vec_andc (vector unsigned char,
                                    vector unsigned char);

     vector unsigned char vec_avg (vector unsigned char,
                                   vector unsigned char);
     vector signed char vec_avg (vector signed char, vector signed char);
     vector unsigned short vec_avg (vector unsigned short,
                                    vector unsigned short);
     vector signed short vec_avg (vector signed short, vector signed short);
     vector unsigned int vec_avg (vector unsigned int, vector unsigned int);
     vector signed int vec_avg (vector signed int, vector signed int);

     vector signed int vec_vavgsw (vector signed int, vector signed int);

     vector unsigned int vec_vavguw (vector unsigned int,
                                     vector unsigned int);

     vector signed short vec_vavgsh (vector signed short,
                                     vector signed short);

     vector unsigned short vec_vavguh (vector unsigned short,
                                       vector unsigned short);

     vector signed char vec_vavgsb (vector signed char, vector signed char);

     vector unsigned char vec_vavgub (vector unsigned char,
                                      vector unsigned char);

     vector float vec_copysign (vector float);

     vector float vec_ceil (vector float);

     vector signed int vec_cmpb (vector float, vector float);

     vector bool char vec_cmpeq (vector signed char, vector signed char);
     vector bool char vec_cmpeq (vector unsigned char, vector unsigned char);
     vector bool short vec_cmpeq (vector signed short, vector signed short);
     vector bool short vec_cmpeq (vector unsigned short,
                                  vector unsigned short);
     vector bool int vec_cmpeq (vector signed int, vector signed int);
     vector bool int vec_cmpeq (vector unsigned int, vector unsigned int);
     vector bool int vec_cmpeq (vector float, vector float);

     vector bool int vec_vcmpeqfp (vector float, vector float);

     vector bool int vec_vcmpequw (vector signed int, vector signed int);
     vector bool int vec_vcmpequw (vector unsigned int, vector unsigned int);

     vector bool short vec_vcmpequh (vector signed short,
                                     vector signed short);
     vector bool short vec_vcmpequh (vector unsigned short,
                                     vector unsigned short);

     vector bool char vec_vcmpequb (vector signed char, vector signed char);
     vector bool char vec_vcmpequb (vector unsigned char,
                                    vector unsigned char);

     vector bool int vec_cmpge (vector float, vector float);

     vector bool char vec_cmpgt (vector unsigned char, vector unsigned char);
     vector bool char vec_cmpgt (vector signed char, vector signed char);
     vector bool short vec_cmpgt (vector unsigned short,
                                  vector unsigned short);
     vector bool short vec_cmpgt (vector signed short, vector signed short);
     vector bool int vec_cmpgt (vector unsigned int, vector unsigned int);
     vector bool int vec_cmpgt (vector signed int, vector signed int);
     vector bool int vec_cmpgt (vector float, vector float);

     vector bool int vec_vcmpgtfp (vector float, vector float);

     vector bool int vec_vcmpgtsw (vector signed int, vector signed int);

     vector bool int vec_vcmpgtuw (vector unsigned int, vector unsigned int);

     vector bool short vec_vcmpgtsh (vector signed short,
                                     vector signed short);

     vector bool short vec_vcmpgtuh (vector unsigned short,
                                     vector unsigned short);

     vector bool char vec_vcmpgtsb (vector signed char, vector signed char);

     vector bool char vec_vcmpgtub (vector unsigned char,
                                    vector unsigned char);

     vector bool int vec_cmple (vector float, vector float);

     vector bool char vec_cmplt (vector unsigned char, vector unsigned char);
     vector bool char vec_cmplt (vector signed char, vector signed char);
     vector bool short vec_cmplt (vector unsigned short,
                                  vector unsigned short);
     vector bool short vec_cmplt (vector signed short, vector signed short);
     vector bool int vec_cmplt (vector unsigned int, vector unsigned int);
     vector bool int vec_cmplt (vector signed int, vector signed int);
     vector bool int vec_cmplt (vector float, vector float);

     vector float vec_cpsgn (vector float, vector float);

     vector float vec_ctf (vector unsigned int, const int);
     vector float vec_ctf (vector signed int, const int);
     vector double vec_ctf (vector unsigned long, const int);
     vector double vec_ctf (vector signed long, const int);

     vector float vec_vcfsx (vector signed int, const int);

     vector float vec_vcfux (vector unsigned int, const int);

     vector signed int vec_cts (vector float, const int);
     vector signed long vec_cts (vector double, const int);

     vector unsigned int vec_ctu (vector float, const int);
     vector unsigned long vec_ctu (vector double, const int);

     void vec_dss (const int);

     void vec_dssall (void);

     void vec_dst (const vector unsigned char *, int, const int);
     void vec_dst (const vector signed char *, int, const int);
     void vec_dst (const vector bool char *, int, const int);
     void vec_dst (const vector unsigned short *, int, const int);
     void vec_dst (const vector signed short *, int, const int);
     void vec_dst (const vector bool short *, int, const int);
     void vec_dst (const vector pixel *, int, const int);
     void vec_dst (const vector unsigned int *, int, const int);
     void vec_dst (const vector signed int *, int, const int);
     void vec_dst (const vector bool int *, int, const int);
     void vec_dst (const vector float *, int, const int);
     void vec_dst (const unsigned char *, int, const int);
     void vec_dst (const signed char *, int, const int);
     void vec_dst (const unsigned short *, int, const int);
     void vec_dst (const short *, int, const int);
     void vec_dst (const unsigned int *, int, const int);
     void vec_dst (const int *, int, const int);
     void vec_dst (const unsigned long *, int, const int);
     void vec_dst (const long *, int, const int);
     void vec_dst (const float *, int, const int);

     void vec_dstst (const vector unsigned char *, int, const int);
     void vec_dstst (const vector signed char *, int, const int);
     void vec_dstst (const vector bool char *, int, const int);
     void vec_dstst (const vector unsigned short *, int, const int);
     void vec_dstst (const vector signed short *, int, const int);
     void vec_dstst (const vector bool short *, int, const int);
     void vec_dstst (const vector pixel *, int, const int);
     void vec_dstst (const vector unsigned int *, int, const int);
     void vec_dstst (const vector signed int *, int, const int);
     void vec_dstst (const vector bool int *, int, const int);
     void vec_dstst (const vector float *, int, const int);
     void vec_dstst (const unsigned char *, int, const int);
     void vec_dstst (const signed char *, int, const int);
     void vec_dstst (const unsigned short *, int, const int);
     void vec_dstst (const short *, int, const int);
     void vec_dstst (const unsigned int *, int, const int);
     void vec_dstst (const int *, int, const int);
     void vec_dstst (const unsigned long *, int, const int);
     void vec_dstst (const long *, int, const int);
     void vec_dstst (const float *, int, const int);

     void vec_dststt (const vector unsigned char *, int, const int);
     void vec_dststt (const vector signed char *, int, const int);
     void vec_dststt (const vector bool char *, int, const int);
     void vec_dststt (const vector unsigned short *, int, const int);
     void vec_dststt (const vector signed short *, int, const int);
     void vec_dststt (const vector bool short *, int, const int);
     void vec_dststt (const vector pixel *, int, const int);
     void vec_dststt (const vector unsigned int *, int, const int);
     void vec_dststt (const vector signed int *, int, const int);
     void vec_dststt (const vector bool int *, int, const int);
     void vec_dststt (const vector float *, int, const int);
     void vec_dststt (const unsigned char *, int, const int);
     void vec_dststt (const signed char *, int, const int);
     void vec_dststt (const unsigned short *, int, const int);
     void vec_dststt (const short *, int, const int);
     void vec_dststt (const unsigned int *, int, const int);
     void vec_dststt (const int *, int, const int);
     void vec_dststt (const unsigned long *, int, const int);
     void vec_dststt (const long *, int, const int);
     void vec_dststt (const float *, int, const int);

     void vec_dstt (const vector unsigned char *, int, const int);
     void vec_dstt (const vector signed char *, int, const int);
     void vec_dstt (const vector bool char *, int, const int);
     void vec_dstt (const vector unsigned short *, int, const int);
     void vec_dstt (const vector signed short *, int, const int);
     void vec_dstt (const vector bool short *, int, const int);
     void vec_dstt (const vector pixel *, int, const int);
     void vec_dstt (const vector unsigned int *, int, const int);
     void vec_dstt (const vector signed int *, int, const int);
     void vec_dstt (const vector bool int *, int, const int);
     void vec_dstt (const vector float *, int, const int);
     void vec_dstt (const unsigned char *, int, const int);
     void vec_dstt (const signed char *, int, const int);
     void vec_dstt (const unsigned short *, int, const int);
     void vec_dstt (const short *, int, const int);
     void vec_dstt (const unsigned int *, int, const int);
     void vec_dstt (const int *, int, const int);
     void vec_dstt (const unsigned long *, int, const int);
     void vec_dstt (const long *, int, const int);
     void vec_dstt (const float *, int, const int);

     vector float vec_expte (vector float);

     vector float vec_floor (vector float);

     vector float vec_ld (int, const vector float *);
     vector float vec_ld (int, const float *);
     vector bool int vec_ld (int, const vector bool int *);
     vector signed int vec_ld (int, const vector signed int *);
     vector signed int vec_ld (int, const int *);
     vector signed int vec_ld (int, const long *);
     vector unsigned int vec_ld (int, const vector unsigned int *);
     vector unsigned int vec_ld (int, const unsigned int *);
     vector unsigned int vec_ld (int, const unsigned long *);
     vector bool short vec_ld (int, const vector bool short *);
     vector pixel vec_ld (int, const vector pixel *);
     vector signed short vec_ld (int, const vector signed short *);
     vector signed short vec_ld (int, const short *);
     vector unsigned short vec_ld (int, const vector unsigned short *);
     vector unsigned short vec_ld (int, const unsigned short *);
     vector bool char vec_ld (int, const vector bool char *);
     vector signed char vec_ld (int, const vector signed char *);
     vector signed char vec_ld (int, const signed char *);
     vector unsigned char vec_ld (int, const vector unsigned char *);
     vector unsigned char vec_ld (int, const unsigned char *);

     vector signed char vec_lde (int, const signed char *);
     vector unsigned char vec_lde (int, const unsigned char *);
     vector signed short vec_lde (int, const short *);
     vector unsigned short vec_lde (int, const unsigned short *);
     vector float vec_lde (int, const float *);
     vector signed int vec_lde (int, const int *);
     vector unsigned int vec_lde (int, const unsigned int *);
     vector signed int vec_lde (int, const long *);
     vector unsigned int vec_lde (int, const unsigned long *);

     vector float vec_lvewx (int, float *);
     vector signed int vec_lvewx (int, int *);
     vector unsigned int vec_lvewx (int, unsigned int *);
     vector signed int vec_lvewx (int, long *);
     vector unsigned int vec_lvewx (int, unsigned long *);

     vector signed short vec_lvehx (int, short *);
     vector unsigned short vec_lvehx (int, unsigned short *);

     vector signed char vec_lvebx (int, char *);
     vector unsigned char vec_lvebx (int, unsigned char *);

     vector float vec_ldl (int, const vector float *);
     vector float vec_ldl (int, const float *);
     vector bool int vec_ldl (int, const vector bool int *);
     vector signed int vec_ldl (int, const vector signed int *);
     vector signed int vec_ldl (int, const int *);
     vector signed int vec_ldl (int, const long *);
     vector unsigned int vec_ldl (int, const vector unsigned int *);
     vector unsigned int vec_ldl (int, const unsigned int *);
     vector unsigned int vec_ldl (int, const unsigned long *);
     vector bool short vec_ldl (int, const vector bool short *);
     vector pixel vec_ldl (int, const vector pixel *);
     vector signed short vec_ldl (int, const vector signed short *);
     vector signed short vec_ldl (int, const short *);
     vector unsigned short vec_ldl (int, const vector unsigned short *);
     vector unsigned short vec_ldl (int, const unsigned short *);
     vector bool char vec_ldl (int, const vector bool char *);
     vector signed char vec_ldl (int, const vector signed char *);
     vector signed char vec_ldl (int, const signed char *);
     vector unsigned char vec_ldl (int, const vector unsigned char *);
     vector unsigned char vec_ldl (int, const unsigned char *);

     vector float vec_loge (vector float);

     vector unsigned char vec_lvsl (int, const volatile unsigned char *);
     vector unsigned char vec_lvsl (int, const volatile signed char *);
     vector unsigned char vec_lvsl (int, const volatile unsigned short *);
     vector unsigned char vec_lvsl (int, const volatile short *);
     vector unsigned char vec_lvsl (int, const volatile unsigned int *);
     vector unsigned char vec_lvsl (int, const volatile int *);
     vector unsigned char vec_lvsl (int, const volatile unsigned long *);
     vector unsigned char vec_lvsl (int, const volatile long *);
     vector unsigned char vec_lvsl (int, const volatile float *);

     vector unsigned char vec_lvsr (int, const volatile unsigned char *);
     vector unsigned char vec_lvsr (int, const volatile signed char *);
     vector unsigned char vec_lvsr (int, const volatile unsigned short *);
     vector unsigned char vec_lvsr (int, const volatile short *);
     vector unsigned char vec_lvsr (int, const volatile unsigned int *);
     vector unsigned char vec_lvsr (int, const volatile int *);
     vector unsigned char vec_lvsr (int, const volatile unsigned long *);
     vector unsigned char vec_lvsr (int, const volatile long *);
     vector unsigned char vec_lvsr (int, const volatile float *);

     vector float vec_madd (vector float, vector float, vector float);

     vector signed short vec_madds (vector signed short,
                                    vector signed short,
                                    vector signed short);

     vector unsigned char vec_max (vector bool char, vector unsigned char);
     vector unsigned char vec_max (vector unsigned char, vector bool char);
     vector unsigned char vec_max (vector unsigned char,
                                   vector unsigned char);
     vector signed char vec_max (vector bool char, vector signed char);
     vector signed char vec_max (vector signed char, vector bool char);
     vector signed char vec_max (vector signed char, vector signed char);
     vector unsigned short vec_max (vector bool short,
                                    vector unsigned short);
     vector unsigned short vec_max (vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_max (vector unsigned short,
                                    vector unsigned short);
     vector signed short vec_max (vector bool short, vector signed short);
     vector signed short vec_max (vector signed short, vector bool short);
     vector signed short vec_max (vector signed short, vector signed short);
     vector unsigned int vec_max (vector bool int, vector unsigned int);
     vector unsigned int vec_max (vector unsigned int, vector bool int);
     vector unsigned int vec_max (vector unsigned int, vector unsigned int);
     vector signed int vec_max (vector bool int, vector signed int);
     vector signed int vec_max (vector signed int, vector bool int);
     vector signed int vec_max (vector signed int, vector signed int);
     vector float vec_max (vector float, vector float);

     vector float vec_vmaxfp (vector float, vector float);

     vector signed int vec_vmaxsw (vector bool int, vector signed int);
     vector signed int vec_vmaxsw (vector signed int, vector bool int);
     vector signed int vec_vmaxsw (vector signed int, vector signed int);

     vector unsigned int vec_vmaxuw (vector bool int, vector unsigned int);
     vector unsigned int vec_vmaxuw (vector unsigned int, vector bool int);
     vector unsigned int vec_vmaxuw (vector unsigned int,
                                     vector unsigned int);

     vector signed short vec_vmaxsh (vector bool short, vector signed short);
     vector signed short vec_vmaxsh (vector signed short, vector bool short);
     vector signed short vec_vmaxsh (vector signed short,
                                     vector signed short);

     vector unsigned short vec_vmaxuh (vector bool short,
                                       vector unsigned short);
     vector unsigned short vec_vmaxuh (vector unsigned short,
                                       vector bool short);
     vector unsigned short vec_vmaxuh (vector unsigned short,
                                       vector unsigned short);

     vector signed char vec_vmaxsb (vector bool char, vector signed char);
     vector signed char vec_vmaxsb (vector signed char, vector bool char);
     vector signed char vec_vmaxsb (vector signed char, vector signed char);

     vector unsigned char vec_vmaxub (vector bool char,
                                      vector unsigned char);
     vector unsigned char vec_vmaxub (vector unsigned char,
                                      vector bool char);
     vector unsigned char vec_vmaxub (vector unsigned char,
                                      vector unsigned char);

     vector bool char vec_mergeh (vector bool char, vector bool char);
     vector signed char vec_mergeh (vector signed char, vector signed char);
     vector unsigned char vec_mergeh (vector unsigned char,
                                      vector unsigned char);
     vector bool short vec_mergeh (vector bool short, vector bool short);
     vector pixel vec_mergeh (vector pixel, vector pixel);
     vector signed short vec_mergeh (vector signed short,
                                     vector signed short);
     vector unsigned short vec_mergeh (vector unsigned short,
                                       vector unsigned short);
     vector float vec_mergeh (vector float, vector float);
     vector bool int vec_mergeh (vector bool int, vector bool int);
     vector signed int vec_mergeh (vector signed int, vector signed int);
     vector unsigned int vec_mergeh (vector unsigned int,
                                     vector unsigned int);

     vector float vec_vmrghw (vector float, vector float);
     vector bool int vec_vmrghw (vector bool int, vector bool int);
     vector signed int vec_vmrghw (vector signed int, vector signed int);
     vector unsigned int vec_vmrghw (vector unsigned int,
                                     vector unsigned int);

     vector bool short vec_vmrghh (vector bool short, vector bool short);
     vector signed short vec_vmrghh (vector signed short,
                                     vector signed short);
     vector unsigned short vec_vmrghh (vector unsigned short,
                                       vector unsigned short);
     vector pixel vec_vmrghh (vector pixel, vector pixel);

     vector bool char vec_vmrghb (vector bool char, vector bool char);
     vector signed char vec_vmrghb (vector signed char, vector signed char);
     vector unsigned char vec_vmrghb (vector unsigned char,
                                      vector unsigned char);

     vector bool char vec_mergel (vector bool char, vector bool char);
     vector signed char vec_mergel (vector signed char, vector signed char);
     vector unsigned char vec_mergel (vector unsigned char,
                                      vector unsigned char);
     vector bool short vec_mergel (vector bool short, vector bool short);
     vector pixel vec_mergel (vector pixel, vector pixel);
     vector signed short vec_mergel (vector signed short,
                                     vector signed short);
     vector unsigned short vec_mergel (vector unsigned short,
                                       vector unsigned short);
     vector float vec_mergel (vector float, vector float);
     vector bool int vec_mergel (vector bool int, vector bool int);
     vector signed int vec_mergel (vector signed int, vector signed int);
     vector unsigned int vec_mergel (vector unsigned int,
                                     vector unsigned int);

     vector float vec_vmrglw (vector float, vector float);
     vector signed int vec_vmrglw (vector signed int, vector signed int);
     vector unsigned int vec_vmrglw (vector unsigned int,
                                     vector unsigned int);
     vector bool int vec_vmrglw (vector bool int, vector bool int);

     vector bool short vec_vmrglh (vector bool short, vector bool short);
     vector signed short vec_vmrglh (vector signed short,
                                     vector signed short);
     vector unsigned short vec_vmrglh (vector unsigned short,
                                       vector unsigned short);
     vector pixel vec_vmrglh (vector pixel, vector pixel);

     vector bool char vec_vmrglb (vector bool char, vector bool char);
     vector signed char vec_vmrglb (vector signed char, vector signed char);
     vector unsigned char vec_vmrglb (vector unsigned char,
                                      vector unsigned char);

     vector unsigned short vec_mfvscr (void);

     vector unsigned char vec_min (vector bool char, vector unsigned char);
     vector unsigned char vec_min (vector unsigned char, vector bool char);
     vector unsigned char vec_min (vector unsigned char,
                                   vector unsigned char);
     vector signed char vec_min (vector bool char, vector signed char);
     vector signed char vec_min (vector signed char, vector bool char);
     vector signed char vec_min (vector signed char, vector signed char);
     vector unsigned short vec_min (vector bool short,
                                    vector unsigned short);
     vector unsigned short vec_min (vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_min (vector unsigned short,
                                    vector unsigned short);
     vector signed short vec_min (vector bool short, vector signed short);
     vector signed short vec_min (vector signed short, vector bool short);
     vector signed short vec_min (vector signed short, vector signed short);
     vector unsigned int vec_min (vector bool int, vector unsigned int);
     vector unsigned int vec_min (vector unsigned int, vector bool int);
     vector unsigned int vec_min (vector unsigned int, vector unsigned int);
     vector signed int vec_min (vector bool int, vector signed int);
     vector signed int vec_min (vector signed int, vector bool int);
     vector signed int vec_min (vector signed int, vector signed int);
     vector float vec_min (vector float, vector float);

     vector float vec_vminfp (vector float, vector float);

     vector signed int vec_vminsw (vector bool int, vector signed int);
     vector signed int vec_vminsw (vector signed int, vector bool int);
     vector signed int vec_vminsw (vector signed int, vector signed int);

     vector unsigned int vec_vminuw (vector bool int, vector unsigned int);
     vector unsigned int vec_vminuw (vector unsigned int, vector bool int);
     vector unsigned int vec_vminuw (vector unsigned int,
                                     vector unsigned int);

     vector signed short vec_vminsh (vector bool short, vector signed short);
     vector signed short vec_vminsh (vector signed short, vector bool short);
     vector signed short vec_vminsh (vector signed short,
                                     vector signed short);

     vector unsigned short vec_vminuh (vector bool short,
                                       vector unsigned short);
     vector unsigned short vec_vminuh (vector unsigned short,
                                       vector bool short);
     vector unsigned short vec_vminuh (vector unsigned short,
                                       vector unsigned short);

     vector signed char vec_vminsb (vector bool char, vector signed char);
     vector signed char vec_vminsb (vector signed char, vector bool char);
     vector signed char vec_vminsb (vector signed char, vector signed char);

     vector unsigned char vec_vminub (vector bool char,
                                      vector unsigned char);
     vector unsigned char vec_vminub (vector unsigned char,
                                      vector bool char);
     vector unsigned char vec_vminub (vector unsigned char,
                                      vector unsigned char);

     vector signed short vec_mladd (vector signed short,
                                    vector signed short,
                                    vector signed short);
     vector signed short vec_mladd (vector signed short,
                                    vector unsigned short,
                                    vector unsigned short);
     vector signed short vec_mladd (vector unsigned short,
                                    vector signed short,
                                    vector signed short);
     vector unsigned short vec_mladd (vector unsigned short,
                                      vector unsigned short,
                                      vector unsigned short);

     vector signed short vec_mradds (vector signed short,
                                     vector signed short,
                                     vector signed short);

     vector unsigned int vec_msum (vector unsigned char,
                                   vector unsigned char,
                                   vector unsigned int);
     vector signed int vec_msum (vector signed char,
                                 vector unsigned char,
                                 vector signed int);
     vector unsigned int vec_msum (vector unsigned short,
                                   vector unsigned short,
                                   vector unsigned int);
     vector signed int vec_msum (vector signed short,
                                 vector signed short,
                                 vector signed int);

     vector signed int vec_vmsumshm (vector signed short,
                                     vector signed short,
                                     vector signed int);

     vector unsigned int vec_vmsumuhm (vector unsigned short,
                                       vector unsigned short,
                                       vector unsigned int);

     vector signed int vec_vmsummbm (vector signed char,
                                     vector unsigned char,
                                     vector signed int);

     vector unsigned int vec_vmsumubm (vector unsigned char,
                                       vector unsigned char,
                                       vector unsigned int);

     vector unsigned int vec_msums (vector unsigned short,
                                    vector unsigned short,
                                    vector unsigned int);
     vector signed int vec_msums (vector signed short,
                                  vector signed short,
                                  vector signed int);

     vector signed int vec_vmsumshs (vector signed short,
                                     vector signed short,
                                     vector signed int);

     vector unsigned int vec_vmsumuhs (vector unsigned short,
                                       vector unsigned short,
                                       vector unsigned int);

     void vec_mtvscr (vector signed int);
     void vec_mtvscr (vector unsigned int);
     void vec_mtvscr (vector bool int);
     void vec_mtvscr (vector signed short);
     void vec_mtvscr (vector unsigned short);
     void vec_mtvscr (vector bool short);
     void vec_mtvscr (vector pixel);
     void vec_mtvscr (vector signed char);
     void vec_mtvscr (vector unsigned char);
     void vec_mtvscr (vector bool char);

     vector unsigned short vec_mule (vector unsigned char,
                                     vector unsigned char);
     vector signed short vec_mule (vector signed char,
                                   vector signed char);
     vector unsigned int vec_mule (vector unsigned short,
                                   vector unsigned short);
     vector signed int vec_mule (vector signed short, vector signed short);

     vector signed int vec_vmulesh (vector signed short,
                                    vector signed short);

     vector unsigned int vec_vmuleuh (vector unsigned short,
                                      vector unsigned short);

     vector signed short vec_vmulesb (vector signed char,
                                      vector signed char);

     vector unsigned short vec_vmuleub (vector unsigned char,
                                       vector unsigned char);

     vector unsigned short vec_mulo (vector unsigned char,
                                     vector unsigned char);
     vector signed short vec_mulo (vector signed char, vector signed char);
     vector unsigned int vec_mulo (vector unsigned short,
                                   vector unsigned short);
     vector signed int vec_mulo (vector signed short, vector signed short);

     vector signed int vec_vmulosh (vector signed short,
                                    vector signed short);

     vector unsigned int vec_vmulouh (vector unsigned short,
                                      vector unsigned short);

     vector signed short vec_vmulosb (vector signed char,
                                      vector signed char);

     vector unsigned short vec_vmuloub (vector unsigned char,
                                        vector unsigned char);

     vector float vec_nmsub (vector float, vector float, vector float);

     vector float vec_nor (vector float, vector float);
     vector signed int vec_nor (vector signed int, vector signed int);
     vector unsigned int vec_nor (vector unsigned int, vector unsigned int);
     vector bool int vec_nor (vector bool int, vector bool int);
     vector signed short vec_nor (vector signed short, vector signed short);
     vector unsigned short vec_nor (vector unsigned short,
                                    vector unsigned short);
     vector bool short vec_nor (vector bool short, vector bool short);
     vector signed char vec_nor (vector signed char, vector signed char);
     vector unsigned char vec_nor (vector unsigned char,
                                   vector unsigned char);
     vector bool char vec_nor (vector bool char, vector bool char);

     vector float vec_or (vector float, vector float);
     vector float vec_or (vector float, vector bool int);
     vector float vec_or (vector bool int, vector float);
     vector bool int vec_or (vector bool int, vector bool int);
     vector signed int vec_or (vector bool int, vector signed int);
     vector signed int vec_or (vector signed int, vector bool int);
     vector signed int vec_or (vector signed int, vector signed int);
     vector unsigned int vec_or (vector bool int, vector unsigned int);
     vector unsigned int vec_or (vector unsigned int, vector bool int);
     vector unsigned int vec_or (vector unsigned int, vector unsigned int);
     vector bool short vec_or (vector bool short, vector bool short);
     vector signed short vec_or (vector bool short, vector signed short);
     vector signed short vec_or (vector signed short, vector bool short);
     vector signed short vec_or (vector signed short, vector signed short);
     vector unsigned short vec_or (vector bool short, vector unsigned short);
     vector unsigned short vec_or (vector unsigned short, vector bool short);
     vector unsigned short vec_or (vector unsigned short,
                                   vector unsigned short);
     vector signed char vec_or (vector bool char, vector signed char);
     vector bool char vec_or (vector bool char, vector bool char);
     vector signed char vec_or (vector signed char, vector bool char);
     vector signed char vec_or (vector signed char, vector signed char);
     vector unsigned char vec_or (vector bool char, vector unsigned char);
     vector unsigned char vec_or (vector unsigned char, vector bool char);
     vector unsigned char vec_or (vector unsigned char,
                                  vector unsigned char);

     vector signed char vec_pack (vector signed short, vector signed short);
     vector unsigned char vec_pack (vector unsigned short,
                                    vector unsigned short);
     vector bool char vec_pack (vector bool short, vector bool short);
     vector signed short vec_pack (vector signed int, vector signed int);
     vector unsigned short vec_pack (vector unsigned int,
                                     vector unsigned int);
     vector bool short vec_pack (vector bool int, vector bool int);

     vector bool short vec_vpkuwum (vector bool int, vector bool int);
     vector signed short vec_vpkuwum (vector signed int, vector signed int);
     vector unsigned short vec_vpkuwum (vector unsigned int,
                                        vector unsigned int);

     vector bool char vec_vpkuhum (vector bool short, vector bool short);
     vector signed char vec_vpkuhum (vector signed short,
                                     vector signed short);
     vector unsigned char vec_vpkuhum (vector unsigned short,
                                       vector unsigned short);

     vector pixel vec_packpx (vector unsigned int, vector unsigned int);

     vector unsigned char vec_packs (vector unsigned short,
                                     vector unsigned short);
     vector signed char vec_packs (vector signed short, vector signed short);
     vector unsigned short vec_packs (vector unsigned int,
                                      vector unsigned int);
     vector signed short vec_packs (vector signed int, vector signed int);

     vector signed short vec_vpkswss (vector signed int, vector signed int);

     vector unsigned short vec_vpkuwus (vector unsigned int,
                                        vector unsigned int);

     vector signed char vec_vpkshss (vector signed short,
                                     vector signed short);

     vector unsigned char vec_vpkuhus (vector unsigned short,
                                       vector unsigned short);

     vector unsigned char vec_packsu (vector unsigned short,
                                      vector unsigned short);
     vector unsigned char vec_packsu (vector signed short,
                                      vector signed short);
     vector unsigned short vec_packsu (vector unsigned int,
                                       vector unsigned int);
     vector unsigned short vec_packsu (vector signed int, vector signed int);

     vector unsigned short vec_vpkswus (vector signed int,
                                        vector signed int);

     vector unsigned char vec_vpkshus (vector signed short,
                                       vector signed short);

     vector float vec_perm (vector float,
                            vector float,
                            vector unsigned char);
     vector signed int vec_perm (vector signed int,
                                 vector signed int,
                                 vector unsigned char);
     vector unsigned int vec_perm (vector unsigned int,
                                   vector unsigned int,
                                   vector unsigned char);
     vector bool int vec_perm (vector bool int,
                               vector bool int,
                               vector unsigned char);
     vector signed short vec_perm (vector signed short,
                                   vector signed short,
                                   vector unsigned char);
     vector unsigned short vec_perm (vector unsigned short,
                                     vector unsigned short,
                                     vector unsigned char);
     vector bool short vec_perm (vector bool short,
                                 vector bool short,
                                 vector unsigned char);
     vector pixel vec_perm (vector pixel,
                            vector pixel,
                            vector unsigned char);
     vector signed char vec_perm (vector signed char,
                                  vector signed char,
                                  vector unsigned char);
     vector unsigned char vec_perm (vector unsigned char,
                                    vector unsigned char,
                                    vector unsigned char);
     vector bool char vec_perm (vector bool char,
                                vector bool char,
                                vector unsigned char);

     vector float vec_re (vector float);

     vector signed char vec_rl (vector signed char,
                                vector unsigned char);
     vector unsigned char vec_rl (vector unsigned char,
                                  vector unsigned char);
     vector signed short vec_rl (vector signed short, vector unsigned short);
     vector unsigned short vec_rl (vector unsigned short,
                                   vector unsigned short);
     vector signed int vec_rl (vector signed int, vector unsigned int);
     vector unsigned int vec_rl (vector unsigned int, vector unsigned int);

     vector signed int vec_vrlw (vector signed int, vector unsigned int);
     vector unsigned int vec_vrlw (vector unsigned int, vector unsigned int);

     vector signed short vec_vrlh (vector signed short,
                                   vector unsigned short);
     vector unsigned short vec_vrlh (vector unsigned short,
                                     vector unsigned short);

     vector signed char vec_vrlb (vector signed char, vector unsigned char);
     vector unsigned char vec_vrlb (vector unsigned char,
                                    vector unsigned char);

     vector float vec_round (vector float);

     vector float vec_recip (vector float, vector float);

     vector float vec_rsqrt (vector float);

     vector float vec_rsqrte (vector float);

     vector float vec_sel (vector float, vector float, vector bool int);
     vector float vec_sel (vector float, vector float, vector unsigned int);
     vector signed int vec_sel (vector signed int,
                                vector signed int,
                                vector bool int);
     vector signed int vec_sel (vector signed int,
                                vector signed int,
                                vector unsigned int);
     vector unsigned int vec_sel (vector unsigned int,
                                  vector unsigned int,
                                  vector bool int);
     vector unsigned int vec_sel (vector unsigned int,
                                  vector unsigned int,
                                  vector unsigned int);
     vector bool int vec_sel (vector bool int,
                              vector bool int,
                              vector bool int);
     vector bool int vec_sel (vector bool int,
                              vector bool int,
                              vector unsigned int);
     vector signed short vec_sel (vector signed short,
                                  vector signed short,
                                  vector bool short);
     vector signed short vec_sel (vector signed short,
                                  vector signed short,
                                  vector unsigned short);
     vector unsigned short vec_sel (vector unsigned short,
                                    vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_sel (vector unsigned short,
                                    vector unsigned short,
                                    vector unsigned short);
     vector bool short vec_sel (vector bool short,
                                vector bool short,
                                vector bool short);
     vector bool short vec_sel (vector bool short,
                                vector bool short,
                                vector unsigned short);
     vector signed char vec_sel (vector signed char,
                                 vector signed char,
                                 vector bool char);
     vector signed char vec_sel (vector signed char,
                                 vector signed char,
                                 vector unsigned char);
     vector unsigned char vec_sel (vector unsigned char,
                                   vector unsigned char,
                                   vector bool char);
     vector unsigned char vec_sel (vector unsigned char,
                                   vector unsigned char,
                                   vector unsigned char);
     vector bool char vec_sel (vector bool char,
                               vector bool char,
                               vector bool char);
     vector bool char vec_sel (vector bool char,
                               vector bool char,
                               vector unsigned char);

     vector signed char vec_sl (vector signed char,
                                vector unsigned char);
     vector unsigned char vec_sl (vector unsigned char,
                                  vector unsigned char);
     vector signed short vec_sl (vector signed short, vector unsigned short);
     vector unsigned short vec_sl (vector unsigned short,
                                   vector unsigned short);
     vector signed int vec_sl (vector signed int, vector unsigned int);
     vector unsigned int vec_sl (vector unsigned int, vector unsigned int);

     vector signed int vec_vslw (vector signed int, vector unsigned int);
     vector unsigned int vec_vslw (vector unsigned int, vector unsigned int);

     vector signed short vec_vslh (vector signed short,
                                   vector unsigned short);
     vector unsigned short vec_vslh (vector unsigned short,
                                     vector unsigned short);

     vector signed char vec_vslb (vector signed char, vector unsigned char);
     vector unsigned char vec_vslb (vector unsigned char,
                                    vector unsigned char);

     vector float vec_sld (vector float, vector float, const int);
     vector signed int vec_sld (vector signed int,
                                vector signed int,
                                const int);
     vector unsigned int vec_sld (vector unsigned int,
                                  vector unsigned int,
                                  const int);
     vector bool int vec_sld (vector bool int,
                              vector bool int,
                              const int);
     vector signed short vec_sld (vector signed short,
                                  vector signed short,
                                  const int);
     vector unsigned short vec_sld (vector unsigned short,
                                    vector unsigned short,
                                    const int);
     vector bool short vec_sld (vector bool short,
                                vector bool short,
                                const int);
     vector pixel vec_sld (vector pixel,
                           vector pixel,
                           const int);
     vector signed char vec_sld (vector signed char,
                                 vector signed char,
                                 const int);
     vector unsigned char vec_sld (vector unsigned char,
                                   vector unsigned char,
                                   const int);
     vector bool char vec_sld (vector bool char,
                               vector bool char,
                               const int);

     vector signed int vec_sll (vector signed int,
                                vector unsigned int);
     vector signed int vec_sll (vector signed int,
                                vector unsigned short);
     vector signed int vec_sll (vector signed int,
                                vector unsigned char);
     vector unsigned int vec_sll (vector unsigned int,
                                  vector unsigned int);
     vector unsigned int vec_sll (vector unsigned int,
                                  vector unsigned short);
     vector unsigned int vec_sll (vector unsigned int,
                                  vector unsigned char);
     vector bool int vec_sll (vector bool int,
                              vector unsigned int);
     vector bool int vec_sll (vector bool int,
                              vector unsigned short);
     vector bool int vec_sll (vector bool int,
                              vector unsigned char);
     vector signed short vec_sll (vector signed short,
                                  vector unsigned int);
     vector signed short vec_sll (vector signed short,
                                  vector unsigned short);
     vector signed short vec_sll (vector signed short,
                                  vector unsigned char);
     vector unsigned short vec_sll (vector unsigned short,
                                    vector unsigned int);
     vector unsigned short vec_sll (vector unsigned short,
                                    vector unsigned short);
     vector unsigned short vec_sll (vector unsigned short,
                                    vector unsigned char);
     vector bool short vec_sll (vector bool short, vector unsigned int);
     vector bool short vec_sll (vector bool short, vector unsigned short);
     vector bool short vec_sll (vector bool short, vector unsigned char);
     vector pixel vec_sll (vector pixel, vector unsigned int);
     vector pixel vec_sll (vector pixel, vector unsigned short);
     vector pixel vec_sll (vector pixel, vector unsigned char);
     vector signed char vec_sll (vector signed char, vector unsigned int);
     vector signed char vec_sll (vector signed char, vector unsigned short);
     vector signed char vec_sll (vector signed char, vector unsigned char);
     vector unsigned char vec_sll (vector unsigned char,
                                   vector unsigned int);
     vector unsigned char vec_sll (vector unsigned char,
                                   vector unsigned short);
     vector unsigned char vec_sll (vector unsigned char,
                                   vector unsigned char);
     vector bool char vec_sll (vector bool char, vector unsigned int);
     vector bool char vec_sll (vector bool char, vector unsigned short);
     vector bool char vec_sll (vector bool char, vector unsigned char);

     vector float vec_slo (vector float, vector signed char);
     vector float vec_slo (vector float, vector unsigned char);
     vector signed int vec_slo (vector signed int, vector signed char);
     vector signed int vec_slo (vector signed int, vector unsigned char);
     vector unsigned int vec_slo (vector unsigned int, vector signed char);
     vector unsigned int vec_slo (vector unsigned int, vector unsigned char);
     vector signed short vec_slo (vector signed short, vector signed char);
     vector signed short vec_slo (vector signed short, vector unsigned char);
     vector unsigned short vec_slo (vector unsigned short,
                                    vector signed char);
     vector unsigned short vec_slo (vector unsigned short,
                                    vector unsigned char);
     vector pixel vec_slo (vector pixel, vector signed char);
     vector pixel vec_slo (vector pixel, vector unsigned char);
     vector signed char vec_slo (vector signed char, vector signed char);
     vector signed char vec_slo (vector signed char, vector unsigned char);
     vector unsigned char vec_slo (vector unsigned char, vector signed char);
     vector unsigned char vec_slo (vector unsigned char,
                                   vector unsigned char);

     vector signed char vec_splat (vector signed char, const int);
     vector unsigned char vec_splat (vector unsigned char, const int);
     vector bool char vec_splat (vector bool char, const int);
     vector signed short vec_splat (vector signed short, const int);
     vector unsigned short vec_splat (vector unsigned short, const int);
     vector bool short vec_splat (vector bool short, const int);
     vector pixel vec_splat (vector pixel, const int);
     vector float vec_splat (vector float, const int);
     vector signed int vec_splat (vector signed int, const int);
     vector unsigned int vec_splat (vector unsigned int, const int);
     vector bool int vec_splat (vector bool int, const int);
     vector signed long vec_splat (vector signed long, const int);
     vector unsigned long vec_splat (vector unsigned long, const int);

     vector signed char vec_splats (signed char);
     vector unsigned char vec_splats (unsigned char);
     vector signed short vec_splats (signed short);
     vector unsigned short vec_splats (unsigned short);
     vector signed int vec_splats (signed int);
     vector unsigned int vec_splats (unsigned int);
     vector float vec_splats (float);

     vector float vec_vspltw (vector float, const int);
     vector signed int vec_vspltw (vector signed int, const int);
     vector unsigned int vec_vspltw (vector unsigned int, const int);
     vector bool int vec_vspltw (vector bool int, const int);

     vector bool short vec_vsplth (vector bool short, const int);
     vector signed short vec_vsplth (vector signed short, const int);
     vector unsigned short vec_vsplth (vector unsigned short, const int);
     vector pixel vec_vsplth (vector pixel, const int);

     vector signed char vec_vspltb (vector signed char, const int);
     vector unsigned char vec_vspltb (vector unsigned char, const int);
     vector bool char vec_vspltb (vector bool char, const int);

     vector signed char vec_splat_s8 (const int);

     vector signed short vec_splat_s16 (const int);

     vector signed int vec_splat_s32 (const int);

     vector unsigned char vec_splat_u8 (const int);

     vector unsigned short vec_splat_u16 (const int);

     vector unsigned int vec_splat_u32 (const int);

     vector signed char vec_sr (vector signed char, vector unsigned char);
     vector unsigned char vec_sr (vector unsigned char,
                                  vector unsigned char);
     vector signed short vec_sr (vector signed short,
                                 vector unsigned short);
     vector unsigned short vec_sr (vector unsigned short,
                                   vector unsigned short);
     vector signed int vec_sr (vector signed int, vector unsigned int);
     vector unsigned int vec_sr (vector unsigned int, vector unsigned int);

     vector signed int vec_vsrw (vector signed int, vector unsigned int);
     vector unsigned int vec_vsrw (vector unsigned int, vector unsigned int);

     vector signed short vec_vsrh (vector signed short,
                                   vector unsigned short);
     vector unsigned short vec_vsrh (vector unsigned short,
                                     vector unsigned short);

     vector signed char vec_vsrb (vector signed char, vector unsigned char);
     vector unsigned char vec_vsrb (vector unsigned char,
                                    vector unsigned char);

     vector signed char vec_sra (vector signed char, vector unsigned char);
     vector unsigned char vec_sra (vector unsigned char,
                                   vector unsigned char);
     vector signed short vec_sra (vector signed short,
                                  vector unsigned short);
     vector unsigned short vec_sra (vector unsigned short,
                                    vector unsigned short);
     vector signed int vec_sra (vector signed int, vector unsigned int);
     vector unsigned int vec_sra (vector unsigned int, vector unsigned int);

     vector signed int vec_vsraw (vector signed int, vector unsigned int);
     vector unsigned int vec_vsraw (vector unsigned int,
                                    vector unsigned int);

     vector signed short vec_vsrah (vector signed short,
                                    vector unsigned short);
     vector unsigned short vec_vsrah (vector unsigned short,
                                      vector unsigned short);

     vector signed char vec_vsrab (vector signed char, vector unsigned char);
     vector unsigned char vec_vsrab (vector unsigned char,
                                     vector unsigned char);

     vector signed int vec_srl (vector signed int, vector unsigned int);
     vector signed int vec_srl (vector signed int, vector unsigned short);
     vector signed int vec_srl (vector signed int, vector unsigned char);
     vector unsigned int vec_srl (vector unsigned int, vector unsigned int);
     vector unsigned int vec_srl (vector unsigned int,
                                  vector unsigned short);
     vector unsigned int vec_srl (vector unsigned int, vector unsigned char);
     vector bool int vec_srl (vector bool int, vector unsigned int);
     vector bool int vec_srl (vector bool int, vector unsigned short);
     vector bool int vec_srl (vector bool int, vector unsigned char);
     vector signed short vec_srl (vector signed short, vector unsigned int);
     vector signed short vec_srl (vector signed short,
                                  vector unsigned short);
     vector signed short vec_srl (vector signed short, vector unsigned char);
     vector unsigned short vec_srl (vector unsigned short,
                                    vector unsigned int);
     vector unsigned short vec_srl (vector unsigned short,
                                    vector unsigned short);
     vector unsigned short vec_srl (vector unsigned short,
                                    vector unsigned char);
     vector bool short vec_srl (vector bool short, vector unsigned int);
     vector bool short vec_srl (vector bool short, vector unsigned short);
     vector bool short vec_srl (vector bool short, vector unsigned char);
     vector pixel vec_srl (vector pixel, vector unsigned int);
     vector pixel vec_srl (vector pixel, vector unsigned short);
     vector pixel vec_srl (vector pixel, vector unsigned char);
     vector signed char vec_srl (vector signed char, vector unsigned int);
     vector signed char vec_srl (vector signed char, vector unsigned short);
     vector signed char vec_srl (vector signed char, vector unsigned char);
     vector unsigned char vec_srl (vector unsigned char,
                                   vector unsigned int);
     vector unsigned char vec_srl (vector unsigned char,
                                   vector unsigned short);
     vector unsigned char vec_srl (vector unsigned char,
                                   vector unsigned char);
     vector bool char vec_srl (vector bool char, vector unsigned int);
     vector bool char vec_srl (vector bool char, vector unsigned short);
     vector bool char vec_srl (vector bool char, vector unsigned char);

     vector float vec_sro (vector float, vector signed char);
     vector float vec_sro (vector float, vector unsigned char);
     vector signed int vec_sro (vector signed int, vector signed char);
     vector signed int vec_sro (vector signed int, vector unsigned char);
     vector unsigned int vec_sro (vector unsigned int, vector signed char);
     vector unsigned int vec_sro (vector unsigned int, vector unsigned char);
     vector signed short vec_sro (vector signed short, vector signed char);
     vector signed short vec_sro (vector signed short, vector unsigned char);
     vector unsigned short vec_sro (vector unsigned short,
                                    vector signed char);
     vector unsigned short vec_sro (vector unsigned short,
                                    vector unsigned char);
     vector pixel vec_sro (vector pixel, vector signed char);
     vector pixel vec_sro (vector pixel, vector unsigned char);
     vector signed char vec_sro (vector signed char, vector signed char);
     vector signed char vec_sro (vector signed char, vector unsigned char);
     vector unsigned char vec_sro (vector unsigned char, vector signed char);
     vector unsigned char vec_sro (vector unsigned char,
                                   vector unsigned char);

     void vec_st (vector float, int, vector float *);
     void vec_st (vector float, int, float *);
     void vec_st (vector signed int, int, vector signed int *);
     void vec_st (vector signed int, int, int *);
     void vec_st (vector unsigned int, int, vector unsigned int *);
     void vec_st (vector unsigned int, int, unsigned int *);
     void vec_st (vector bool int, int, vector bool int *);
     void vec_st (vector bool int, int, unsigned int *);
     void vec_st (vector bool int, int, int *);
     void vec_st (vector signed short, int, vector signed short *);
     void vec_st (vector signed short, int, short *);
     void vec_st (vector unsigned short, int, vector unsigned short *);
     void vec_st (vector unsigned short, int, unsigned short *);
     void vec_st (vector bool short, int, vector bool short *);
     void vec_st (vector bool short, int, unsigned short *);
     void vec_st (vector pixel, int, vector pixel *);
     void vec_st (vector pixel, int, unsigned short *);
     void vec_st (vector pixel, int, short *);
     void vec_st (vector bool short, int, short *);
     void vec_st (vector signed char, int, vector signed char *);
     void vec_st (vector signed char, int, signed char *);
     void vec_st (vector unsigned char, int, vector unsigned char *);
     void vec_st (vector unsigned char, int, unsigned char *);
     void vec_st (vector bool char, int, vector bool char *);
     void vec_st (vector bool char, int, unsigned char *);
     void vec_st (vector bool char, int, signed char *);

     void vec_ste (vector signed char, int, signed char *);
     void vec_ste (vector unsigned char, int, unsigned char *);
     void vec_ste (vector bool char, int, signed char *);
     void vec_ste (vector bool char, int, unsigned char *);
     void vec_ste (vector signed short, int, short *);
     void vec_ste (vector unsigned short, int, unsigned short *);
     void vec_ste (vector bool short, int, short *);
     void vec_ste (vector bool short, int, unsigned short *);
     void vec_ste (vector pixel, int, short *);
     void vec_ste (vector pixel, int, unsigned short *);
     void vec_ste (vector float, int, float *);
     void vec_ste (vector signed int, int, int *);
     void vec_ste (vector unsigned int, int, unsigned int *);
     void vec_ste (vector bool int, int, int *);
     void vec_ste (vector bool int, int, unsigned int *);

     void vec_stvewx (vector float, int, float *);
     void vec_stvewx (vector signed int, int, int *);
     void vec_stvewx (vector unsigned int, int, unsigned int *);
     void vec_stvewx (vector bool int, int, int *);
     void vec_stvewx (vector bool int, int, unsigned int *);

     void vec_stvehx (vector signed short, int, short *);
     void vec_stvehx (vector unsigned short, int, unsigned short *);
     void vec_stvehx (vector bool short, int, short *);
     void vec_stvehx (vector bool short, int, unsigned short *);
     void vec_stvehx (vector pixel, int, short *);
     void vec_stvehx (vector pixel, int, unsigned short *);

     void vec_stvebx (vector signed char, int, signed char *);
     void vec_stvebx (vector unsigned char, int, unsigned char *);
     void vec_stvebx (vector bool char, int, signed char *);
     void vec_stvebx (vector bool char, int, unsigned char *);

     void vec_stl (vector float, int, vector float *);
     void vec_stl (vector float, int, float *);
     void vec_stl (vector signed int, int, vector signed int *);
     void vec_stl (vector signed int, int, int *);
     void vec_stl (vector unsigned int, int, vector unsigned int *);
     void vec_stl (vector unsigned int, int, unsigned int *);
     void vec_stl (vector bool int, int, vector bool int *);
     void vec_stl (vector bool int, int, unsigned int *);
     void vec_stl (vector bool int, int, int *);
     void vec_stl (vector signed short, int, vector signed short *);
     void vec_stl (vector signed short, int, short *);
     void vec_stl (vector unsigned short, int, vector unsigned short *);
     void vec_stl (vector unsigned short, int, unsigned short *);
     void vec_stl (vector bool short, int, vector bool short *);
     void vec_stl (vector bool short, int, unsigned short *);
     void vec_stl (vector bool short, int, short *);
     void vec_stl (vector pixel, int, vector pixel *);
     void vec_stl (vector pixel, int, unsigned short *);
     void vec_stl (vector pixel, int, short *);
     void vec_stl (vector signed char, int, vector signed char *);
     void vec_stl (vector signed char, int, signed char *);
     void vec_stl (vector unsigned char, int, vector unsigned char *);
     void vec_stl (vector unsigned char, int, unsigned char *);
     void vec_stl (vector bool char, int, vector bool char *);
     void vec_stl (vector bool char, int, unsigned char *);
     void vec_stl (vector bool char, int, signed char *);

     vector signed char vec_sub (vector bool char, vector signed char);
     vector signed char vec_sub (vector signed char, vector bool char);
     vector signed char vec_sub (vector signed char, vector signed char);
     vector unsigned char vec_sub (vector bool char, vector unsigned char);
     vector unsigned char vec_sub (vector unsigned char, vector bool char);
     vector unsigned char vec_sub (vector unsigned char,
                                   vector unsigned char);
     vector signed short vec_sub (vector bool short, vector signed short);
     vector signed short vec_sub (vector signed short, vector bool short);
     vector signed short vec_sub (vector signed short, vector signed short);
     vector unsigned short vec_sub (vector bool short,
                                    vector unsigned short);
     vector unsigned short vec_sub (vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_sub (vector unsigned short,
                                    vector unsigned short);
     vector signed int vec_sub (vector bool int, vector signed int);
     vector signed int vec_sub (vector signed int, vector bool int);
     vector signed int vec_sub (vector signed int, vector signed int);
     vector unsigned int vec_sub (vector bool int, vector unsigned int);
     vector unsigned int vec_sub (vector unsigned int, vector bool int);
     vector unsigned int vec_sub (vector unsigned int, vector unsigned int);
     vector float vec_sub (vector float, vector float);

     vector float vec_vsubfp (vector float, vector float);

     vector signed int vec_vsubuwm (vector bool int, vector signed int);
     vector signed int vec_vsubuwm (vector signed int, vector bool int);
     vector signed int vec_vsubuwm (vector signed int, vector signed int);
     vector unsigned int vec_vsubuwm (vector bool int, vector unsigned int);
     vector unsigned int vec_vsubuwm (vector unsigned int, vector bool int);
     vector unsigned int vec_vsubuwm (vector unsigned int,
                                      vector unsigned int);

     vector signed short vec_vsubuhm (vector bool short,
                                      vector signed short);
     vector signed short vec_vsubuhm (vector signed short,
                                      vector bool short);
     vector signed short vec_vsubuhm (vector signed short,
                                      vector signed short);
     vector unsigned short vec_vsubuhm (vector bool short,
                                        vector unsigned short);
     vector unsigned short vec_vsubuhm (vector unsigned short,
                                        vector bool short);
     vector unsigned short vec_vsubuhm (vector unsigned short,
                                        vector unsigned short);

     vector signed char vec_vsububm (vector bool char, vector signed char);
     vector signed char vec_vsububm (vector signed char, vector bool char);
     vector signed char vec_vsububm (vector signed char, vector signed char);
     vector unsigned char vec_vsububm (vector bool char,
                                       vector unsigned char);
     vector unsigned char vec_vsububm (vector unsigned char,
                                       vector bool char);
     vector unsigned char vec_vsububm (vector unsigned char,
                                       vector unsigned char);

     vector unsigned int vec_subc (vector unsigned int, vector unsigned int);

     vector unsigned char vec_subs (vector bool char, vector unsigned char);
     vector unsigned char vec_subs (vector unsigned char, vector bool char);
     vector unsigned char vec_subs (vector unsigned char,
                                    vector unsigned char);
     vector signed char vec_subs (vector bool char, vector signed char);
     vector signed char vec_subs (vector signed char, vector bool char);
     vector signed char vec_subs (vector signed char, vector signed char);
     vector unsigned short vec_subs (vector bool short,
                                     vector unsigned short);
     vector unsigned short vec_subs (vector unsigned short,
                                     vector bool short);
     vector unsigned short vec_subs (vector unsigned short,
                                     vector unsigned short);
     vector signed short vec_subs (vector bool short, vector signed short);
     vector signed short vec_subs (vector signed short, vector bool short);
     vector signed short vec_subs (vector signed short, vector signed short);
     vector unsigned int vec_subs (vector bool int, vector unsigned int);
     vector unsigned int vec_subs (vector unsigned int, vector bool int);
     vector unsigned int vec_subs (vector unsigned int, vector unsigned int);
     vector signed int vec_subs (vector bool int, vector signed int);
     vector signed int vec_subs (vector signed int, vector bool int);
     vector signed int vec_subs (vector signed int, vector signed int);

     vector signed int vec_vsubsws (vector bool int, vector signed int);
     vector signed int vec_vsubsws (vector signed int, vector bool int);
     vector signed int vec_vsubsws (vector signed int, vector signed int);

     vector unsigned int vec_vsubuws (vector bool int, vector unsigned int);
     vector unsigned int vec_vsubuws (vector unsigned int, vector bool int);
     vector unsigned int vec_vsubuws (vector unsigned int,
                                      vector unsigned int);

     vector signed short vec_vsubshs (vector bool short,
                                      vector signed short);
     vector signed short vec_vsubshs (vector signed short,
                                      vector bool short);
     vector signed short vec_vsubshs (vector signed short,
                                      vector signed short);

     vector unsigned short vec_vsubuhs (vector bool short,
                                        vector unsigned short);
     vector unsigned short vec_vsubuhs (vector unsigned short,
                                        vector bool short);
     vector unsigned short vec_vsubuhs (vector unsigned short,
                                        vector unsigned short);

     vector signed char vec_vsubsbs (vector bool char, vector signed char);
     vector signed char vec_vsubsbs (vector signed char, vector bool char);
     vector signed char vec_vsubsbs (vector signed char, vector signed char);

     vector unsigned char vec_vsububs (vector bool char,
                                       vector unsigned char);
     vector unsigned char vec_vsububs (vector unsigned char,
                                       vector bool char);
     vector unsigned char vec_vsububs (vector unsigned char,
                                       vector unsigned char);

     vector unsigned int vec_sum4s (vector unsigned char,
                                    vector unsigned int);
     vector signed int vec_sum4s (vector signed char, vector signed int);
     vector signed int vec_sum4s (vector signed short, vector signed int);

     vector signed int vec_vsum4shs (vector signed short, vector signed int);

     vector signed int vec_vsum4sbs (vector signed char, vector signed int);

     vector unsigned int vec_vsum4ubs (vector unsigned char,
                                       vector unsigned int);

     vector signed int vec_sum2s (vector signed int, vector signed int);

     vector signed int vec_sums (vector signed int, vector signed int);

     vector float vec_trunc (vector float);

     vector signed short vec_unpackh (vector signed char);
     vector bool short vec_unpackh (vector bool char);
     vector signed int vec_unpackh (vector signed short);
     vector bool int vec_unpackh (vector bool short);
     vector unsigned int vec_unpackh (vector pixel);

     vector bool int vec_vupkhsh (vector bool short);
     vector signed int vec_vupkhsh (vector signed short);

     vector unsigned int vec_vupkhpx (vector pixel);

     vector bool short vec_vupkhsb (vector bool char);
     vector signed short vec_vupkhsb (vector signed char);

     vector signed short vec_unpackl (vector signed char);
     vector bool short vec_unpackl (vector bool char);
     vector unsigned int vec_unpackl (vector pixel);
     vector signed int vec_unpackl (vector signed short);
     vector bool int vec_unpackl (vector bool short);

     vector unsigned int vec_vupklpx (vector pixel);

     vector bool int vec_vupklsh (vector bool short);
     vector signed int vec_vupklsh (vector signed short);

     vector bool short vec_vupklsb (vector bool char);
     vector signed short vec_vupklsb (vector signed char);

     vector float vec_xor (vector float, vector float);
     vector float vec_xor (vector float, vector bool int);
     vector float vec_xor (vector bool int, vector float);
     vector bool int vec_xor (vector bool int, vector bool int);
     vector signed int vec_xor (vector bool int, vector signed int);
     vector signed int vec_xor (vector signed int, vector bool int);
     vector signed int vec_xor (vector signed int, vector signed int);
     vector unsigned int vec_xor (vector bool int, vector unsigned int);
     vector unsigned int vec_xor (vector unsigned int, vector bool int);
     vector unsigned int vec_xor (vector unsigned int, vector unsigned int);
     vector bool short vec_xor (vector bool short, vector bool short);
     vector signed short vec_xor (vector bool short, vector signed short);
     vector signed short vec_xor (vector signed short, vector bool short);
     vector signed short vec_xor (vector signed short, vector signed short);
     vector unsigned short vec_xor (vector bool short,
                                    vector unsigned short);
     vector unsigned short vec_xor (vector unsigned short,
                                    vector bool short);
     vector unsigned short vec_xor (vector unsigned short,
                                    vector unsigned short);
     vector signed char vec_xor (vector bool char, vector signed char);
     vector bool char vec_xor (vector bool char, vector bool char);
     vector signed char vec_xor (vector signed char, vector bool char);
     vector signed char vec_xor (vector signed char, vector signed char);
     vector unsigned char vec_xor (vector bool char, vector unsigned char);
     vector unsigned char vec_xor (vector unsigned char, vector bool char);
     vector unsigned char vec_xor (vector unsigned char,
                                   vector unsigned char);

     int vec_all_eq (vector signed char, vector bool char);
     int vec_all_eq (vector signed char, vector signed char);
     int vec_all_eq (vector unsigned char, vector bool char);
     int vec_all_eq (vector unsigned char, vector unsigned char);
     int vec_all_eq (vector bool char, vector bool char);
     int vec_all_eq (vector bool char, vector unsigned char);
     int vec_all_eq (vector bool char, vector signed char);
     int vec_all_eq (vector signed short, vector bool short);
     int vec_all_eq (vector signed short, vector signed short);
     int vec_all_eq (vector unsigned short, vector bool short);
     int vec_all_eq (vector unsigned short, vector unsigned short);
     int vec_all_eq (vector bool short, vector bool short);
     int vec_all_eq (vector bool short, vector unsigned short);
     int vec_all_eq (vector bool short, vector signed short);
     int vec_all_eq (vector pixel, vector pixel);
     int vec_all_eq (vector signed int, vector bool int);
     int vec_all_eq (vector signed int, vector signed int);
     int vec_all_eq (vector unsigned int, vector bool int);
     int vec_all_eq (vector unsigned int, vector unsigned int);
     int vec_all_eq (vector bool int, vector bool int);
     int vec_all_eq (vector bool int, vector unsigned int);
     int vec_all_eq (vector bool int, vector signed int);
     int vec_all_eq (vector float, vector float);

     int vec_all_ge (vector bool char, vector unsigned char);
     int vec_all_ge (vector unsigned char, vector bool char);
     int vec_all_ge (vector unsigned char, vector unsigned char);
     int vec_all_ge (vector bool char, vector signed char);
     int vec_all_ge (vector signed char, vector bool char);
     int vec_all_ge (vector signed char, vector signed char);
     int vec_all_ge (vector bool short, vector unsigned short);
     int vec_all_ge (vector unsigned short, vector bool short);
     int vec_all_ge (vector unsigned short, vector unsigned short);
     int vec_all_ge (vector signed short, vector signed short);
     int vec_all_ge (vector bool short, vector signed short);
     int vec_all_ge (vector signed short, vector bool short);
     int vec_all_ge (vector bool int, vector unsigned int);
     int vec_all_ge (vector unsigned int, vector bool int);
     int vec_all_ge (vector unsigned int, vector unsigned int);
     int vec_all_ge (vector bool int, vector signed int);
     int vec_all_ge (vector signed int, vector bool int);
     int vec_all_ge (vector signed int, vector signed int);
     int vec_all_ge (vector float, vector float);

     int vec_all_gt (vector bool char, vector unsigned char);
     int vec_all_gt (vector unsigned char, vector bool char);
     int vec_all_gt (vector unsigned char, vector unsigned char);
     int vec_all_gt (vector bool char, vector signed char);
     int vec_all_gt (vector signed char, vector bool char);
     int vec_all_gt (vector signed char, vector signed char);
     int vec_all_gt (vector bool short, vector unsigned short);
     int vec_all_gt (vector unsigned short, vector bool short);
     int vec_all_gt (vector unsigned short, vector unsigned short);
     int vec_all_gt (vector bool short, vector signed short);
     int vec_all_gt (vector signed short, vector bool short);
     int vec_all_gt (vector signed short, vector signed short);
     int vec_all_gt (vector bool int, vector unsigned int);
     int vec_all_gt (vector unsigned int, vector bool int);
     int vec_all_gt (vector unsigned int, vector unsigned int);
     int vec_all_gt (vector bool int, vector signed int);
     int vec_all_gt (vector signed int, vector bool int);
     int vec_all_gt (vector signed int, vector signed int);
     int vec_all_gt (vector float, vector float);

     int vec_all_in (vector float, vector float);

     int vec_all_le (vector bool char, vector unsigned char);
     int vec_all_le (vector unsigned char, vector bool char);
     int vec_all_le (vector unsigned char, vector unsigned char);
     int vec_all_le (vector bool char, vector signed char);
     int vec_all_le (vector signed char, vector bool char);
     int vec_all_le (vector signed char, vector signed char);
     int vec_all_le (vector bool short, vector unsigned short);
     int vec_all_le (vector unsigned short, vector bool short);
     int vec_all_le (vector unsigned short, vector unsigned short);
     int vec_all_le (vector bool short, vector signed short);
     int vec_all_le (vector signed short, vector bool short);
     int vec_all_le (vector signed short, vector signed short);
     int vec_all_le (vector bool int, vector unsigned int);
     int vec_all_le (vector unsigned int, vector bool int);
     int vec_all_le (vector unsigned int, vector unsigned int);
     int vec_all_le (vector bool int, vector signed int);
     int vec_all_le (vector signed int, vector bool int);
     int vec_all_le (vector signed int, vector signed int);
     int vec_all_le (vector float, vector float);

     int vec_all_lt (vector bool char, vector unsigned char);
     int vec_all_lt (vector unsigned char, vector bool char);
     int vec_all_lt (vector unsigned char, vector unsigned char);
     int vec_all_lt (vector bool char, vector signed char);
     int vec_all_lt (vector signed char, vector bool char);
     int vec_all_lt (vector signed char, vector signed char);
     int vec_all_lt (vector bool short, vector unsigned short);
     int vec_all_lt (vector unsigned short, vector bool short);
     int vec_all_lt (vector unsigned short, vector unsigned short);
     int vec_all_lt (vector bool short, vector signed short);
     int vec_all_lt (vector signed short, vector bool short);
     int vec_all_lt (vector signed short, vector signed short);
     int vec_all_lt (vector bool int, vector unsigned int);
     int vec_all_lt (vector unsigned int, vector bool int);
     int vec_all_lt (vector unsigned int, vector unsigned int);
     int vec_all_lt (vector bool int, vector signed int);
     int vec_all_lt (vector signed int, vector bool int);
     int vec_all_lt (vector signed int, vector signed int);
     int vec_all_lt (vector float, vector float);

     int vec_all_nan (vector float);

     int vec_all_ne (vector signed char, vector bool char);
     int vec_all_ne (vector signed char, vector signed char);
     int vec_all_ne (vector unsigned char, vector bool char);
     int vec_all_ne (vector unsigned char, vector unsigned char);
     int vec_all_ne (vector bool char, vector bool char);
     int vec_all_ne (vector bool char, vector unsigned char);
     int vec_all_ne (vector bool char, vector signed char);
     int vec_all_ne (vector signed short, vector bool short);
     int vec_all_ne (vector signed short, vector signed short);
     int vec_all_ne (vector unsigned short, vector bool short);
     int vec_all_ne (vector unsigned short, vector unsigned short);
     int vec_all_ne (vector bool short, vector bool short);
     int vec_all_ne (vector bool short, vector unsigned short);
     int vec_all_ne (vector bool short, vector signed short);
     int vec_all_ne (vector pixel, vector pixel);
     int vec_all_ne (vector signed int, vector bool int);
     int vec_all_ne (vector signed int, vector signed int);
     int vec_all_ne (vector unsigned int, vector bool int);
     int vec_all_ne (vector unsigned int, vector unsigned int);
     int vec_all_ne (vector bool int, vector bool int);
     int vec_all_ne (vector bool int, vector unsigned int);
     int vec_all_ne (vector bool int, vector signed int);
     int vec_all_ne (vector float, vector float);

     int vec_all_nge (vector float, vector float);

     int vec_all_ngt (vector float, vector float);

     int vec_all_nle (vector float, vector float);

     int vec_all_nlt (vector float, vector float);

     int vec_all_numeric (vector float);

     int vec_any_eq (vector signed char, vector bool char);
     int vec_any_eq (vector signed char, vector signed char);
     int vec_any_eq (vector unsigned char, vector bool char);
     int vec_any_eq (vector unsigned char, vector unsigned char);
     int vec_any_eq (vector bool char, vector bool char);
     int vec_any_eq (vector bool char, vector unsigned char);
     int vec_any_eq (vector bool char, vector signed char);
     int vec_any_eq (vector signed short, vector bool short);
     int vec_any_eq (vector signed short, vector signed short);
     int vec_any_eq (vector unsigned short, vector bool short);
     int vec_any_eq (vector unsigned short, vector unsigned short);
     int vec_any_eq (vector bool short, vector bool short);
     int vec_any_eq (vector bool short, vector unsigned short);
     int vec_any_eq (vector bool short, vector signed short);
     int vec_any_eq (vector pixel, vector pixel);
     int vec_any_eq (vector signed int, vector bool int);
     int vec_any_eq (vector signed int, vector signed int);
     int vec_any_eq (vector unsigned int, vector bool int);
     int vec_any_eq (vector unsigned int, vector unsigned int);
     int vec_any_eq (vector bool int, vector bool int);
     int vec_any_eq (vector bool int, vector unsigned int);
     int vec_any_eq (vector bool int, vector signed int);
     int vec_any_eq (vector float, vector float);

     int vec_any_ge (vector signed char, vector bool char);
     int vec_any_ge (vector unsigned char, vector bool char);
     int vec_any_ge (vector unsigned char, vector unsigned char);
     int vec_any_ge (vector signed char, vector signed char);
     int vec_any_ge (vector bool char, vector unsigned char);
     int vec_any_ge (vector bool char, vector signed char);
     int vec_any_ge (vector unsigned short, vector bool short);
     int vec_any_ge (vector unsigned short, vector unsigned short);
     int vec_any_ge (vector signed short, vector signed short);
     int vec_any_ge (vector signed short, vector bool short);
     int vec_any_ge (vector bool short, vector unsigned short);
     int vec_any_ge (vector bool short, vector signed short);
     int vec_any_ge (vector signed int, vector bool int);
     int vec_any_ge (vector unsigned int, vector bool int);
     int vec_any_ge (vector unsigned int, vector unsigned int);
     int vec_any_ge (vector signed int, vector signed int);
     int vec_any_ge (vector bool int, vector unsigned int);
     int vec_any_ge (vector bool int, vector signed int);
     int vec_any_ge (vector float, vector float);

     int vec_any_gt (vector bool char, vector unsigned char);
     int vec_any_gt (vector unsigned char, vector bool char);
     int vec_any_gt (vector unsigned char, vector unsigned char);
     int vec_any_gt (vector bool char, vector signed char);
     int vec_any_gt (vector signed char, vector bool char);
     int vec_any_gt (vector signed char, vector signed char);
     int vec_any_gt (vector bool short, vector unsigned short);
     int vec_any_gt (vector unsigned short, vector bool short);
     int vec_any_gt (vector unsigned short, vector unsigned short);
     int vec_any_gt (vector bool short, vector signed short);
     int vec_any_gt (vector signed short, vector bool short);
     int vec_any_gt (vector signed short, vector signed short);
     int vec_any_gt (vector bool int, vector unsigned int);
     int vec_any_gt (vector unsigned int, vector bool int);
     int vec_any_gt (vector unsigned int, vector unsigned int);
     int vec_any_gt (vector bool int, vector signed int);
     int vec_any_gt (vector signed int, vector bool int);
     int vec_any_gt (vector signed int, vector signed int);
     int vec_any_gt (vector float, vector float);

     int vec_any_le (vector bool char, vector unsigned char);
     int vec_any_le (vector unsigned char, vector bool char);
     int vec_any_le (vector unsigned char, vector unsigned char);
     int vec_any_le (vector bool char, vector signed char);
     int vec_any_le (vector signed char, vector bool char);
     int vec_any_le (vector signed char, vector signed char);
     int vec_any_le (vector bool short, vector unsigned short);
     int vec_any_le (vector unsigned short, vector bool short);
     int vec_any_le (vector unsigned short, vector unsigned short);
     int vec_any_le (vector bool short, vector signed short);
     int vec_any_le (vector signed short, vector bool short);
     int vec_any_le (vector signed short, vector signed short);
     int vec_any_le (vector bool int, vector unsigned int);
     int vec_any_le (vector unsigned int, vector bool int);
     int vec_any_le (vector unsigned int, vector unsigned int);
     int vec_any_le (vector bool int, vector signed int);
     int vec_any_le (vector signed int, vector bool int);
     int vec_any_le (vector signed int, vector signed int);
     int vec_any_le (vector float, vector float);

     int vec_any_lt (vector bool char, vector unsigned char);
     int vec_any_lt (vector unsigned char, vector bool char);
     int vec_any_lt (vector unsigned char, vector unsigned char);
     int vec_any_lt (vector bool char, vector signed char);
     int vec_any_lt (vector signed char, vector bool char);
     int vec_any_lt (vector signed char, vector signed char);
     int vec_any_lt (vector bool short, vector unsigned short);
     int vec_any_lt (vector unsigned short, vector bool short);
     int vec_any_lt (vector unsigned short, vector unsigned short);
     int vec_any_lt (vector bool short, vector signed short);
     int vec_any_lt (vector signed short, vector bool short);
     int vec_any_lt (vector signed short, vector signed short);
     int vec_any_lt (vector bool int, vector unsigned int);
     int vec_any_lt (vector unsigned int, vector bool int);
     int vec_any_lt (vector unsigned int, vector unsigned int);
     int vec_any_lt (vector bool int, vector signed int);
     int vec_any_lt (vector signed int, vector bool int);
     int vec_any_lt (vector signed int, vector signed int);
     int vec_any_lt (vector float, vector float);

     int vec_any_nan (vector float);

     int vec_any_ne (vector signed char, vector bool char);
     int vec_any_ne (vector signed char, vector signed char);
     int vec_any_ne (vector unsigned char, vector bool char);
     int vec_any_ne (vector unsigned char, vector unsigned char);
     int vec_any_ne (vector bool char, vector bool char);
     int vec_any_ne (vector bool char, vector unsigned char);
     int vec_any_ne (vector bool char, vector signed char);
     int vec_any_ne (vector signed short, vector bool short);
     int vec_any_ne (vector signed short, vector signed short);
     int vec_any_ne (vector unsigned short, vector bool short);
     int vec_any_ne (vector unsigned short, vector unsigned short);
     int vec_any_ne (vector bool short, vector bool short);
     int vec_any_ne (vector bool short, vector unsigned short);
     int vec_any_ne (vector bool short, vector signed short);
     int vec_any_ne (vector pixel, vector pixel);
     int vec_any_ne (vector signed int, vector bool int);
     int vec_any_ne (vector signed int, vector signed int);
     int vec_any_ne (vector unsigned int, vector bool int);
     int vec_any_ne (vector unsigned int, vector unsigned int);
     int vec_any_ne (vector bool int, vector bool int);
     int vec_any_ne (vector bool int, vector unsigned int);
     int vec_any_ne (vector bool int, vector signed int);
     int vec_any_ne (vector float, vector float);

     int vec_any_nge (vector float, vector float);

     int vec_any_ngt (vector float, vector float);

     int vec_any_nle (vector float, vector float);

     int vec_any_nlt (vector float, vector float);

     int vec_any_numeric (vector float);

     int vec_any_out (vector float, vector float);

 If the vector/scalar (VSX) instruction set is available, the following
additional functions are available:

     vector double vec_abs (vector double);
     vector double vec_add (vector double, vector double);
     vector double vec_and (vector double, vector double);
     vector double vec_and (vector double, vector bool long);
     vector double vec_and (vector bool long, vector double);
     vector long vec_and (vector long, vector long);
     vector long vec_and (vector long, vector bool long);
     vector long vec_and (vector bool long, vector long);
     vector unsigned long vec_and (vector unsigned long, vector unsigned long);
     vector unsigned long vec_and (vector unsigned long, vector bool long);
     vector unsigned long vec_and (vector bool long, vector unsigned long);
     vector double vec_andc (vector double, vector double);
     vector double vec_andc (vector double, vector bool long);
     vector double vec_andc (vector bool long, vector double);
     vector long vec_andc (vector long, vector long);
     vector long vec_andc (vector long, vector bool long);
     vector long vec_andc (vector bool long, vector long);
     vector unsigned long vec_andc (vector unsigned long, vector unsigned long);
     vector unsigned long vec_andc (vector unsigned long, vector bool long);
     vector unsigned long vec_andc (vector bool long, vector unsigned long);
     vector double vec_ceil (vector double);
     vector bool long vec_cmpeq (vector double, vector double);
     vector bool long vec_cmpge (vector double, vector double);
     vector bool long vec_cmpgt (vector double, vector double);
     vector bool long vec_cmple (vector double, vector double);
     vector bool long vec_cmplt (vector double, vector double);
     vector double vec_cpsgn (vector double, vector double);
     vector float vec_div (vector float, vector float);
     vector double vec_div (vector double, vector double);
     vector long vec_div (vector long, vector long);
     vector unsigned long vec_div (vector unsigned long, vector unsigned long);
     vector double vec_floor (vector double);
     vector double vec_ld (int, const vector double *);
     vector double vec_ld (int, const double *);
     vector double vec_ldl (int, const vector double *);
     vector double vec_ldl (int, const double *);
     vector unsigned char vec_lvsl (int, const volatile double *);
     vector unsigned char vec_lvsr (int, const volatile double *);
     vector double vec_madd (vector double, vector double, vector double);
     vector double vec_max (vector double, vector double);
     vector signed long vec_mergeh (vector signed long, vector signed long);
     vector signed long vec_mergeh (vector signed long, vector bool long);
     vector signed long vec_mergeh (vector bool long, vector signed long);
     vector unsigned long vec_mergeh (vector unsigned long, vector unsigned long);
     vector unsigned long vec_mergeh (vector unsigned long, vector bool long);
     vector unsigned long vec_mergeh (vector bool long, vector unsigned long);
     vector signed long vec_mergel (vector signed long, vector signed long);
     vector signed long vec_mergel (vector signed long, vector bool long);
     vector signed long vec_mergel (vector bool long, vector signed long);
     vector unsigned long vec_mergel (vector unsigned long, vector unsigned long);
     vector unsigned long vec_mergel (vector unsigned long, vector bool long);
     vector unsigned long vec_mergel (vector bool long, vector unsigned long);
     vector double vec_min (vector double, vector double);
     vector float vec_msub (vector float, vector float, vector float);
     vector double vec_msub (vector double, vector double, vector double);
     vector float vec_mul (vector float, vector float);
     vector double vec_mul (vector double, vector double);
     vector long vec_mul (vector long, vector long);
     vector unsigned long vec_mul (vector unsigned long, vector unsigned long);
     vector float vec_nearbyint (vector float);
     vector double vec_nearbyint (vector double);
     vector float vec_nmadd (vector float, vector float, vector float);
     vector double vec_nmadd (vector double, vector double, vector double);
     vector double vec_nmsub (vector double, vector double, vector double);
     vector double vec_nor (vector double, vector double);
     vector long vec_nor (vector long, vector long);
     vector long vec_nor (vector long, vector bool long);
     vector long vec_nor (vector bool long, vector long);
     vector unsigned long vec_nor (vector unsigned long, vector unsigned long);
     vector unsigned long vec_nor (vector unsigned long, vector bool long);
     vector unsigned long vec_nor (vector bool long, vector unsigned long);
     vector double vec_or (vector double, vector double);
     vector double vec_or (vector double, vector bool long);
     vector double vec_or (vector bool long, vector double);
     vector long vec_or (vector long, vector long);
     vector long vec_or (vector long, vector bool long);
     vector long vec_or (vector bool long, vector long);
     vector unsigned long vec_or (vector unsigned long, vector unsigned long);
     vector unsigned long vec_or (vector unsigned long, vector bool long);
     vector unsigned long vec_or (vector bool long, vector unsigned long);
     vector double vec_perm (vector double, vector double, vector unsigned char);
     vector long vec_perm (vector long, vector long, vector unsigned char);
     vector unsigned long vec_perm (vector unsigned long, vector unsigned long,
                                    vector unsigned char);
     vector double vec_rint (vector double);
     vector double vec_recip (vector double, vector double);
     vector double vec_rsqrt (vector double);
     vector double vec_rsqrte (vector double);
     vector double vec_sel (vector double, vector double, vector bool long);
     vector double vec_sel (vector double, vector double, vector unsigned long);
     vector long vec_sel (vector long, vector long, vector long);
     vector long vec_sel (vector long, vector long, vector unsigned long);
     vector long vec_sel (vector long, vector long, vector bool long);
     vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                                   vector long);
     vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                                   vector unsigned long);
     vector unsigned long vec_sel (vector unsigned long, vector unsigned long,
                                   vector bool long);
     vector double vec_splats (double);
     vector signed long vec_splats (signed long);
     vector unsigned long vec_splats (unsigned long);
     vector float vec_sqrt (vector float);
     vector double vec_sqrt (vector double);
     void vec_st (vector double, int, vector double *);
     void vec_st (vector double, int, double *);
     vector double vec_sub (vector double, vector double);
     vector double vec_trunc (vector double);
     vector double vec_xor (vector double, vector double);
     vector double vec_xor (vector double, vector bool long);
     vector double vec_xor (vector bool long, vector double);
     vector long vec_xor (vector long, vector long);
     vector long vec_xor (vector long, vector bool long);
     vector long vec_xor (vector bool long, vector long);
     vector unsigned long vec_xor (vector unsigned long, vector unsigned long);
     vector unsigned long vec_xor (vector unsigned long, vector bool long);
     vector unsigned long vec_xor (vector bool long, vector unsigned long);
     int vec_all_eq (vector double, vector double);
     int vec_all_ge (vector double, vector double);
     int vec_all_gt (vector double, vector double);
     int vec_all_le (vector double, vector double);
     int vec_all_lt (vector double, vector double);
     int vec_all_nan (vector double);
     int vec_all_ne (vector double, vector double);
     int vec_all_nge (vector double, vector double);
     int vec_all_ngt (vector double, vector double);
     int vec_all_nle (vector double, vector double);
     int vec_all_nlt (vector double, vector double);
     int vec_all_numeric (vector double);
     int vec_any_eq (vector double, vector double);
     int vec_any_ge (vector double, vector double);
     int vec_any_gt (vector double, vector double);
     int vec_any_le (vector double, vector double);
     int vec_any_lt (vector double, vector double);
     int vec_any_nan (vector double);
     int vec_any_ne (vector double, vector double);
     int vec_any_nge (vector double, vector double);
     int vec_any_ngt (vector double, vector double);
     int vec_any_nle (vector double, vector double);
     int vec_any_nlt (vector double, vector double);
     int vec_any_numeric (vector double);

     vector double vec_vsx_ld (int, const vector double *);
     vector double vec_vsx_ld (int, const double *);
     vector float vec_vsx_ld (int, const vector float *);
     vector float vec_vsx_ld (int, const float *);
     vector bool int vec_vsx_ld (int, const vector bool int *);
     vector signed int vec_vsx_ld (int, const vector signed int *);
     vector signed int vec_vsx_ld (int, const int *);
     vector signed int vec_vsx_ld (int, const long *);
     vector unsigned int vec_vsx_ld (int, const vector unsigned int *);
     vector unsigned int vec_vsx_ld (int, const unsigned int *);
     vector unsigned int vec_vsx_ld (int, const unsigned long *);
     vector bool short vec_vsx_ld (int, const vector bool short *);
     vector pixel vec_vsx_ld (int, const vector pixel *);
     vector signed short vec_vsx_ld (int, const vector signed short *);
     vector signed short vec_vsx_ld (int, const short *);
     vector unsigned short vec_vsx_ld (int, const vector unsigned short *);
     vector unsigned short vec_vsx_ld (int, const unsigned short *);
     vector bool char vec_vsx_ld (int, const vector bool char *);
     vector signed char vec_vsx_ld (int, const vector signed char *);
     vector signed char vec_vsx_ld (int, const signed char *);
     vector unsigned char vec_vsx_ld (int, const vector unsigned char *);
     vector unsigned char vec_vsx_ld (int, const unsigned char *);

     void vec_vsx_st (vector double, int, vector double *);
     void vec_vsx_st (vector double, int, double *);
     void vec_vsx_st (vector float, int, vector float *);
     void vec_vsx_st (vector float, int, float *);
     void vec_vsx_st (vector signed int, int, vector signed int *);
     void vec_vsx_st (vector signed int, int, int *);
     void vec_vsx_st (vector unsigned int, int, vector unsigned int *);
     void vec_vsx_st (vector unsigned int, int, unsigned int *);
     void vec_vsx_st (vector bool int, int, vector bool int *);
     void vec_vsx_st (vector bool int, int, unsigned int *);
     void vec_vsx_st (vector bool int, int, int *);
     void vec_vsx_st (vector signed short, int, vector signed short *);
     void vec_vsx_st (vector signed short, int, short *);
     void vec_vsx_st (vector unsigned short, int, vector unsigned short *);
     void vec_vsx_st (vector unsigned short, int, unsigned short *);
     void vec_vsx_st (vector bool short, int, vector bool short *);
     void vec_vsx_st (vector bool short, int, unsigned short *);
     void vec_vsx_st (vector pixel, int, vector pixel *);
     void vec_vsx_st (vector pixel, int, unsigned short *);
     void vec_vsx_st (vector pixel, int, short *);
     void vec_vsx_st (vector bool short, int, short *);
     void vec_vsx_st (vector signed char, int, vector signed char *);
     void vec_vsx_st (vector signed char, int, signed char *);
     void vec_vsx_st (vector unsigned char, int, vector unsigned char *);
     void vec_vsx_st (vector unsigned char, int, unsigned char *);
     void vec_vsx_st (vector bool char, int, vector bool char *);
     void vec_vsx_st (vector bool char, int, unsigned char *);
     void vec_vsx_st (vector bool char, int, signed char *);

     vector double vec_xxpermdi (vector double, vector double, int);
     vector float vec_xxpermdi (vector float, vector float, int);
     vector long long vec_xxpermdi (vector long long, vector long long, int);
     vector unsigned long long vec_xxpermdi (vector unsigned long long,
                                             vector unsigned long long, int);
     vector int vec_xxpermdi (vector int, vector int, int);
     vector unsigned int vec_xxpermdi (vector unsigned int,
                                       vector unsigned int, int);
     vector short vec_xxpermdi (vector short, vector short, int);
     vector unsigned short vec_xxpermdi (vector unsigned short,
                                         vector unsigned short, int);
     vector signed char vec_xxpermdi (vector signed char, vector signed char, int);
     vector unsigned char vec_xxpermdi (vector unsigned char,
                                        vector unsigned char, int);

     vector double vec_xxsldi (vector double, vector double, int);
     vector float vec_xxsldi (vector float, vector float, int);
     vector long long vec_xxsldi (vector long long, vector long long, int);
     vector unsigned long long vec_xxsldi (vector unsigned long long,
                                           vector unsigned long long, int);
     vector int vec_xxsldi (vector int, vector int, int);
     vector unsigned int vec_xxsldi (vector unsigned int, vector unsigned int, int);
     vector short vec_xxsldi (vector short, vector short, int);
     vector unsigned short vec_xxsldi (vector unsigned short,
                                       vector unsigned short, int);
     vector signed char vec_xxsldi (vector signed char, vector signed char, int);
     vector unsigned char vec_xxsldi (vector unsigned char,
                                      vector unsigned char, int);

 Note that the 'vec_ld' and 'vec_st' built-in functions always generate
the AltiVec 'LVX' and 'STVX' instructions even if the VSX instruction
set is available.  The 'vec_vsx_ld' and 'vec_vsx_st' built-in functions
always generate the VSX 'LXVD2X', 'LXVW4X', 'STXVD2X', and 'STXVW4X'
instructions.

 If the ISA 2.07 additions to the vector/scalar (power8-vector)
instruction set is available, the following additional functions are
available for both 32-bit and 64-bit targets.  For 64-bit targets, you
can use VECTOR LONG instead of VECTOR LONG LONG, VECTOR BOOL LONG
instead of VECTOR BOOL LONG LONG, and VECTOR UNSIGNED LONG instead of
VECTOR UNSIGNED LONG LONG.

     vector long long vec_abs (vector long long);

     vector long long vec_add (vector long long, vector long long);
     vector unsigned long long vec_add (vector unsigned long long,
                                        vector unsigned long long);

     int vec_all_eq (vector long long, vector long long);
     int vec_all_eq (vector unsigned long long, vector unsigned long long);
     int vec_all_ge (vector long long, vector long long);
     int vec_all_ge (vector unsigned long long, vector unsigned long long);
     int vec_all_gt (vector long long, vector long long);
     int vec_all_gt (vector unsigned long long, vector unsigned long long);
     int vec_all_le (vector long long, vector long long);
     int vec_all_le (vector unsigned long long, vector unsigned long long);
     int vec_all_lt (vector long long, vector long long);
     int vec_all_lt (vector unsigned long long, vector unsigned long long);
     int vec_all_ne (vector long long, vector long long);
     int vec_all_ne (vector unsigned long long, vector unsigned long long);

     int vec_any_eq (vector long long, vector long long);
     int vec_any_eq (vector unsigned long long, vector unsigned long long);
     int vec_any_ge (vector long long, vector long long);
     int vec_any_ge (vector unsigned long long, vector unsigned long long);
     int vec_any_gt (vector long long, vector long long);
     int vec_any_gt (vector unsigned long long, vector unsigned long long);
     int vec_any_le (vector long long, vector long long);
     int vec_any_le (vector unsigned long long, vector unsigned long long);
     int vec_any_lt (vector long long, vector long long);
     int vec_any_lt (vector unsigned long long, vector unsigned long long);
     int vec_any_ne (vector long long, vector long long);
     int vec_any_ne (vector unsigned long long, vector unsigned long long);

     vector long long vec_eqv (vector long long, vector long long);
     vector long long vec_eqv (vector bool long long, vector long long);
     vector long long vec_eqv (vector long long, vector bool long long);
     vector unsigned long long vec_eqv (vector unsigned long long,
                                        vector unsigned long long);
     vector unsigned long long vec_eqv (vector bool long long,
                                        vector unsigned long long);
     vector unsigned long long vec_eqv (vector unsigned long long,
                                        vector bool long long);
     vector int vec_eqv (vector int, vector int);
     vector int vec_eqv (vector bool int, vector int);
     vector int vec_eqv (vector int, vector bool int);
     vector unsigned int vec_eqv (vector unsigned int, vector unsigned int);
     vector unsigned int vec_eqv (vector bool unsigned int,
                                  vector unsigned int);
     vector unsigned int vec_eqv (vector unsigned int,
                                  vector bool unsigned int);
     vector short vec_eqv (vector short, vector short);
     vector short vec_eqv (vector bool short, vector short);
     vector short vec_eqv (vector short, vector bool short);
     vector unsigned short vec_eqv (vector unsigned short, vector unsigned short);
     vector unsigned short vec_eqv (vector bool unsigned short,
                                    vector unsigned short);
     vector unsigned short vec_eqv (vector unsigned short,
                                    vector bool unsigned short);
     vector signed char vec_eqv (vector signed char, vector signed char);
     vector signed char vec_eqv (vector bool signed char, vector signed char);
     vector signed char vec_eqv (vector signed char, vector bool signed char);
     vector unsigned char vec_eqv (vector unsigned char, vector unsigned char);
     vector unsigned char vec_eqv (vector bool unsigned char, vector unsigned char);
     vector unsigned char vec_eqv (vector unsigned char, vector bool unsigned char);

     vector long long vec_max (vector long long, vector long long);
     vector unsigned long long vec_max (vector unsigned long long,
                                        vector unsigned long long);

     vector signed int vec_mergee (vector signed int, vector signed int);
     vector unsigned int vec_mergee (vector unsigned int, vector unsigned int);
     vector bool int vec_mergee (vector bool int, vector bool int);

     vector signed int vec_mergeo (vector signed int, vector signed int);
     vector unsigned int vec_mergeo (vector unsigned int, vector unsigned int);
     vector bool int vec_mergeo (vector bool int, vector bool int);

     vector long long vec_min (vector long long, vector long long);
     vector unsigned long long vec_min (vector unsigned long long,
                                        vector unsigned long long);

     vector long long vec_nand (vector long long, vector long long);
     vector long long vec_nand (vector bool long long, vector long long);
     vector long long vec_nand (vector long long, vector bool long long);
     vector unsigned long long vec_nand (vector unsigned long long,
                                         vector unsigned long long);
     vector unsigned long long vec_nand (vector bool long long,
                                        vector unsigned long long);
     vector unsigned long long vec_nand (vector unsigned long long,
                                         vector bool long long);
     vector int vec_nand (vector int, vector int);
     vector int vec_nand (vector bool int, vector int);
     vector int vec_nand (vector int, vector bool int);
     vector unsigned int vec_nand (vector unsigned int, vector unsigned int);
     vector unsigned int vec_nand (vector bool unsigned int,
                                   vector unsigned int);
     vector unsigned int vec_nand (vector unsigned int,
                                   vector bool unsigned int);
     vector short vec_nand (vector short, vector short);
     vector short vec_nand (vector bool short, vector short);
     vector short vec_nand (vector short, vector bool short);
     vector unsigned short vec_nand (vector unsigned short, vector unsigned short);
     vector unsigned short vec_nand (vector bool unsigned short,
                                     vector unsigned short);
     vector unsigned short vec_nand (vector unsigned short,
                                     vector bool unsigned short);
     vector signed char vec_nand (vector signed char, vector signed char);
     vector signed char vec_nand (vector bool signed char, vector signed char);
     vector signed char vec_nand (vector signed char, vector bool signed char);
     vector unsigned char vec_nand (vector unsigned char, vector unsigned char);
     vector unsigned char vec_nand (vector bool unsigned char, vector unsigned char);
     vector unsigned char vec_nand (vector unsigned char, vector bool unsigned char);

     vector long long vec_orc (vector long long, vector long long);
     vector long long vec_orc (vector bool long long, vector long long);
     vector long long vec_orc (vector long long, vector bool long long);
     vector unsigned long long vec_orc (vector unsigned long long,
                                        vector unsigned long long);
     vector unsigned long long vec_orc (vector bool long long,
                                        vector unsigned long long);
     vector unsigned long long vec_orc (vector unsigned long long,
                                        vector bool long long);
     vector int vec_orc (vector int, vector int);
     vector int vec_orc (vector bool int, vector int);
     vector int vec_orc (vector int, vector bool int);
     vector unsigned int vec_orc (vector unsigned int, vector unsigned int);
     vector unsigned int vec_orc (vector bool unsigned int,
                                  vector unsigned int);
     vector unsigned int vec_orc (vector unsigned int,
                                  vector bool unsigned int);
     vector short vec_orc (vector short, vector short);
     vector short vec_orc (vector bool short, vector short);
     vector short vec_orc (vector short, vector bool short);
     vector unsigned short vec_orc (vector unsigned short, vector unsigned short);
     vector unsigned short vec_orc (vector bool unsigned short,
                                    vector unsigned short);
     vector unsigned short vec_orc (vector unsigned short,
                                    vector bool unsigned short);
     vector signed char vec_orc (vector signed char, vector signed char);
     vector signed char vec_orc (vector bool signed char, vector signed char);
     vector signed char vec_orc (vector signed char, vector bool signed char);
     vector unsigned char vec_orc (vector unsigned char, vector unsigned char);
     vector unsigned char vec_orc (vector bool unsigned char, vector unsigned char);
     vector unsigned char vec_orc (vector unsigned char, vector bool unsigned char);

     vector int vec_pack (vector long long, vector long long);
     vector unsigned int vec_pack (vector unsigned long long,
                                   vector unsigned long long);
     vector bool int vec_pack (vector bool long long, vector bool long long);

     vector int vec_packs (vector long long, vector long long);
     vector unsigned int vec_packs (vector unsigned long long,
                                    vector unsigned long long);

     vector unsigned int vec_packsu (vector long long, vector long long);
     vector unsigned int vec_packsu (vector unsigned long long,
                                     vector unsigned long long);

     vector long long vec_rl (vector long long,
                              vector unsigned long long);
     vector long long vec_rl (vector unsigned long long,
                              vector unsigned long long);

     vector long long vec_sl (vector long long, vector unsigned long long);
     vector long long vec_sl (vector unsigned long long,
                              vector unsigned long long);

     vector long long vec_sr (vector long long, vector unsigned long long);
     vector unsigned long long char vec_sr (vector unsigned long long,
                                            vector unsigned long long);

     vector long long vec_sra (vector long long, vector unsigned long long);
     vector unsigned long long vec_sra (vector unsigned long long,
                                        vector unsigned long long);

     vector long long vec_sub (vector long long, vector long long);
     vector unsigned long long vec_sub (vector unsigned long long,
                                        vector unsigned long long);

     vector long long vec_unpackh (vector int);
     vector unsigned long long vec_unpackh (vector unsigned int);

     vector long long vec_unpackl (vector int);
     vector unsigned long long vec_unpackl (vector unsigned int);

     vector long long vec_vaddudm (vector long long, vector long long);
     vector long long vec_vaddudm (vector bool long long, vector long long);
     vector long long vec_vaddudm (vector long long, vector bool long long);
     vector unsigned long long vec_vaddudm (vector unsigned long long,
                                            vector unsigned long long);
     vector unsigned long long vec_vaddudm (vector bool unsigned long long,
                                            vector unsigned long long);
     vector unsigned long long vec_vaddudm (vector unsigned long long,
                                            vector bool unsigned long long);

     vector long long vec_vbpermq (vector signed char, vector signed char);
     vector long long vec_vbpermq (vector unsigned char, vector unsigned char);

     vector long long vec_cntlz (vector long long);
     vector unsigned long long vec_cntlz (vector unsigned long long);
     vector int vec_cntlz (vector int);
     vector unsigned int vec_cntlz (vector int);
     vector short vec_cntlz (vector short);
     vector unsigned short vec_cntlz (vector unsigned short);
     vector signed char vec_cntlz (vector signed char);
     vector unsigned char vec_cntlz (vector unsigned char);

     vector long long vec_vclz (vector long long);
     vector unsigned long long vec_vclz (vector unsigned long long);
     vector int vec_vclz (vector int);
     vector unsigned int vec_vclz (vector int);
     vector short vec_vclz (vector short);
     vector unsigned short vec_vclz (vector unsigned short);
     vector signed char vec_vclz (vector signed char);
     vector unsigned char vec_vclz (vector unsigned char);

     vector signed char vec_vclzb (vector signed char);
     vector unsigned char vec_vclzb (vector unsigned char);

     vector long long vec_vclzd (vector long long);
     vector unsigned long long vec_vclzd (vector unsigned long long);

     vector short vec_vclzh (vector short);
     vector unsigned short vec_vclzh (vector unsigned short);

     vector int vec_vclzw (vector int);
     vector unsigned int vec_vclzw (vector int);

     vector signed char vec_vgbbd (vector signed char);
     vector unsigned char vec_vgbbd (vector unsigned char);

     vector long long vec_vmaxsd (vector long long, vector long long);

     vector unsigned long long vec_vmaxud (vector unsigned long long,
                                           unsigned vector long long);

     vector long long vec_vminsd (vector long long, vector long long);

     vector unsigned long long vec_vminud (vector long long,
                                           vector long long);

     vector int vec_vpksdss (vector long long, vector long long);
     vector unsigned int vec_vpksdss (vector long long, vector long long);

     vector unsigned int vec_vpkudus (vector unsigned long long,
                                      vector unsigned long long);

     vector int vec_vpkudum (vector long long, vector long long);
     vector unsigned int vec_vpkudum (vector unsigned long long,
                                      vector unsigned long long);
     vector bool int vec_vpkudum (vector bool long long, vector bool long long);

     vector long long vec_vpopcnt (vector long long);
     vector unsigned long long vec_vpopcnt (vector unsigned long long);
     vector int vec_vpopcnt (vector int);
     vector unsigned int vec_vpopcnt (vector int);
     vector short vec_vpopcnt (vector short);
     vector unsigned short vec_vpopcnt (vector unsigned short);
     vector signed char vec_vpopcnt (vector signed char);
     vector unsigned char vec_vpopcnt (vector unsigned char);

     vector signed char vec_vpopcntb (vector signed char);
     vector unsigned char vec_vpopcntb (vector unsigned char);

     vector long long vec_vpopcntd (vector long long);
     vector unsigned long long vec_vpopcntd (vector unsigned long long);

     vector short vec_vpopcnth (vector short);
     vector unsigned short vec_vpopcnth (vector unsigned short);

     vector int vec_vpopcntw (vector int);
     vector unsigned int vec_vpopcntw (vector int);

     vector long long vec_vrld (vector long long, vector unsigned long long);
     vector unsigned long long vec_vrld (vector unsigned long long,
                                         vector unsigned long long);

     vector long long vec_vsld (vector long long, vector unsigned long long);
     vector long long vec_vsld (vector unsigned long long,
                                vector unsigned long long);

     vector long long vec_vsrad (vector long long, vector unsigned long long);
     vector unsigned long long vec_vsrad (vector unsigned long long,
                                          vector unsigned long long);

     vector long long vec_vsrd (vector long long, vector unsigned long long);
     vector unsigned long long char vec_vsrd (vector unsigned long long,
                                              vector unsigned long long);

     vector long long vec_vsubudm (vector long long, vector long long);
     vector long long vec_vsubudm (vector bool long long, vector long long);
     vector long long vec_vsubudm (vector long long, vector bool long long);
     vector unsigned long long vec_vsubudm (vector unsigned long long,
                                            vector unsigned long long);
     vector unsigned long long vec_vsubudm (vector bool long long,
                                            vector unsigned long long);
     vector unsigned long long vec_vsubudm (vector unsigned long long,
                                            vector bool long long);

     vector long long vec_vupkhsw (vector int);
     vector unsigned long long vec_vupkhsw (vector unsigned int);

     vector long long vec_vupklsw (vector int);
     vector unsigned long long vec_vupklsw (vector int);

 If the ISA 2.07 additions to the vector/scalar (power8-vector)
instruction set is available, the following additional functions are
available for 64-bit targets.  New vector types (VECTOR __INT128_T and
VECTOR __UINT128_T) are available to hold the __INT128_T and __UINT128_T
types to use these builtins.

 The normal vector extract, and set operations work on VECTOR __INT128_T
and VECTOR __UINT128_T types, but the index value must be 0.

     vector __int128_t vec_vaddcuq (vector __int128_t, vector __int128_t);
     vector __uint128_t vec_vaddcuq (vector __uint128_t, vector __uint128_t);

     vector __int128_t vec_vadduqm (vector __int128_t, vector __int128_t);
     vector __uint128_t vec_vadduqm (vector __uint128_t, vector __uint128_t);

     vector __int128_t vec_vaddecuq (vector __int128_t, vector __int128_t,
                                     vector __int128_t);
     vector __uint128_t vec_vaddecuq (vector __uint128_t, vector __uint128_t,
                                      vector __uint128_t);

     vector __int128_t vec_vaddeuqm (vector __int128_t, vector __int128_t,
                                     vector __int128_t);
     vector __uint128_t vec_vaddeuqm (vector __uint128_t, vector __uint128_t,
                                      vector __uint128_t);

     vector __int128_t vec_vsubecuq (vector __int128_t, vector __int128_t,
                                     vector __int128_t);
     vector __uint128_t vec_vsubecuq (vector __uint128_t, vector __uint128_t,
                                      vector __uint128_t);

     vector __int128_t vec_vsubeuqm (vector __int128_t, vector __int128_t,
                                     vector __int128_t);
     vector __uint128_t vec_vsubeuqm (vector __uint128_t, vector __uint128_t,
                                      vector __uint128_t);

     vector __int128_t vec_vsubcuq (vector __int128_t, vector __int128_t);
     vector __uint128_t vec_vsubcuq (vector __uint128_t, vector __uint128_t);

     __int128_t vec_vsubuqm (__int128_t, __int128_t);
     __uint128_t vec_vsubuqm (__uint128_t, __uint128_t);

     vector __int128_t __builtin_bcdadd (vector __int128_t, vector__int128_t);
     int __builtin_bcdadd_lt (vector __int128_t, vector__int128_t);
     int __builtin_bcdadd_eq (vector __int128_t, vector__int128_t);
     int __builtin_bcdadd_gt (vector __int128_t, vector__int128_t);
     int __builtin_bcdadd_ov (vector __int128_t, vector__int128_t);
     vector __int128_t bcdsub (vector __int128_t, vector__int128_t);
     int __builtin_bcdsub_lt (vector __int128_t, vector__int128_t);
     int __builtin_bcdsub_eq (vector __int128_t, vector__int128_t);
     int __builtin_bcdsub_gt (vector __int128_t, vector__int128_t);
     int __builtin_bcdsub_ov (vector __int128_t, vector__int128_t);

 If the cryptographic instructions are enabled ('-mcrypto' or
'-mcpu=power8'), the following builtins are enabled.

     vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);

     vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,
                                                         vector unsigned long long);

     vector unsigned long long __builtin_crypto_vcipherlast
                                          (vector unsigned long long,
                                           vector unsigned long long);

     vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,
                                                          vector unsigned long long);

     vector unsigned long long __builtin_crypto_vncipherlast
                                          (vector unsigned long long,
                                           vector unsigned long long);

     vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,
                                                     vector unsigned char,
                                                     vector unsigned char);

     vector unsigned short __builtin_crypto_vpermxor (vector unsigned short,
                                                      vector unsigned short,
                                                      vector unsigned short);

     vector unsigned int __builtin_crypto_vpermxor (vector unsigned int,
                                                    vector unsigned int,
                                                    vector unsigned int);

     vector unsigned long long __builtin_crypto_vpermxor (vector unsigned long long,
                                                          vector unsigned long long,
                                                          vector unsigned long long);

     vector unsigned char __builtin_crypto_vpmsumb (vector unsigned char,
                                                    vector unsigned char);

     vector unsigned short __builtin_crypto_vpmsumb (vector unsigned short,
                                                     vector unsigned short);

     vector unsigned int __builtin_crypto_vpmsumb (vector unsigned int,
                                                   vector unsigned int);

     vector unsigned long long __builtin_crypto_vpmsumb (vector unsigned long long,
                                                         vector unsigned long long);

     vector unsigned long long __builtin_crypto_vshasigmad
                                    (vector unsigned long long, int, int);

     vector unsigned int __builtin_crypto_vshasigmaw (vector unsigned int,
                                                      int, int);

 The second argument to the __BUILTIN_CRYPTO_VSHASIGMAD and
__BUILTIN_CRYPTO_VSHASIGMAW builtin functions must be a constant integer
that is 0 or 1.  The third argument to these builtin functions must be a
constant integer in the range of 0 to 15.

