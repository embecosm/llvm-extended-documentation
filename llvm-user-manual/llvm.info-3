This is llvm.info, produced by makeinfo version 5.2 from llvm.texi.

Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies published by
Embecosm support introducing others to free and open source software and
hardware.
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* llvm: (llvm).                The LLVM compiler
END-INFO-DIR-ENTRY

 This file documents the use of the LLVM compiler.

 Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies published by
Embecosm support introducing others to free and open source software and
hardware.


File: llvm.info,  Node: Label Attributes,  Next: Attribute Syntax,  Prev: Function Attributes,  Up: C Extensions

6.32 Label Attributes
=====================

GCC allows attributes to be set on C labels.  *Note Attribute Syntax::,
for details of the exact syntax for using attributes.  Other attributes
are available for functions (*note Function Attributes::), variables
(*note Variable Attributes::) and for types (*note Type Attributes::).

 This example uses the 'cold' label attribute to indicate the
'ErrorHandling' branch is unlikely to be taken and that the
'ErrorHandling' label is unused:


        asm goto ("some asm" : : : : NoError);

     /* This branch (the fall-through from the asm) is less commonly used */
     ErrorHandling:
        __attribute__((cold, unused)); /* Semi-colon is required here */
        printf("error\n");
        return 0;

     NoError:
        printf("no error\n");
        return 1;

'unused'
     This feature is intended for program-generated code that may
     contain unused labels, but which is compiled with '-Wall'.  It is
     not normally appropriate to use in it human-written code, though it
     could be useful in cases where the code that jumps to the label is
     contained within an '#ifdef' conditional.

'hot'
     The 'hot' attribute on a label is used to inform the compiler that
     the path following the label is more likely than paths that are not
     so annotated.  This attribute is used in cases where
     '__builtin_expect' cannot be used, for instance with computed goto
     or 'asm goto'.

'cold'
     The 'cold' attribute on labels is used to inform the compiler that
     the path following the label is unlikely to be executed.  This
     attribute is used in cases where '__builtin_expect' cannot be used,
     for instance with computed goto or 'asm goto'.


File: llvm.info,  Node: Attribute Syntax,  Next: Function Prototypes,  Prev: Label Attributes,  Up: C Extensions

6.33 Attribute Syntax
=====================

This section describes the syntax with which '__attribute__' may be
used, and the constructs to which attribute specifiers bind, for the C
language.  Some details may vary for C++ and Objective-C.  Because of
infelicities in the grammar for attributes, some forms described here
may not be successfully parsed in all cases.

 There are some problems with the semantics of attributes in C++.  For
example, there are no manglings for attributes, although they may affect
code generation, so problems may arise when attributed types are used in
conjunction with templates or overloading.  Similarly, 'typeid' does not
distinguish between types with different attributes.  Support for
attributes in C++ may be restricted in future to attributes on
declarations only, but not on nested declarators.

 *Note Function Attributes::, for details of the semantics of attributes
applying to functions.  *Note Variable Attributes::, for details of the
semantics of attributes applying to variables.  *Note Type Attributes::,
for details of the semantics of attributes applying to structure, union
and enumerated types.  *Note Label Attributes::, for details of the
semantics of attributes applying to labels.

 An "attribute specifier" is of the form '__attribute__
((ATTRIBUTE-LIST))'.  An "attribute list" is a possibly empty
comma-separated sequence of "attributes", where each attribute is one of
the following:

   * Empty.  Empty attributes are ignored.

   * A word (which may be an identifier such as 'unused', or a reserved
     word such as 'const').

   * A word, followed by, in parentheses, parameters for the attribute.
     These parameters take one of the following forms:

        * An identifier.  For example, 'mode' attributes use this form.

        * An identifier followed by a comma and a non-empty
          comma-separated list of expressions.  For example, 'format'
          attributes use this form.

        * A possibly empty comma-separated list of expressions.  For
          example, 'format_arg' attributes use this form with the list
          being a single integer constant expression, and 'alias'
          attributes use this form with the list being a single string
          constant.

 An "attribute specifier list" is a sequence of one or more attribute
specifiers, not separated by any other tokens.

Label Attributes
................

In GNU C, an attribute specifier list may appear after the colon
following a label, other than a 'case' or 'default' label.  GNU C++ only
permits attributes on labels if the attribute specifier is immediately
followed by a semicolon (i.e., the label applies to an empty statement).
If the semicolon is missing, C++ label attributes are ambiguous, as it
is permissible for a declaration, which could begin with an attribute
list, to be labelled in C++.  Declarations cannot be labelled in C90 or
C99, so the ambiguity does not arise there.

Type Attributes
...............

An attribute specifier list may appear as part of a 'struct', 'union' or
'enum' specifier.  It may go either immediately after the 'struct',
'union' or 'enum' keyword, or after the closing brace.  The former
syntax is preferred.  Where attribute specifiers follow the closing
brace, they are considered to relate to the structure, union or
enumerated type defined, not to any enclosing declaration the type
specifier appears in, and the type defined is not complete until after
the attribute specifiers.

All other attributes
....................

Otherwise, an attribute specifier appears as part of a declaration,
counting declarations of unnamed parameters and type names, and relates
to that declaration (which may be nested in another declaration, for
example in the case of a parameter declaration), or to a particular
declarator within a declaration.  Where an attribute specifier is
applied to a parameter declared as a function or an array, it should
apply to the function or array rather than the pointer to which the
parameter is implicitly converted, but this is not yet correctly
implemented.

 Any list of specifiers and qualifiers at the start of a declaration may
contain attribute specifiers, whether or not such a list may in that
context contain storage class specifiers.  (Some attributes, however,
are essentially in the nature of storage class specifiers, and only make
sense where storage class specifiers may be used; for example,
'section'.)  There is one necessary limitation to this syntax: the first
old-style parameter declaration in a function definition cannot begin
with an attribute specifier, because such an attribute applies to the
function instead by syntax described below (which, however, is not yet
implemented in this case).  In some other cases, attribute specifiers
are permitted by this grammar but not yet supported by the compiler.
All attribute specifiers in this place relate to the declaration as a
whole.  In the obsolescent usage where a type of 'int' is implied by the
absence of type specifiers, such a list of specifiers and qualifiers may
be an attribute specifier list with no other specifiers or qualifiers.

 At present, the first parameter in a function prototype must have some
type specifier that is not an attribute specifier; this resolves an
ambiguity in the interpretation of 'void f(int (__attribute__((foo))
x))', but is subject to change.  At present, if the parentheses of a
function declarator contain only attributes then those attributes are
ignored, rather than yielding an error or warning or implying a single
parameter of type int, but this is subject to change.

 An attribute specifier list may appear immediately before a declarator
(other than the first) in a comma-separated list of declarators in a
declaration of more than one identifier using a single list of
specifiers and qualifiers.  Such attribute specifiers apply only to the
identifier before whose declarator they appear.  For example, in

     __attribute__((noreturn)) void d0 (void),
         __attribute__((format(printf, 1, 2))) d1 (const char *, ...),
          d2 (void)

the 'noreturn' attribute applies to all the functions declared; the
'format' attribute only applies to 'd1'.

 An attribute specifier list may appear immediately before the comma,
'=' or semicolon terminating the declaration of an identifier other than
a function definition.  Such attribute specifiers apply to the declared
object or function.  Where an assembler name for an object or function
is specified (*note Asm Labels::), the attribute must follow the 'asm'
specification.

 An attribute specifier list may, in future, be permitted to appear
after the declarator in a function definition (before any old-style
parameter declarations or the function body).

 Attribute specifiers may be mixed with type qualifiers appearing inside
the '[]' of a parameter array declarator, in the C99 construct by which
such qualifiers are applied to the pointer to which the array is
implicitly converted.  Such attribute specifiers apply to the pointer,
not to the array, but at present this is not implemented and they are
ignored.

 An attribute specifier list may appear at the start of a nested
declarator.  At present, there are some limitations in this usage: the
attributes correctly apply to the declarator, but for most individual
attributes the semantics this implies are not implemented.  When
attribute specifiers follow the '*' of a pointer declarator, they may be
mixed with any type qualifiers present.  The following describes the
formal semantics of this syntax.  It makes the most sense if you are
familiar with the formal specification of declarators in the ISO C
standard.

 Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration 'T D1',
where 'T' contains declaration specifiers that specify a type TYPE (such
as 'int') and 'D1' is a declarator that contains an identifier IDENT.
The type specified for IDENT for derived declarators whose type does not
include an attribute specifier is as in the ISO C standard.

 If 'D1' has the form '( ATTRIBUTE-SPECIFIER-LIST D )', and the
declaration 'T D' specifies the type "DERIVED-DECLARATOR-TYPE-LIST TYPE"
for IDENT, then 'T D1' specifies the type "DERIVED-DECLARATOR-TYPE-LIST
ATTRIBUTE-SPECIFIER-LIST TYPE" for IDENT.

 If 'D1' has the form '* TYPE-QUALIFIER-AND-ATTRIBUTE-SPECIFIER-LIST D',
and the declaration 'T D' specifies the type
"DERIVED-DECLARATOR-TYPE-LIST TYPE" for IDENT, then 'T D1' specifies the
type "DERIVED-DECLARATOR-TYPE-LIST
TYPE-QUALIFIER-AND-ATTRIBUTE-SPECIFIER-LIST pointer to TYPE" for IDENT.

 For example,

     void (__attribute__((noreturn)) ****f) (void);

specifies the type "pointer to pointer to pointer to pointer to
non-returning function returning 'void'".  As another example,

     char *__attribute__((aligned(8))) *f;

specifies the type "pointer to 8-byte-aligned pointer to 'char'".  Note
again that this does not work with most attributes; for example, the
usage of 'aligned' and 'noreturn' attributes given above is not yet
supported.

 For compatibility with existing code written for compiler versions that
did not implement attributes on nested declarators, some laxity is
allowed in the placing of attributes.  If an attribute that only applies
to types is applied to a declaration, it is treated as applying to the
type of that declaration.  If an attribute that only applies to
declarations is applied to the type of a declaration, it is treated as
applying to that declaration; and, for compatibility with code placing
the attributes immediately before the identifier declared, such an
attribute applied to a function return type is treated as applying to
the function type, and such an attribute applied to an array element
type is treated as applying to the array type.  If an attribute that
only applies to function types is applied to a pointer-to-function type,
it is treated as applying to the pointer target type; if such an
attribute is applied to a function return type that is not a
pointer-to-function type, it is treated as applying to the function
type.


File: llvm.info,  Node: Function Prototypes,  Next: C++ Comments,  Prev: Attribute Syntax,  Up: C Extensions

6.34 Prototypes and Old-Style Function Definitions
==================================================

GNU C extends ISO C to allow a function prototype to override a later
old-style non-prototype definition.  Consider the following example:

     /* Use prototypes unless the compiler is old-fashioned.  */
     #ifdef __STDC__
     #define P(x) x
     #else
     #define P(x) ()
     #endif

     /* Prototype function declaration.  */
     int isroot P((uid_t));

     /* Old-style function definition.  */
     int
     isroot (x)   /* ??? lossage here ??? */
          uid_t x;
     {
       return x == 0;
     }

 Suppose the type 'uid_t' happens to be 'short'.  ISO C does not allow
this example, because subword arguments in old-style non-prototype
definitions are promoted.  Therefore in this example the function
definition's argument is really an 'int', which does not match the
prototype argument type of 'short'.

 This restriction of ISO C makes it hard to write code that is portable
to traditional C compilers, because the programmer does not know whether
the 'uid_t' type is 'short', 'int', or 'long'.  Therefore, in cases like
these GNU C allows a prototype to override a later old-style definition.
More precisely, in GNU C, a function prototype argument type overrides
the argument type specified by a later old-style definition if the
former type is the same as the latter type before promotion.  Thus in
GNU C the above example is equivalent to the following:

     int isroot (uid_t);

     int
     isroot (uid_t x)
     {
       return x == 0;
     }

GNU C++ does not support old-style function definitions, so this
extension is irrelevant.


File: llvm.info,  Node: C++ Comments,  Next: Dollar Signs,  Prev: Function Prototypes,  Up: C Extensions

6.35 C++ Style Comments
=======================

In GNU C, you may use C++ style comments, which start with '//' and
continue until the end of the line.  Many other C implementations allow
such comments, and they are included in the 1999 C standard.  However,
C++ style comments are not recognized if you specify an '-std' option
specifying a version of ISO C before C99, or '-ansi' (equivalent to
'-std=c90').


File: llvm.info,  Node: Dollar Signs,  Next: Character Escapes,  Prev: C++ Comments,  Up: C Extensions

6.36 Dollar Signs in Identifier Names
=====================================

In GNU C, you may normally use dollar signs in identifier names.  This
is because many traditional C implementations allow such identifiers.
However, dollar signs in identifiers are not supported on a few target
machines, typically because the target assembler does not allow them.


File: llvm.info,  Node: Character Escapes,  Next: Variable Attributes,  Prev: Dollar Signs,  Up: C Extensions

6.37 The Character <ESC> in Constants
=====================================

You can use the sequence '\e' in a string or character constant to stand
for the ASCII character <ESC>.


File: llvm.info,  Node: Variable Attributes,  Next: Type Attributes,  Prev: Character Escapes,  Up: C Extensions

6.38 Specifying Attributes of Variables
=======================================

The keyword '__attribute__' allows you to specify special attributes of
variables or structure fields.  This keyword is followed by an attribute
specification inside double parentheses.  Some attributes are currently
defined generically for variables.  Other attributes are defined for
variables on particular target systems.  Other attributes are available
for functions (*note Function Attributes::), labels (*note Label
Attributes::) and for types (*note Type Attributes::).  Other front ends
might define more attributes (*note Extensions to the C++ Language: C++
Extensions.).

 You may also specify attributes with '__' preceding and following each
keyword.  This allows you to use them in header files without being
concerned about a possible macro of the same name.  For example, you may
use '__aligned__' instead of 'aligned'.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

'aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment for the variable or
     structure field, measured in bytes.  For example, the declaration:

          int x __attribute__ ((aligned (16))) = 0;

     causes the compiler to allocate the global variable 'x' on a
     16-byte boundary.  On a 68040, this could be used in conjunction
     with an 'asm' expression to access the 'move16' instruction which
     requires 16-byte aligned operands.

     You can also specify the alignment of structure fields.  For
     example, to create a double-word aligned 'int' pair, you could
     write:

          struct foo { int x[2] __attribute__ ((aligned (8))); };

     This is an alternative to creating a union with a 'double' member,
     which forces the union to be double-word aligned.

     As in the preceding examples, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     variable or structure field.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a variable or
     field to the default alignment for the target architecture you are
     compiling for.  The default alignment is sufficient for all scalar
     types, but may not be enough for all vector types on a target that
     supports vector operations.  The default alignment is fixed for a
     particular target ABI.

     GCC also provides a target specific macro '__BIGGEST_ALIGNMENT__',
     which is the largest alignment ever used for any data type on the
     target machine you are compiling for.  For example, you could
     write:

          short array[3] __attribute__ ((aligned (__BIGGEST_ALIGNMENT__)));

     The compiler automatically sets the alignment for the declared
     variable or field to '__BIGGEST_ALIGNMENT__'.  Doing this can often
     make copy operations more efficient, because the compiler can use
     whatever instructions copy the biggest chunks of memory when
     performing copies to or from the variables or fields that you have
     aligned this way.  Note that the value of '__BIGGEST_ALIGNMENT__'
     may change depending on command-line options.

     When used on a struct, or struct member, the 'aligned' attribute
     can only increase the alignment; in order to decrease it, the
     'packed' attribute must be specified as well.  When used as part of
     a typedef, the 'aligned' attribute can both increase and decrease
     alignment, and specifying the 'packed' attribute generates a
     warning.

     Note that the effectiveness of 'aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8-byte alignment,
     then specifying 'aligned(16)' in an '__attribute__' still only
     provides you with 8-byte alignment.  See your linker documentation
     for further information.

     The 'aligned' attribute can also be used for functions (*note
     Function Attributes::.)

'cleanup (CLEANUP_FUNCTION)'
     The 'cleanup' attribute runs a function when the variable goes out
     of scope.  This attribute can only be applied to auto function
     scope variables; it may not be applied to parameters or variables
     with static storage duration.  The function must take one
     parameter, a pointer to a type compatible with the variable.  The
     return value of the function (if any) is ignored.

     If '-fexceptions' is enabled, then CLEANUP_FUNCTION is run during
     the stack unwinding that happens during the processing of the
     exception.  Note that the 'cleanup' attribute does not allow the
     exception to be caught, only to perform an action.  It is undefined
     what happens if CLEANUP_FUNCTION does not return normally.

'common'
'nocommon'
     The 'common' attribute requests GCC to place a variable in "common"
     storage.  The 'nocommon' attribute requests the opposite--to
     allocate space for it directly.

     These attributes override the default chosen by the '-fno-common'
     and '-fcommon' flags respectively.

'deprecated'
'deprecated (MSG)'
     The 'deprecated' attribute results in a warning if the variable is
     used anywhere in the source file.  This is useful when identifying
     variables that are expected to be removed in a future version of a
     program.  The warning also includes the location of the declaration
     of the deprecated variable, to enable users to easily find further
     information about why the variable is deprecated, or what they
     should do instead.  Note that the warning only occurs for uses:

          extern int old_var __attribute__ ((deprecated));
          extern int old_var;
          int new_fn () { return old_var; }

     results in a warning on line 3 but not line 2.  The optional MSG
     argument, which must be a string, is printed in the warning if
     present.

     The 'deprecated' attribute can also be used for functions and types
     (*note Function Attributes::, *note Type Attributes::.)

'mode (MODE)'
     This attribute specifies the data type for the
     declaration--whichever type corresponds to the mode MODE.  This in
     effect lets you request an integer or floating-point type according
     to its width.

     You may also specify a mode of 'byte' or '__byte__' to indicate the
     mode corresponding to a one-byte integer, 'word' or '__word__' for
     the mode of a one-word integer, and 'pointer' or '__pointer__' for
     the mode used to represent pointers.

'packed'
     The 'packed' attribute specifies that a variable or structure field
     should have the smallest possible alignment--one byte for a
     variable, and one bit for a field, unless you specify a larger
     value with the 'aligned' attribute.

     Here is a structure in which the field 'x' is packed, so that it
     immediately follows 'a':

          struct foo
          {
            char a;
            int x[2] __attribute__ ((packed));
          };

     _Note:_ The 4.1, 4.2 and 4.3 series of GCC ignore the 'packed'
     attribute on bit-fields of type 'char'.  This has been fixed in GCC
     4.4 but the change can lead to differences in the structure layout.
     See the documentation of '-Wpacked-bitfield-compat' for more
     information.

'section ("SECTION-NAME")'
     Normally, the compiler places the objects it generates in sections
     like 'data' and 'bss'.  Sometimes, however, you need additional
     sections, or you need certain particular variables to appear in
     special sections, for example to map to special hardware.  The
     'section' attribute specifies that a variable (or function) lives
     in a particular section.  For example, this small program uses
     several specific section names:

          struct duart a __attribute__ ((section ("DUART_A"))) = { 0 };
          struct duart b __attribute__ ((section ("DUART_B"))) = { 0 };
          char stack[10000] __attribute__ ((section ("STACK"))) = { 0 };
          int init_data __attribute__ ((section ("INITDATA")));

          main()
          {
            /* Initialize stack pointer */
            init_sp (stack + sizeof (stack));

            /* Initialize initialized data */
            memcpy (&init_data, &data, &edata - &data);

            /* Turn on the serial ports */
            init_duart (&a);
            init_duart (&b);
          }

     Use the 'section' attribute with _global_ variables and not _local_
     variables, as shown in the example.

     You may use the 'section' attribute with initialized or
     uninitialized global variables but the linker requires each object
     be defined once, with the exception that uninitialized variables
     tentatively go in the 'common' (or 'bss') section and can be
     multiply "defined".  Using the 'section' attribute changes what
     section the variable goes into and may cause the linker to issue an
     error if an uninitialized variable has multiple definitions.  You
     can force a variable to be initialized with the '-fno-common' flag
     or the 'nocommon' attribute.

     Some file formats do not support arbitrary sections so the
     'section' attribute is not available on all platforms.  If you need
     to map the entire contents of a module to a particular section,
     consider using the facilities of the linker instead.

'shared'
     On Microsoft Windows, in addition to putting variable definitions
     in a named section, the section can also be shared among all
     running copies of an executable or DLL.  For example, this small
     program defines shared data by putting it in a named section
     'shared' and marking the section shareable:

          int foo __attribute__((section ("shared"), shared)) = 0;

          int
          main()
          {
            /* Read and write foo.  All running
               copies see the same value.  */
            return 0;
          }

     You may only use the 'shared' attribute along with 'section'
     attribute with a fully-initialized global definition because of the
     way linkers work.  See 'section' attribute for more information.

     The 'shared' attribute is only available on Microsoft Windows.

'tls_model ("TLS_MODEL")'
     The 'tls_model' attribute sets thread-local storage model (*note
     Thread-Local::) of a particular '__thread' variable, overriding
     '-ftls-model=' command-line switch on a per-variable basis.  The
     TLS_MODEL argument should be one of 'global-dynamic',
     'local-dynamic', 'initial-exec' or 'local-exec'.

     Not all targets support this attribute.

'unused'
     This attribute, attached to a variable, means that the variable is
     meant to be possibly unused.  GCC does not produce a warning for
     this variable.

'used'
     This attribute, attached to a variable with the static storage,
     means that the variable must be emitted even if it appears that the
     variable is not referenced.

     When applied to a static data member of a C++ class template, the
     attribute also means that the member is instantiated if the class
     itself is instantiated.

'vector_size (BYTES)'
     This attribute specifies the vector size for the variable, measured
     in bytes.  For example, the declaration:

          int foo __attribute__ ((vector_size (16)));

     causes the compiler to set the mode for 'foo', to be 16 bytes,
     divided into 'int' sized units.  Assuming a 32-bit int (a vector of
     4 units of 4 bytes), the corresponding mode of 'foo' is V4SI.

     This attribute is only applicable to integral and float scalars,
     although arrays, pointers, and function return values are allowed
     in conjunction with this construct.

     Aggregates with this attribute are invalid, even if they are of the
     same size as a corresponding scalar.  For example, the declaration:

          struct S { int a; };
          struct S  __attribute__ ((vector_size (16))) foo;

     is invalid even if the size of the structure is the same as the
     size of the 'int'.

'selectany'
     The 'selectany' attribute causes an initialized global variable to
     have link-once semantics.  When multiple definitions of the
     variable are encountered by the linker, the first is selected and
     the remainder are discarded.  Following usage by the Microsoft
     compiler, the linker is told _not_ to warn about size or content
     differences of the multiple definitions.

     Although the primary usage of this attribute is for POD types, the
     attribute can also be applied to global C++ objects that are
     initialized by a constructor.  In this case, the static
     initialization and destruction code for the object is emitted in
     each translation defining the object, but the calls to the
     constructor and destructor are protected by a link-once guard
     variable.

     The 'selectany' attribute is only available on Microsoft Windows
     targets.  You can use '__declspec (selectany)' as a synonym for
     '__attribute__ ((selectany))' for compatibility with other
     compilers.

'weak'
     The 'weak' attribute is described in *note Function Attributes::.

'dllimport'
     The 'dllimport' attribute is described in *note Function
     Attributes::.

'dllexport'
     The 'dllexport' attribute is described in *note Function
     Attributes::.

6.38.1 AVR Variable Attributes
------------------------------

'progmem'
     The 'progmem' attribute is used on the AVR to place read-only data
     in the non-volatile program memory (flash).  The 'progmem'
     attribute accomplishes this by putting respective variables into a
     section whose name starts with '.progmem'.

     This attribute works similar to the 'section' attribute but adds
     additional checking.  Notice that just like the 'section'
     attribute, 'progmem' affects the location of the data but not how
     this data is accessed.

     In order to read data located with the 'progmem' attribute (inline)
     assembler must be used.
          /* Use custom macros from AVR-LibC (http://nongnu.org/avr-libc/user-manual/) */
          #include <avr/pgmspace.h>

          /* Locate var in flash memory */
          const int var[2] PROGMEM = { 1, 2 };

          int read_var (int i)
          {
              /* Access var[] by accessor macro from avr/pgmspace.h */
              return (int) pgm_read_word (& var[i]);
          }

     AVR is a Harvard architecture processor and data and read-only data
     normally resides in the data memory (RAM).

     See also the *note AVR Named Address Spaces:: section for an
     alternate way to locate and access data in flash memory.

'io'
'io (ADDR)'
     Variables with the 'io' attribute are used to address memory-mapped
     peripherals in the io address range.  If an address is specified,
     the variable is assigned that address, and the value is interpreted
     as an address in the data address space.  Example:

          volatile int porta __attribute__((io (0x22)));

     The address specified in the address in the data address range.

     Otherwise, the variable it is not assigned an address, but the
     compiler will still use in/out instructions where applicable,
     assuming some other module assigns an address in the io address
     range.  Example:

          extern volatile int porta __attribute__((io));

'io_low'
'io_low (ADDR)'
     This is like the 'io' attribute, but additionally it informs the
     compiler that the object lies in the lower half of the I/O area,
     allowing the use of 'cbi', 'sbi', 'sbic' and 'sbis' instructions.

'address'
'address (ADDR)'
     Variables with the 'address' attribute are used to address
     memory-mapped peripherals that may lie outside the io address
     range.

          volatile int porta __attribute__((address (0x600)));

6.38.2 Blackfin Variable Attributes
-----------------------------------

Three attributes are currently defined for the Blackfin.

'l1_data'
'l1_data_A'
'l1_data_B'
     Use these attributes on the Blackfin to place the variable into L1
     Data SRAM. Variables with 'l1_data' attribute are put into the
     specific section named '.l1.data'.  Those with 'l1_data_A'
     attribute are put into the specific section named '.l1.data.A'.
     Those with 'l1_data_B' attribute are put into the specific section
     named '.l1.data.B'.

'l2'
     Use this attribute on the Blackfin to place the variable into L2
     SRAM. Variables with 'l2' attribute are put into the specific
     section named '.l2.data'.

6.38.3 M32R/D Variable Attributes
---------------------------------

One attribute is currently defined for the M32R/D.

'model (MODEL-NAME)'
     Use this attribute on the M32R/D to set the addressability of an
     object.  The identifier MODEL-NAME is one of 'small', 'medium', or
     'large', representing each of the code models.

     Small model objects live in the lower 16MB of memory (so that their
     addresses can be loaded with the 'ld24' instruction).

     Medium and large model objects may live anywhere in the 32-bit
     address space (the compiler generates 'seth/add3' instructions to
     load their addresses).

6.38.4 MeP Variable Attributes
------------------------------

The MeP target has a number of addressing modes and busses.  The 'near'
space spans the standard memory space's first 16 megabytes (24 bits).
The 'far' space spans the entire 32-bit memory space.  The 'based' space
is a 128-byte region in the memory space that is addressed relative to
the '$tp' register.  The 'tiny' space is a 65536-byte region relative to
the '$gp' register.  In addition to these memory regions, the MeP target
has a separate 16-bit control bus which is specified with 'cb'
attributes.

'based'
     Any variable with the 'based' attribute is assigned to the '.based'
     section, and is accessed with relative to the '$tp' register.

'tiny'
     Likewise, the 'tiny' attribute assigned variables to the '.tiny'
     section, relative to the '$gp' register.

'near'
     Variables with the 'near' attribute are assumed to have addresses
     that fit in a 24-bit addressing mode.  This is the default for
     large variables ('-mtiny=4' is the default) but this attribute can
     override '-mtiny=' for small variables, or override '-ml'.

'far'
     Variables with the 'far' attribute are addressed using a full
     32-bit address.  Since this covers the entire memory space, this
     allows modules to make no assumptions about where variables might
     be stored.

'io'
'io (ADDR)'
     Variables with the 'io' attribute are used to address memory-mapped
     peripherals.  If an address is specified, the variable is assigned
     that address, else it is not assigned an address (it is assumed
     some other module assigns an address).  Example:

          int timer_count __attribute__((io(0x123)));

'cb'
'cb (ADDR)'
     Variables with the 'cb' attribute are used to access the control
     bus, using special instructions.  'addr' indicates the control bus
     address.  Example:

          int cpu_clock __attribute__((cb(0x123)));

6.38.5 PowerPC Variable Attributes
----------------------------------

Three attributes currently are defined for PowerPC configurations:
'altivec', 'ms_struct' and 'gcc_struct'.

 For full documentation of the struct attributes please see the
documentation in *note x86 Variable Attributes::.

 For documentation of 'altivec' attribute please see the documentation
in *note PowerPC Type Attributes::.

6.38.6 SPU Variable Attributes
------------------------------

The SPU supports the 'spu_vector' attribute for variables.  For
documentation of this attribute please see the documentation in *note
SPU Type Attributes::.

6.38.7 x86 Variable Attributes
------------------------------

Two attributes are currently defined for x86 configurations: 'ms_struct'
and 'gcc_struct'.

'ms_struct'
'gcc_struct'

     If 'packed' is used on a structure, or if bit-fields are used, it
     may be that the Microsoft ABI lays out the structure differently
     than the way GCC normally does.  Particularly when moving packed
     data between functions compiled with GCC and the native Microsoft
     compiler (either via function call or as data in a file), it may be
     necessary to access either format.

     Currently '-m[no-]ms-bitfields' is provided for the Microsoft
     Windows x86 compilers to match the native Microsoft compiler.

     The Microsoft structure layout algorithm is fairly simple with the
     exception of the bit-field packing.  The padding and alignment of
     members of structures and whether a bit-field can straddle a
     storage-unit boundary are determine by these rules:

       1. Structure members are stored sequentially in the order in
          which they are declared: the first member has the lowest
          memory address and the last member the highest.

       2. Every data object has an alignment requirement.  The alignment
          requirement for all data except structures, unions, and arrays
          is either the size of the object or the current packing size
          (specified with either the 'aligned' attribute or the 'pack'
          pragma), whichever is less.  For structures, unions, and
          arrays, the alignment requirement is the largest alignment
          requirement of its members.  Every object is allocated an
          offset so that:

               offset % alignment_requirement == 0

       3. Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte
          allocation unit if the integral types are the same size and if
          the next bit-field fits into the current allocation unit
          without crossing the boundary imposed by the common alignment
          requirements of the bit-fields.

     MSVC interprets zero-length bit-fields in the following ways:

       1. If a zero-length bit-field is inserted between two bit-fields
          that are normally coalesced, the bit-fields are not coalesced.

          For example:

               struct
                {
                  unsigned long bf_1 : 12;
                  unsigned long : 0;
                  unsigned long bf_2 : 12;
                } t1;

          The size of 't1' is 8 bytes with the zero-length bit-field.
          If the zero-length bit-field were removed, 't1''s size would
          be 4 bytes.

       2. If a zero-length bit-field is inserted after a bit-field,
          'foo', and the alignment of the zero-length bit-field is
          greater than the member that follows it, 'bar', 'bar' is
          aligned as the type of the zero-length bit-field.

          For example:

               struct
                {
                  char foo : 4;
                  short : 0;
                  char bar;
                } t2;

               struct
                {
                  char foo : 4;
                  short : 0;
                  double bar;
                } t3;

          For 't2', 'bar' is placed at offset 2, rather than offset 1.
          Accordingly, the size of 't2' is 4.  For 't3', the zero-length
          bit-field does not affect the alignment of 'bar' or, as a
          result, the size of the structure.

          Taking this into account, it is important to note the
          following:

            1. If a zero-length bit-field follows a normal bit-field,
               the type of the zero-length bit-field may affect the
               alignment of the structure as whole.  For example, 't2'
               has a size of 4 bytes, since the zero-length bit-field
               follows a normal bit-field, and is of type short.

            2. Even if a zero-length bit-field is not followed by a
               normal bit-field, it may still affect the alignment of
               the structure:

                    struct
                     {
                       char foo : 6;
                       long : 0;
                     } t4;

               Here, 't4' takes up 4 bytes.

       3. Zero-length bit-fields following non-bit-field members are
          ignored:

               struct
                {
                  char foo;
                  long : 0;
                  char bar;
                } t5;

          Here, 't5' takes up 2 bytes.

6.38.8 Xstormy16 Variable Attributes
------------------------------------

One attribute is currently defined for xstormy16 configurations:
'below100'.

'below100'

     If a variable has the 'below100' attribute ('BELOW100' is allowed
     also), GCC places the variable in the first 0x100 bytes of memory
     and use special opcodes to access it.  Such variables are placed in
     either the '.bss_below100' section or the '.data_below100' section.


File: llvm.info,  Node: Type Attributes,  Next: Alignment,  Prev: Variable Attributes,  Up: C Extensions

6.39 Specifying Attributes of Types
===================================

The keyword '__attribute__' allows you to specify special attributes of
'struct' and 'union' types when you define such types.  This keyword is
followed by an attribute specification inside double parentheses.  Eight
attributes are currently defined for types: 'aligned', 'packed',
'transparent_union', 'unused', 'deprecated', 'visibility', 'may_alias'
and 'bnd_variable_size'.  Other attributes are defined for functions
(*note Function Attributes::), labels (*note Label Attributes::) and for
variables (*note Variable Attributes::).

 You may also specify any one of these attributes with '__' preceding
and following its keyword.  This allows you to use these attributes in
header files without being concerned about a possible macro of the same
name.  For example, you may use '__aligned__' instead of 'aligned'.

 You may specify type attributes in an enum, struct or union type
declaration or definition, or for other types in a 'typedef'
declaration.

 For an enum, struct or union type, you may specify attributes either
between the enum, struct or union tag and the name of the type, or just
past the closing curly brace of the _definition_.  The former syntax is
preferred.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

'aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment (in bytes) for
     variables of the specified type.  For example, the declarations:

          struct S { short f[3]; } __attribute__ ((aligned (8)));
          typedef int more_aligned_int __attribute__ ((aligned (8)));

     force the compiler to ensure (as far as it can) that each variable
     whose type is 'struct S' or 'more_aligned_int' is allocated and
     aligned _at least_ on a 8-byte boundary.  On a SPARC, having all
     variables of type 'struct S' aligned to 8-byte boundaries allows
     the compiler to use the 'ldd' and 'std' (doubleword load and store)
     instructions when copying one variable of type 'struct S' to
     another, thus improving run-time efficiency.

     Note that the alignment of any given 'struct' or 'union' type is
     required by the ISO C standard to be at least a perfect multiple of
     the lowest common multiple of the alignments of all of the members
     of the 'struct' or 'union' in question.  This means that you _can_
     effectively adjust the alignment of a 'struct' or 'union' type by
     attaching an 'aligned' attribute to any one of the members of such
     a type, but the notation illustrated in the example above is a more
     obvious, intuitive, and readable way to request the compiler to
     adjust the alignment of an entire 'struct' or 'union' type.

     As in the preceding example, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     'struct' or 'union' type.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a type to the
     maximum useful alignment for the target machine you are compiling
     for.  For example, you could write:

          struct S { short f[3]; } __attribute__ ((aligned));

     Whenever you leave out the alignment factor in an 'aligned'
     attribute specification, the compiler automatically sets the
     alignment for the type to the largest alignment that is ever used
     for any data type on the target machine you are compiling for.
     Doing this can often make copy operations more efficient, because
     the compiler can use whatever instructions copy the biggest chunks
     of memory when performing copies to or from the variables that have
     types that you have aligned this way.

     In the example above, if the size of each 'short' is 2 bytes, then
     the size of the entire 'struct S' type is 6 bytes.  The smallest
     power of two that is greater than or equal to that is 8, so the
     compiler sets the alignment for the entire 'struct S' type to 8
     bytes.

     Note that although you can ask the compiler to select a
     time-efficient alignment for a given type and then declare only
     individual stand-alone objects of that type, the compiler's ability
     to select a time-efficient alignment is primarily useful only when
     you plan to create arrays of variables having the relevant
     (efficiently aligned) type.  If you declare or use arrays of
     variables of an efficiently-aligned type, then it is likely that
     your program also does pointer arithmetic (or subscripting, which
     amounts to the same thing) on pointers to the relevant type, and
     the code that the compiler generates for these pointer arithmetic
     operations is often more efficient for efficiently-aligned types
     than for other types.

     The 'aligned' attribute can only increase the alignment; but you
     can decrease it by specifying 'packed' as well.  See below.

     Note that the effectiveness of 'aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8-byte alignment,
     then specifying 'aligned(16)' in an '__attribute__' still only
     provides you with 8-byte alignment.  See your linker documentation
     for further information.

'packed'
     This attribute, attached to 'struct' or 'union' type definition,
     specifies that each member (other than zero-width bit-fields) of
     the structure or union is placed to minimize the memory required.
     When attached to an 'enum' definition, it indicates that the
     smallest integral type should be used.

     Specifying this attribute for 'struct' and 'union' types is
     equivalent to specifying the 'packed' attribute on each of the
     structure or union members.  Specifying the '-fshort-enums' flag on
     the line is equivalent to specifying the 'packed' attribute on all
     'enum' definitions.

     In the following example 'struct my_packed_struct''s members are
     packed closely together, but the internal layout of its 's' member
     is not packed--to do that, 'struct my_unpacked_struct' needs to be
     packed too.

          struct my_unpacked_struct
           {
              char c;
              int i;
           };

          struct __attribute__ ((__packed__)) my_packed_struct
            {
               char c;
               int  i;
               struct my_unpacked_struct s;
            };

     You may only specify this attribute on the definition of an 'enum',
     'struct' or 'union', not on a 'typedef' that does not also define
     the enumerated type, structure or union.

'transparent_union'

     This attribute, attached to a 'union' type definition, indicates
     that any function parameter having that union type causes calls to
     that function to be treated in a special way.

     First, the argument corresponding to a transparent union type can
     be of any type in the union; no cast is required.  Also, if the
     union contains a pointer type, the corresponding argument can be a
     null pointer constant or a void pointer expression; and if the
     union contains a void pointer type, the corresponding argument can
     be any pointer expression.  If the union member type is a pointer,
     qualifiers like 'const' on the referenced type must be respected,
     just as with normal pointer conversions.

     Second, the argument is passed to the function using the calling
     conventions of the first member of the transparent union, not the
     calling conventions of the union itself.  All members of the union
     must have the same machine representation; this is necessary for
     this argument passing to work properly.

     Transparent unions are designed for library functions that have
     multiple interfaces for compatibility reasons.  For example,
     suppose the 'wait' function must accept either a value of type 'int
     *' to comply with POSIX, or a value of type 'union wait *' to
     comply with the 4.1BSD interface.  If 'wait''s parameter were 'void
     *', 'wait' would accept both kinds of arguments, but it would also
     accept any other pointer type and this would make argument type
     checking less useful.  Instead, '<sys/wait.h>' might define the
     interface as follows:

          typedef union __attribute__ ((__transparent_union__))
            {
              int *__ip;
              union wait *__up;
            } wait_status_ptr_t;

          pid_t wait (wait_status_ptr_t);

     This interface allows either 'int *' or 'union wait *' arguments to
     be passed, using the 'int *' calling convention.  The program can
     call 'wait' with arguments of either type:

          int w1 () { int w; return wait (&w); }
          int w2 () { union wait w; return wait (&w); }

     With this interface, 'wait''s implementation might look like this:

          pid_t wait (wait_status_ptr_t p)
          {
            return waitpid (-1, p.__ip, 0);
          }

'unused'
     When attached to a type (including a 'union' or a 'struct'), this
     attribute means that variables of that type are meant to appear
     possibly unused.  GCC does not produce a warning for any variables
     of that type, even if the variable appears to do nothing.  This is
     often the case with lock or thread classes, which are usually
     defined and then not referenced, but contain constructors and
     destructors that have nontrivial bookkeeping functions.

'deprecated'
'deprecated (MSG)'
     The 'deprecated' attribute results in a warning if the type is used
     anywhere in the source file.  This is useful when identifying types
     that are expected to be removed in a future version of a program.
     If possible, the warning also includes the location of the
     declaration of the deprecated type, to enable users to easily find
     further information about why the type is deprecated, or what they
     should do instead.  Note that the warnings only occur for uses and
     then only if the type is being applied to an identifier that itself
     is not being declared as deprecated.

          typedef int T1 __attribute__ ((deprecated));
          T1 x;
          typedef T1 T2;
          T2 y;
          typedef T1 T3 __attribute__ ((deprecated));
          T3 z __attribute__ ((deprecated));

     results in a warning on line 2 and 3 but not lines 4, 5, or 6.  No
     warning is issued for line 4 because T2 is not explicitly
     deprecated.  Line 5 has no warning because T3 is explicitly
     deprecated.  Similarly for line 6.  The optional MSG argument,
     which must be a string, is printed in the warning if present.

     The 'deprecated' attribute can also be used for functions and
     variables (*note Function Attributes::, *note Variable
     Attributes::.)

'may_alias'
     Accesses through pointers to types with this attribute are not
     subject to type-based alias analysis, but are instead assumed to be
     able to alias any other type of objects.  In the context of section
     6.5 paragraph 7 of the C99 standard, an lvalue expression
     dereferencing such a pointer is treated like having a character
     type.  See '-fstrict-aliasing' for more information on aliasing
     issues.  This extension exists to support some vector APIs, in
     which pointers to one vector type are permitted to alias pointers
     to a different vector type.

     Note that an object of a type with this attribute does not have any
     special semantics.

     Example of use:

          typedef short __attribute__((__may_alias__)) short_a;

          int
          main (void)
          {
            int a = 0x12345678;
            short_a *b = (short_a *) &a;

            b[1] = 0;

            if (a == 0x12345678)
              abort();

            exit(0);
          }

     If you replaced 'short_a' with 'short' in the variable declaration,
     the above program would abort when compiled with
     '-fstrict-aliasing', which is on by default at '-O2' or above.

'visibility'
     In C++, attribute visibility (*note Function Attributes::) can also
     be applied to class, struct, union and enum types.  Unlike other
     type attributes, the attribute must appear between the initial
     keyword and the name of the type; it cannot appear after the body
     of the type.

     Note that the type visibility is applied to vague linkage entities
     associated with the class (vtable, typeinfo node, etc.).  In
     particular, if a class is thrown as an exception in one shared
     object and caught in another, the class must have default
     visibility.  Otherwise the two shared objects are unable to use the
     same typeinfo node and exception handling will break.

'designated_init'
     This attribute may only be applied to structure types.  It
     indicates that any initialization of an object of this type must
     use designated initializers rather than positional initializers.
     The intent of this attribute is to allow the programmer to indicate
     that a structure's layout may change, and that therefore relying on
     positional initialization will result in future breakage.

     GCC emits warnings based on this attribute by default; use
     '-Wno-designated-init' to suppress them.

'bnd_variable_size'
     When applied to a structure field, this attribute tells Pointer
     Bounds Checker that the size of this field should not be computed
     using static type information.  It may be used to mark variable
     sized static array fields placed at the end of a structure.

          struct S
          {
            int size;
            char data[1];
          }
          S *p = (S *)malloc (sizeof(S) + 100);
          p->data[10] = 0; //Bounds violation

     By using an attribute for a field we may avoid bound violation we
     most probably do not want to see:

          struct S
          {
            int size;
            char data[1] __attribute__((bnd_variable_size));
          }
          S *p = (S *)malloc (sizeof(S) + 100);
          p->data[10] = 0; //OK

 To specify multiple attributes, separate them by commas within the
double parentheses: for example, '__attribute__ ((aligned (16),
packed))'.

6.39.1 ARM Type Attributes
--------------------------

On those ARM targets that support 'dllimport' (such as Symbian OS), you
can use the 'notshared' attribute to indicate that the virtual table and
other similar data for a class should not be exported from a DLL.  For
example:

     class __declspec(notshared) C {
     public:
       __declspec(dllimport) C();
       virtual void f();
     }

     __declspec(dllexport)
     C::C() {}

In this code, 'C::C' is exported from the current DLL, but the virtual
table for 'C' is not exported.  (You can use '__attribute__' instead of
'__declspec' if you prefer, but most Symbian OS code uses '__declspec'.)

6.39.2 MeP Type Attributes
--------------------------

Many of the MeP variable attributes may be applied to types as well.
Specifically, the 'based', 'tiny', 'near', and 'far' attributes may be
applied to either.  The 'io' and 'cb' attributes may not be applied to
types.

6.39.3 PowerPC Type Attributes
------------------------------

Three attributes currently are defined for PowerPC configurations:
'altivec', 'ms_struct' and 'gcc_struct'.

 For full documentation of the 'ms_struct' and 'gcc_struct' attributes
please see the documentation in *note x86 Type Attributes::.

 The 'altivec' attribute allows one to declare AltiVec vector data types
supported by the AltiVec Programming Interface Manual.  The attribute
requires an argument to specify one of three vector types: 'vector__',
'pixel__' (always followed by unsigned short), and 'bool__' (always
followed by unsigned).

     __attribute__((altivec(vector__)))
     __attribute__((altivec(pixel__))) unsigned short
     __attribute__((altivec(bool__))) unsigned

 These attributes mainly are intended to support the '__vector',
'__pixel', and '__bool' AltiVec keywords.

6.39.4 SPU Type Attributes
--------------------------

The SPU supports the 'spu_vector' attribute for types.  This attribute
allows one to declare vector data types supported by the
Sony/Toshiba/IBM SPU Language Extensions Specification.  It is intended
to support the '__vector' keyword.

6.39.5 x86 Type Attributes
--------------------------

Two attributes are currently defined for x86 configurations: 'ms_struct'
and 'gcc_struct'.

'ms_struct'
'gcc_struct'

     If 'packed' is used on a structure, or if bit-fields are used it
     may be that the Microsoft ABI packs them differently than GCC
     normally packs them.  Particularly when moving packed data between
     functions compiled with GCC and the native Microsoft compiler
     (either via function call or as data in a file), it may be
     necessary to access either format.

     Currently '-m[no-]ms-bitfields' is provided for the Microsoft
     Windows x86 compilers to match the native Microsoft compiler.


File: llvm.info,  Node: Alignment,  Next: Inline,  Prev: Type Attributes,  Up: C Extensions

6.40 Inquiring on Alignment of Types or Variables
=================================================

The keyword '__alignof__' allows you to inquire about how an object is
aligned, or the minimum alignment usually required by a type.  Its
syntax is just like 'sizeof'.

 For example, if the target machine requires a 'double' value to be
aligned on an 8-byte boundary, then '__alignof__ (double)' is 8.  This
is true on many RISC machines.  On more traditional machine designs,
'__alignof__ (double)' is 4 or even 2.

 Some machines never actually require alignment; they allow reference to
any data type even at an odd address.  For these machines, '__alignof__'
reports the smallest alignment that GCC gives the data type, usually as
mandated by the target ABI.

 If the operand of '__alignof__' is an lvalue rather than a type, its
value is the required alignment for its type, taking into account any
minimum alignment specified with GCC's '__attribute__' extension (*note
Variable Attributes::).  For example, after this declaration:

     struct foo { int x; char y; } foo1;

the value of '__alignof__ (foo1.y)' is 1, even though its actual
alignment is probably 2 or 4, the same as '__alignof__ (int)'.

 It is an error to ask for the alignment of an incomplete type.


File: llvm.info,  Node: Inline,  Next: Volatiles,  Prev: Alignment,  Up: C Extensions

6.41 An Inline Function is As Fast As a Macro
=============================================

By declaring a function inline, you can direct GCC to make calls to that
function faster.  One way GCC can achieve this is to integrate that
function's code into the code for its callers.  This makes execution
faster by eliminating the function-call overhead; in addition, if any of
the actual argument values are constant, their known values may permit
simplifications at compile time so that not all of the inline function's
code needs to be included.  The effect on code size is less predictable;
object code may be larger or smaller with function inlining, depending
on the particular case.  You can also direct GCC to try to integrate all
"simple enough" functions into their callers with the option
'-finline-functions'.

 GCC implements three different semantics of declaring a function
inline.  One is available with '-std=gnu89' or '-fgnu89-inline' or when
'gnu_inline' attribute is present on all inline declarations, another
when '-std=c99', '-std=c11', '-std=gnu99' or '-std=gnu11' (without
'-fgnu89-inline'), and the third is used when compiling C++.

 To declare a function inline, use the 'inline' keyword in its
declaration, like this:

     static inline int
     inc (int *a)
     {
       return (*a)++;
     }

 If you are writing a header file to be included in ISO C90 programs,
write '__inline__' instead of 'inline'.  *Note Alternate Keywords::.

 The three types of inlining behave similarly in two important cases:
when the 'inline' keyword is used on a 'static' function, like the
example above, and when a function is first declared without using the
'inline' keyword and then is defined with 'inline', like this:

     extern int inc (int *a);
     inline int
     inc (int *a)
     {
       return (*a)++;
     }

 In both of these common cases, the program behaves the same as if you
had not used the 'inline' keyword, except for its speed.

 When a function is both inline and 'static', if all calls to the
function are integrated into the caller, and the function's address is
never used, then the function's own assembler code is never referenced.
In this case, GCC does not actually output assembler code for the
function, unless you specify the option '-fkeep-inline-functions'.  Some
calls cannot be integrated for various reasons (in particular, calls
that precede the function's definition cannot be integrated, and neither
can recursive calls within the definition).  If there is a nonintegrated
call, then the function is compiled to assembler code as usual.  The
function must also be compiled as usual if the program refers to its
address, because that can't be inlined.

 Note that certain usages in a function definition can make it
unsuitable for inline substitution.  Among these usages are: variadic
functions, use of 'alloca', use of variable-length data types (*note
Variable Length::), use of computed goto (*note Labels as Values::), use
of nonlocal goto, and nested functions (*note Nested Functions::).
Using '-Winline' warns when a function marked 'inline' could not be
substituted, and gives the reason for the failure.

 As required by ISO C++, GCC considers member functions defined within
the body of a class to be marked inline even if they are not explicitly
declared with the 'inline' keyword.  You can override this with
'-fno-default-inline'; *note Options Controlling C++ Dialect: C++
Dialect Options.

 GCC does not inline any functions when not optimizing unless you
specify the 'always_inline' attribute for the function, like this:

     /* Prototype.  */
     inline void foo (const char) __attribute__((always_inline));

 The remainder of this section is specific to GNU C90 inlining.

 When an inline function is not 'static', then the compiler must assume
that there may be calls from other source files; since a global symbol
can be defined only once in any program, the function must not be
defined in the other source files, so the calls therein cannot be
integrated.  Therefore, a non-'static' inline function is always
compiled on its own in the usual fashion.

 If you specify both 'inline' and 'extern' in the function definition,
then the definition is used only for inlining.  In no case is the
function compiled on its own, not even if you refer to its address
explicitly.  Such an address becomes an external reference, as if you
had only declared the function, and had not defined it.

 This combination of 'inline' and 'extern' has almost the effect of a
macro.  The way to use it is to put a function definition in a header
file with these keywords, and put another copy of the definition
(lacking 'inline' and 'extern') in a library file.  The definition in
the header file causes most calls to the function to be inlined.  If any
uses of the function remain, they refer to the single copy in the
library.


File: llvm.info,  Node: Volatiles,  Next: Using Assembly Language with C,  Prev: Inline,  Up: C Extensions

6.42 When is a Volatile Object Accessed?
========================================

C has the concept of volatile objects.  These are normally accessed by
pointers and used for accessing hardware or inter-thread communication.
The standard encourages compilers to refrain from optimizations
concerning accesses to volatile objects, but leaves it implementation
defined as to what constitutes a volatile access.  The minimum
requirement is that at a sequence point all previous accesses to
volatile objects have stabilized and no subsequent accesses have
occurred.  Thus an implementation is free to reorder and combine
volatile accesses that occur between sequence points, but cannot do so
for accesses across a sequence point.  The use of volatile does not
allow you to violate the restriction on updating objects multiple times
between two sequence points.

 Accesses to non-volatile objects are not ordered with respect to
volatile accesses.  You cannot use a volatile object as a memory barrier
to order a sequence of writes to non-volatile memory.  For instance:

     int *ptr = SOMETHING;
     volatile int vobj;
     *ptr = SOMETHING;
     vobj = 1;

Unless *PTR and VOBJ can be aliased, it is not guaranteed that the write
to *PTR occurs by the time the update of VOBJ happens.  If you need this
guarantee, you must use a stronger memory barrier such as:

     int *ptr = SOMETHING;
     volatile int vobj;
     *ptr = SOMETHING;
     asm volatile ("" : : : "memory");
     vobj = 1;

 A scalar volatile object is read when it is accessed in a void context:

     volatile int *src = SOMEVALUE;
     *src;

 Such expressions are rvalues, and GCC implements this as a read of the
volatile object being pointed to.

 Assignments are also expressions and have an rvalue.  However when
assigning to a scalar volatile, the volatile object is not reread,
regardless of whether the assignment expression's rvalue is used or not.
If the assignment's rvalue is used, the value is that assigned to the
volatile object.  For instance, there is no read of VOBJ in all the
following cases:

     int obj;
     volatile int vobj;
     vobj = SOMETHING;
     obj = vobj = SOMETHING;
     obj ? vobj = ONETHING : vobj = ANOTHERTHING;
     obj = (SOMETHING, vobj = ANOTHERTHING);

 If you need to read the volatile object after an assignment has
occurred, you must use a separate expression with an intervening
sequence point.

 As bit-fields are not individually addressable, volatile bit-fields may
be implicitly read when written to, or when adjacent bit-fields are
accessed.  Bit-field operations may be optimized such that adjacent
bit-fields are only partially accessed, if they straddle a storage unit
boundary.  For these reasons it is unwise to use volatile bit-fields to
access hardware.


File: llvm.info,  Node: Using Assembly Language with C,  Next: Alternate Keywords,  Prev: Volatiles,  Up: C Extensions

6.43 How to Use Inline Assembly Language in C Code
==================================================

The 'asm' keyword allows you to embed assembler instructions within C
code.  GCC provides two forms of inline 'asm' statements.  A "basic
'asm'" statement is one with no operands (*note Basic Asm::), while an
"extended 'asm'" statement (*note Extended Asm::) includes one or more
operands.  The extended form is preferred for mixing C and assembly
language within a function, but to include assembly language at top
level you must use basic 'asm'.

 You can also use the 'asm' keyword to override the assembler name for a
C symbol, or to place a C variable in a specific register.

* Menu:

* Basic Asm::          Inline assembler without operands.
* Extended Asm::       Inline assembler with operands.
* Constraints::        Constraints for 'asm' operands
* Asm Labels::         Specifying the assembler name to use for a C symbol.
* Explicit Reg Vars::  Defining variables residing in specified registers.
* Size of an asm::     How GCC calculates the size of an 'asm' block.


File: llvm.info,  Node: Basic Asm,  Next: Extended Asm,  Up: Using Assembly Language with C

6.43.1 Basic Asm -- Assembler Instructions Without Operands
-----------------------------------------------------------

A basic 'asm' statement has the following syntax:

     asm [ volatile ] ( ASSEMBLERINSTRUCTIONS )

 The 'asm' keyword is a GNU extension.  When writing code that can be
compiled with '-ansi' and the various '-std' options, use '__asm__'
instead of 'asm' (*note Alternate Keywords::).

Qualifiers
..........

'volatile'
     The optional 'volatile' qualifier has no effect.  All basic 'asm'
     blocks are implicitly volatile.

Parameters
..........

ASSEMBLERINSTRUCTIONS
     This is a literal string that specifies the assembler code.  The
     string can contain any instructions recognized by the assembler,
     including directives.  GCC does not parse the assembler
     instructions themselves and does not know what they mean or even
     whether they are valid assembler input.

     You may place multiple assembler instructions together in a single
     'asm' string, separated by the characters normally used in assembly
     code for the system.  A combination that works in most places is a
     newline to break the line, plus a tab character (written as
     '\n\t').  Some assemblers allow semicolons as a line separator.
     However, note that some assembler dialects use semicolons to start
     a comment.

Remarks
.......

Using extended 'asm' typically produces smaller, safer, and more
efficient code, and in most cases it is a better solution than basic
'asm'.  However, there are two situations where only basic 'asm' can be
used:

   * Extended 'asm' statements have to be inside a C function, so to
     write inline assembly language at file scope ("top-level"), outside
     of C functions, you must use basic 'asm'.  You can use this
     technique to emit assembler directives, define assembly language
     macros that can be invoked elsewhere in the file, or write entire
     functions in assembly language.

   * Functions declared with the 'naked' attribute also require basic
     'asm' (*note Function Attributes::).

 Safely accessing C data and calling functions from basic 'asm' is more
complex than it may appear.  To access C data, it is better to use
extended 'asm'.

 Do not expect a sequence of 'asm' statements to remain perfectly
consecutive after compilation.  If certain instructions need to remain
consecutive in the output, put them in a single multi-instruction 'asm'
statement.  Note that GCC's optimizers can move 'asm' statements
relative to other code, including across jumps.

 'asm' statements may not perform jumps into other 'asm' statements.
GCC does not know about these jumps, and therefore cannot take account
of them when deciding how to optimize.  Jumps from 'asm' to C labels are
only supported in extended 'asm'.

 Under certain circumstances, GCC may duplicate (or remove duplicates
of) your assembly code when optimizing.  This can lead to unexpected
duplicate symbol errors during compilation if your assembly code defines
symbols or labels.

 Since GCC does not parse the ASSEMBLERINSTRUCTIONS, it has no
visibility of any symbols it references.  This may result in GCC
discarding those symbols as unreferenced.

 The compiler copies the assembler instructions in a basic 'asm'
verbatim to the assembly language output file, without processing
dialects or any of the '%' operators that are available with extended
'asm'.  This results in minor differences between basic 'asm' strings
and extended 'asm' templates.  For example, to refer to registers you
might use '%eax' in basic 'asm' and '%%eax' in extended 'asm'.

 On targets such as x86 that support multiple assembler dialects, all
basic 'asm' blocks use the assembler dialect specified by the '-masm'
command-line option (*note x86 Options::).  Basic 'asm' provides no
mechanism to provide different assembler strings for different dialects.

 Here is an example of basic 'asm' for i386:

     /* Note that this code will not compile with -masm=intel */
     #define DebugBreak() asm("int $3")


File: llvm.info,  Node: Extended Asm,  Next: Constraints,  Prev: Basic Asm,  Up: Using Assembly Language with C

6.43.2 Extended Asm - Assembler Instructions with C Expression Operands
-----------------------------------------------------------------------

With extended 'asm' you can read and write C variables from assembler
and perform jumps from assembler code to C labels.  Extended 'asm'
syntax uses colons (':') to delimit the operand parameters after the
assembler template:

     asm [volatile] ( ASSEMBLERTEMPLATE
                      : OUTPUTOPERANDS
                      [ : INPUTOPERANDS
                      [ : CLOBBERS ] ])

     asm [volatile] goto ( ASSEMBLERTEMPLATE
                           :
                           : INPUTOPERANDS
                           : CLOBBERS
                           : GOTOLABELS)

 The 'asm' keyword is a GNU extension.  When writing code that can be
compiled with '-ansi' and the various '-std' options, use '__asm__'
instead of 'asm' (*note Alternate Keywords::).

Qualifiers
..........

'volatile'
     The typical use of extended 'asm' statements is to manipulate input
     values to produce output values.  However, your 'asm' statements
     may also produce side effects.  If so, you may need to use the
     'volatile' qualifier to disable certain optimizations.  *Note
     Volatile::.

'goto'
     This qualifier informs the compiler that the 'asm' statement may
     perform a jump to one of the labels listed in the GOTOLABELS.
     *Note GotoLabels::.

Parameters
..........

ASSEMBLERTEMPLATE
     This is a literal string that is the template for the assembler
     code.  It is a combination of fixed text and tokens that refer to
     the input, output, and goto parameters.  *Note AssemblerTemplate::.

OUTPUTOPERANDS
     A comma-separated list of the C variables modified by the
     instructions in the ASSEMBLERTEMPLATE.  An empty list is permitted.
     *Note OutputOperands::.

INPUTOPERANDS
     A comma-separated list of C expressions read by the instructions in
     the ASSEMBLERTEMPLATE.  An empty list is permitted.  *Note
     InputOperands::.

CLOBBERS
     A comma-separated list of registers or other values changed by the
     ASSEMBLERTEMPLATE, beyond those listed as outputs.  An empty list
     is permitted.  *Note Clobbers::.

GOTOLABELS
     When you are using the 'goto' form of 'asm', this section contains
     the list of all C labels to which the code in the ASSEMBLERTEMPLATE
     may jump.  *Note GotoLabels::.

     'asm' statements may not perform jumps into other 'asm' statements,
     only to the listed GOTOLABELS.  GCC's optimizers do not know about
     other jumps; therefore they cannot take account of them when
     deciding how to optimize.

 The total number of input + output + goto operands is limited to 30.

Remarks
.......

The 'asm' statement allows you to include assembly instructions directly
within C code.  This may help you to maximize performance in
time-sensitive code or to access assembly instructions that are not
readily available to C programs.

 Note that extended 'asm' statements must be inside a function.  Only
basic 'asm' may be outside functions (*note Basic Asm::).  Functions
declared with the 'naked' attribute also require basic 'asm' (*note
Function Attributes::).

 While the uses of 'asm' are many and varied, it may help to think of an
'asm' statement as a series of low-level instructions that convert input
parameters to output parameters.  So a simple (if not particularly
useful) example for i386 using 'asm' might look like this:

     int src = 1;
     int dst;

     asm ("mov %1, %0\n\t"
         "add $1, %0"
         : "=r" (dst)
         : "r" (src));

     printf("%d\n", dst);

 This code copies 'src' to 'dst' and add 1 to 'dst'.

6.43.2.1 Volatile
.................

GCC's optimizers sometimes discard 'asm' statements if they determine
there is no need for the output variables.  Also, the optimizers may
move code out of loops if they believe that the code will always return
the same result (i.e.  none of its input values change between calls).
Using the 'volatile' qualifier disables these optimizations.  'asm'
statements that have no output operands, including 'asm goto'
statements, are implicitly volatile.

 This i386 code demonstrates a case that does not use (or require) the
'volatile' qualifier.  If it is performing assertion checking, this code
uses 'asm' to perform the validation.  Otherwise, 'dwRes' is
unreferenced by any code.  As a result, the optimizers can discard the
'asm' statement, which in turn removes the need for the entire 'DoCheck'
routine.  By omitting the 'volatile' qualifier when it isn't needed you
allow the optimizers to produce the most efficient code possible.

     void DoCheck(uint32_t dwSomeValue)
     {
        uint32_t dwRes;

        // Assumes dwSomeValue is not zero.
        asm ("bsfl %1,%0"
          : "=r" (dwRes)
          : "r" (dwSomeValue)
          : "cc");

        assert(dwRes > 3);
     }

 The next example shows a case where the optimizers can recognize that
the input ('dwSomeValue') never changes during the execution of the
function and can therefore move the 'asm' outside the loop to produce
more efficient code.  Again, using 'volatile' disables this type of
optimization.

     void do_print(uint32_t dwSomeValue)
     {
        uint32_t dwRes;

        for (uint32_t x=0; x < 5; x++)
        {
           // Assumes dwSomeValue is not zero.
           asm ("bsfl %1,%0"
             : "=r" (dwRes)
             : "r" (dwSomeValue)
             : "cc");

           printf("%u: %u %u\n", x, dwSomeValue, dwRes);
        }
     }

 The following example demonstrates a case where you need to use the
'volatile' qualifier.  It uses the x86 'rdtsc' instruction, which reads
the computer's time-stamp counter.  Without the 'volatile' qualifier,
the optimizers might assume that the 'asm' block will always return the
same value and therefore optimize away the second call.

     uint64_t msr;

     asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
             "shl $32, %%rdx\n\t"  // Shift the upper bits left.
             "or %%rdx, %0"        // 'Or' in the lower bits.
             : "=a" (msr)
             :
             : "rdx");

     printf("msr: %llx\n", msr);

     // Do other work...

     // Reprint the timestamp
     asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
             "shl $32, %%rdx\n\t"  // Shift the upper bits left.
             "or %%rdx, %0"        // 'Or' in the lower bits.
             : "=a" (msr)
             :
             : "rdx");

     printf("msr: %llx\n", msr);

 GCC's optimizers do not treat this code like the non-volatile code in
the earlier examples.  They do not move it out of loops or omit it on
the assumption that the result from a previous call is still valid.

 Note that the compiler can move even volatile 'asm' instructions
relative to other code, including across jump instructions.  For
example, on many targets there is a system register that controls the
rounding mode of floating-point operations.  Setting it with a volatile
'asm', as in the following PowerPC example, does not work reliably.

     asm volatile("mtfsf 255, %0" : : "f" (fpenv));
     sum = x + y;

 The compiler may move the addition back before the volatile 'asm'.  To
make it work as expected, add an artificial dependency to the 'asm' by
referencing a variable in the subsequent code, for example:

     asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
     sum = x + y;

 Under certain circumstances, GCC may duplicate (or remove duplicates
of) your assembly code when optimizing.  This can lead to unexpected
duplicate symbol errors during compilation if your asm code defines
symbols or labels.  Using '%=' (*note AssemblerTemplate::) may help
resolve this problem.

6.43.2.2 Assembler Template
...........................

An assembler template is a literal string containing assembler
instructions.  The compiler replaces tokens in the template that refer
to inputs, outputs, and goto labels, and then outputs the resulting
string to the assembler.  The string can contain any instructions
recognized by the assembler, including directives.  GCC does not parse
the assembler instructions themselves and does not know what they mean
or even whether they are valid assembler input.  However, it does count
the statements (*note Size of an asm::).

 You may place multiple assembler instructions together in a single
'asm' string, separated by the characters normally used in assembly code
for the system.  A combination that works in most places is a newline to
break the line, plus a tab character to move to the instruction field
(written as '\n\t').  Some assemblers allow semicolons as a line
separator.  However, note that some assembler dialects use semicolons to
start a comment.

 Do not expect a sequence of 'asm' statements to remain perfectly
consecutive after compilation, even when you are using the 'volatile'
qualifier.  If certain instructions need to remain consecutive in the
output, put them in a single multi-instruction asm statement.

 Accessing data from C programs without using input/output operands
(such as by using global symbols directly from the assembler template)
may not work as expected.  Similarly, calling functions directly from an
assembler template requires a detailed understanding of the target
assembler and ABI.

 Since GCC does not parse the assembler template, it has no visibility
of any symbols it references.  This may result in GCC discarding those
symbols as unreferenced unless they are also listed as input, output, or
goto operands.

Special format strings
......................

In addition to the tokens described by the input, output, and goto
operands, these tokens have special meanings in the assembler template:

'%%'
     Outputs a single '%' into the assembler code.

'%='
     Outputs a number that is unique to each instance of the 'asm'
     statement in the entire compilation.  This option is useful when
     creating local labels and referring to them multiple times in a
     single template that generates multiple assembler instructions.

'%{'
'%|'
'%}'
     Outputs '{', '|', and '}' characters (respectively) into the
     assembler code.  When unescaped, these characters have special
     meaning to indicate multiple assembler dialects, as described
     below.

Multiple assembler dialects in 'asm' templates
..............................................

On targets such as x86, GCC supports multiple assembler dialects.  The
'-masm' option controls which dialect GCC uses as its default for inline
assembler.  The target-specific documentation for the '-masm' option
contains the list of supported dialects, as well as the default dialect
if the option is not specified.  This information may be important to
understand, since assembler code that works correctly when compiled
using one dialect will likely fail if compiled using another.  *Note x86
Options::.

 If your code needs to support multiple assembler dialects (for example,
if you are writing public headers that need to support a variety of
compilation options), use constructs of this form:

     { dialect0 | dialect1 | dialect2... }

 This construct outputs 'dialect0' when using dialect #0 to compile the
code, 'dialect1' for dialect #1, etc.  If there are fewer alternatives
within the braces than the number of dialects the compiler supports, the
construct outputs nothing.

 For example, if an x86 compiler supports two dialects ('att', 'intel'),
an assembler template such as this:

     "bt{l %[Offset],%[Base] | %[Base],%[Offset]}; jc %l2"

is equivalent to one of

     "btl %[Offset],%[Base] ; jc %l2"   /* att dialect */
     "bt %[Base],%[Offset]; jc %l2"     /* intel dialect */

 Using that same compiler, this code:

     "xchg{l}\t{%%}ebx, %1"

corresponds to either

     "xchgl\t%%ebx, %1"                 /* att dialect */
     "xchg\tebx, %1"                    /* intel dialect */

 There is no support for nesting dialect alternatives.

6.43.2.3 Output Operands
........................

An 'asm' statement has zero or more output operands indicating the names
of C variables modified by the assembler code.

 In this i386 example, 'old' (referred to in the template string as
'%0') and '*Base' (as '%1') are outputs and 'Offset' ('%2') is an input:

     bool old;

     __asm__ ("btsl %2,%1\n\t" // Turn on zero-based bit #Offset in Base.
              "sbb %0,%0"      // Use the CF to calculate old.
        : "=r" (old), "+rm" (*Base)
        : "Ir" (Offset)
        : "cc");

     return old;

 Operands are separated by commas.  Each operand has this format:

     [ [ASMSYMBOLICNAME] ] CONSTRAINT (CVARIABLENAME)

ASMSYMBOLICNAME
     Specifies a symbolic name for the operand.  Reference the name in
     the assembler template by enclosing it in square brackets (i.e.
     '%[Value]').  The scope of the name is the 'asm' statement that
     contains the definition.  Any valid C variable name is acceptable,
     including names already defined in the surrounding code.  No two
     operands within the same 'asm' statement can use the same symbolic
     name.

     When not using an ASMSYMBOLICNAME, use the (zero-based) position of
     the operand in the list of operands in the assembler template.  For
     example if there are three output operands, use '%0' in the
     template to refer to the first, '%1' for the second, and '%2' for
     the third.

CONSTRAINT
     A string constant specifying constraints on the placement of the
     operand; *Note Constraints::, for details.

     Output constraints must begin with either '=' (a variable
     overwriting an existing value) or '+' (when reading and writing).
     When using '=', do not assume the location contains the existing
     value on entry to the 'asm', except when the operand is tied to an
     input; *note Input Operands: InputOperands.

     After the prefix, there must be one or more additional constraints
     (*note Constraints::) that describe where the value resides.
     Common constraints include 'r' for register and 'm' for memory.
     When you list more than one possible location (for example,
     '"=rm"'), the compiler chooses the most efficient one based on the
     current context.  If you list as many alternates as the 'asm'
     statement allows, you permit the optimizers to produce the best
     possible code.  If you must use a specific register, but your
     Machine Constraints do not provide sufficient control to select the
     specific register you want, local register variables may provide a
     solution (*note Local Reg Vars::).

CVARIABLENAME
     Specifies a C lvalue expression to hold the output, typically a
     variable name.  The enclosing parentheses are a required part of
     the syntax.

 When the compiler selects the registers to use to represent the output
operands, it does not use any of the clobbered registers (*note
Clobbers::).

 Output operand expressions must be lvalues.  The compiler cannot check
whether the operands have data types that are reasonable for the
instruction being executed.  For output expressions that are not
directly addressable (for example a bit-field), the constraint must
allow a register.  In that case, GCC uses the register as the output of
the 'asm', and then stores that register into the output.

 Operands using the '+' constraint modifier count as two operands (that
is, both as input and output) towards the total maximum of 30 operands
per 'asm' statement.

 Use the '&' constraint modifier (*note Modifiers::) on all output
operands that must not overlap an input.  Otherwise, GCC may allocate
the output operand in the same register as an unrelated input operand,
on the assumption that the assembler code consumes its inputs before
producing outputs.  This assumption may be false if the assembler code
actually consists of more than one instruction.

 The same problem can occur if one output parameter (A) allows a
register constraint and another output parameter (B) allows a memory
constraint.  The code generated by GCC to access the memory address in B
can contain registers which _might_ be shared by A, and GCC considers
those registers to be inputs to the asm.  As above, GCC assumes that
such input registers are consumed before any outputs are written.  This
assumption may result in incorrect behavior if the asm writes to A
before using B.  Combining the '&' modifier with the register constraint
on A ensures that modifying A does not affect the address referenced by
B.  Otherwise, the location of B is undefined if A is modified before
using B.

 'asm' supports operand modifiers on operands (for example '%k2' instead
of simply '%2').  Typically these qualifiers are hardware dependent.
The list of supported modifiers for x86 is found at *note x86 Operand
modifiers: x86Operandmodifiers.

 If the C code that follows the 'asm' makes no use of any of the output
operands, use 'volatile' for the 'asm' statement to prevent the
optimizers from discarding the 'asm' statement as unneeded (see *note
Volatile::).

 This code makes no use of the optional ASMSYMBOLICNAME.  Therefore it
references the first output operand as '%0' (were there a second, it
would be '%1', etc).  The number of the first input operand is one
greater than that of the last output operand.  In this i386 example,
that makes 'Mask' referenced as '%1':

     uint32_t Mask = 1234;
     uint32_t Index;

       asm ("bsfl %1, %0"
          : "=r" (Index)
          : "r" (Mask)
          : "cc");

 That code overwrites the variable 'Index' ('='), placing the value in a
register ('r').  Using the generic 'r' constraint instead of a
constraint for a specific register allows the compiler to pick the
register to use, which can result in more efficient code.  This may not
be possible if an assembler instruction requires a specific register.

 The following i386 example uses the ASMSYMBOLICNAME syntax.  It
produces the same result as the code above, but some may consider it
more readable or more maintainable since reordering index numbers is not
necessary when adding or removing operands.  The names 'aIndex' and
'aMask' are only used in this example to emphasize which names get used
where.  It is acceptable to reuse the names 'Index' and 'Mask'.

     uint32_t Mask = 1234;
     uint32_t Index;

       asm ("bsfl %[aMask], %[aIndex]"
          : [aIndex] "=r" (Index)
          : [aMask] "r" (Mask)
          : "cc");

 Here are some more examples of output operands.

     uint32_t c = 1;
     uint32_t d;
     uint32_t *e = &c;

     asm ("mov %[e], %[d]"
        : [d] "=rm" (d)
        : [e] "rm" (*e));

 Here, 'd' may either be in a register or in memory.  Since the compiler
might already have the current value of the 'uint32_t' location pointed
to by 'e' in a register, you can enable it to choose the best location
for 'd' by specifying both constraints.

6.43.2.4 Input Operands
.......................

Input operands make values from C variables and expressions available to
the assembly code.

 Operands are separated by commas.  Each operand has this format:

     [ [ASMSYMBOLICNAME] ] CONSTRAINT (CEXPRESSION)

ASMSYMBOLICNAME
     Specifies a symbolic name for the operand.  Reference the name in
     the assembler template by enclosing it in square brackets (i.e.
     '%[Value]').  The scope of the name is the 'asm' statement that
     contains the definition.  Any valid C variable name is acceptable,
     including names already defined in the surrounding code.  No two
     operands within the same 'asm' statement can use the same symbolic
     name.

     When not using an ASMSYMBOLICNAME, use the (zero-based) position of
     the operand in the list of operands in the assembler template.  For
     example if there are two output operands and three inputs, use '%2'
     in the template to refer to the first input operand, '%3' for the
     second, and '%4' for the third.

CONSTRAINT
     A string constant specifying constraints on the placement of the
     operand; *Note Constraints::, for details.

     Input constraint strings may not begin with either '=' or '+'.
     When you list more than one possible location (for example,
     '"irm"'), the compiler chooses the most efficient one based on the
     current context.  If you must use a specific register, but your
     Machine Constraints do not provide sufficient control to select the
     specific register you want, local register variables may provide a
     solution (*note Local Reg Vars::).

     Input constraints can also be digits (for example, '"0"').  This
     indicates that the specified input must be in the same place as the
     output constraint at the (zero-based) index in the output
     constraint list.  When using ASMSYMBOLICNAME syntax for the output
     operands, you may use these names (enclosed in brackets '[]')
     instead of digits.

CEXPRESSION
     This is the C variable or expression being passed to the 'asm'
     statement as input.  The enclosing parentheses are a required part
     of the syntax.

 When the compiler selects the registers to use to represent the input
operands, it does not use any of the clobbered registers (*note
Clobbers::).

 If there are no output operands but there are input operands, place two
consecutive colons where the output operands would go:

     __asm__ ("some instructions"
        : /* No outputs. */
        : "r" (Offset / 8));

 *Warning:* Do _not_ modify the contents of input-only operands (except
for inputs tied to outputs).  The compiler assumes that on exit from the
'asm' statement these operands contain the same values as they had
before executing the statement.  It is _not_ possible to use clobbers to
inform the compiler that the values in these inputs are changing.  One
common work-around is to tie the changing input variable to an output
variable that never gets used.  Note, however, that if the code that
follows the 'asm' statement makes no use of any of the output operands,
the GCC optimizers may discard the 'asm' statement as unneeded (see
*note Volatile::).

 'asm' supports operand modifiers on operands (for example '%k2' instead
of simply '%2').  Typically these qualifiers are hardware dependent.
The list of supported modifiers for x86 is found at *note x86 Operand
modifiers: x86Operandmodifiers.

 In this example using the fictitious 'combine' instruction, the
constraint '"0"' for input operand 1 says that it must occupy the same
location as output operand 0.  Only input operands may use numbers in
constraints, and they must each refer to an output operand.  Only a
number (or the symbolic assembler name) in the constraint can guarantee
that one operand is in the same place as another.  The mere fact that
'foo' is the value of both operands is not enough to guarantee that they
are in the same place in the generated assembler code.

     asm ("combine %2, %0"
        : "=r" (foo)
        : "0" (foo), "g" (bar));

 Here is an example using symbolic names.

     asm ("cmoveq %1, %2, %[result]"
        : [result] "=r"(result)
        : "r" (test), "r" (new), "[result]" (old));

6.43.2.5 Clobbers
.................

While the compiler is aware of changes to entries listed in the output
operands, the inline 'asm' code may modify more than just the outputs.
For example, calculations may require additional registers, or the
processor may overwrite a register as a side effect of a particular
assembler instruction.  In order to inform the compiler of these
changes, list them in the clobber list.  Clobber list items are either
register names or the special clobbers (listed below).  Each clobber
list item is a string constant enclosed in double quotes and separated
by commas.

 Clobber descriptions may not in any way overlap with an input or output
operand.  For example, you may not have an operand describing a register
class with one member when listing that register in the clobber list.
Variables declared to live in specific registers (*note Explicit Reg
Vars::) and used as 'asm' input or output operands must have no part
mentioned in the clobber description.  In particular, there is no way to
specify that input operands get modified without also specifying them as
output operands.

 When the compiler selects which registers to use to represent input and
output operands, it does not use any of the clobbered registers.  As a
result, clobbered registers are available for any use in the assembler
code.

 Here is a realistic example for the VAX showing the use of clobbered
registers:

     asm volatile ("movc3 %0, %1, %2"
                        : /* No outputs. */
                        : "g" (from), "g" (to), "g" (count)
                        : "r0", "r1", "r2", "r3", "r4", "r5");

 Also, there are two special clobber arguments:

'"cc"'
     The '"cc"' clobber indicates that the assembler code modifies the
     flags register.  On some machines, GCC represents the condition
     codes as a specific hardware register; '"cc"' serves to name this
     register.  On other machines, condition code handling is different,
     and specifying '"cc"' has no effect.  But it is valid no matter
     what the target.

'"memory"'
     The '"memory"' clobber tells the compiler that the assembly code
     performs memory reads or writes to items other than those listed in
     the input and output operands (for example, accessing the memory
     pointed to by one of the input parameters).  To ensure memory
     contains correct values, GCC may need to flush specific register
     values to memory before executing the 'asm'.  Further, the compiler
     does not assume that any values read from memory before an 'asm'
     remain unchanged after that 'asm'; it reloads them as needed.
     Using the '"memory"' clobber effectively forms a read/write memory
     barrier for the compiler.

     Note that this clobber does not prevent the _processor_ from doing
     speculative reads past the 'asm' statement.  To prevent that, you
     need processor-specific fence instructions.

     Flushing registers to memory has performance implications and may
     be an issue for time-sensitive code.  You can use a trick to avoid
     this if the size of the memory being accessed is known at compile
     time.  For example, if accessing ten bytes of a string, use a
     memory input like:

     '{"m"( ({ struct { char x[10]; } *p = (void *)ptr ; *p; }) )}'.

6.43.2.6 Goto Labels
....................

'asm goto' allows assembly code to jump to one or more C labels.  The
GOTOLABELS section in an 'asm goto' statement contains a comma-separated
list of all C labels to which the assembler code may jump.  GCC assumes
that 'asm' execution falls through to the next statement (if this is not
the case, consider using the '__builtin_unreachable' intrinsic after the
'asm' statement).  Optimization of 'asm goto' may be improved by using
the 'hot' and 'cold' label attributes (*note Label Attributes::).

 An 'asm goto' statement cannot have outputs.  This is due to an
internal restriction of the compiler: control transfer instructions
cannot have outputs.  If the assembler code does modify anything, use
the '"memory"' clobber to force the optimizers to flush all register
values to memory and reload them if necessary after the 'asm' statement.

 Also note that an 'asm goto' statement is always implicitly considered
volatile.

 To reference a label in the assembler template, prefix it with '%l'
(lowercase 'L') followed by its (zero-based) position in GOTOLABELS plus
the number of input operands.  For example, if the 'asm' has three
inputs and references two labels, refer to the first label as '%l3' and
the second as '%l4').

 Alternately, you can reference labels using the actual C label name
enclosed in brackets.  For example, to reference a label named 'carry',
you can use '%l[carry]'.  The label must still be listed in the
GOTOLABELS section when using this approach.

 Here is an example of 'asm goto' for i386:

     asm goto (
         "btl %1, %0\n\t"
         "jc %l2"
         : /* No outputs. */
         : "r" (p1), "r" (p2)
         : "cc"
         : carry);

     return 0;

     carry:
     return 1;

 The following example shows an 'asm goto' that uses a memory clobber.

     int frob(int x)
     {
       int y;
       asm goto ("frob %%r5, %1; jc %l[error]; mov (%2), %%r5"
                 : /* No outputs. */
                 : "r"(x), "r"(&y)
                 : "r5", "memory"
                 : error);
       return y;
     error:
       return -1;
     }

6.43.2.7 x86 Operand Modifiers
..............................

References to input, output, and goto operands in the assembler template
of extended 'asm' statements can use modifiers to affect the way the
operands are formatted in the code output to the assembler.  For
example, the following code uses the 'h' and 'b' modifiers for x86:

     uint16_t  num;
     asm volatile ("xchg %h0, %b0" : "+a" (num) );

These modifiers generate this assembler code:

     xchg %ah, %al

 The rest of this discussion uses the following code for illustrative
purposes.

     int main()
     {
        int iInt = 1;

     top:

        asm volatile goto ("some assembler instructions here"
        : /* No outputs. */
        : "q" (iInt), "X" (sizeof(unsigned char) + 1)
        : /* No clobbers. */
        : top);
     }

 With no modifiers, this is what the output from the operands would be
for the 'att' and 'intel' dialects of assembler:

Operand   masm=att   masm=intel
---------------------------------------
'%0'      '%eax'     'eax'
'%1'      '$2'       '2'
'%2'      '$.L2'     'OFFSET
                     FLAT:.L2'

 The table below shows the list of supported modifiers and their
effects.

Modifier   Description                                  Operand   'masm=att' 'masm=intel'
------------------------------------------------------------------------------------------
'z'        Print the opcode suffix for the size of      '%z0'     'l'
           the current integer operand (one of
           'b'/'w'/'l'/'q').
'b'        Print the QImode name of the register.       '%b0'     '%al'      'al'
'h'        Print the QImode name for a "high"           '%h0'     '%ah'      'ah'
           register.
'w'        Print the HImode name of the register.       '%w0'     '%ax'      'ax'
'k'        Print the SImode name of the register.       '%k0'     '%eax'     'eax'
'q'        Print the DImode name of the register.       '%q0'     '%rax'     'rax'
'l'        Print the label name with no punctuation.    '%l2'     '.L2'      '.L2'
'c'        Require a constant operand and print the     '%c1'     '2'        '2'
           constant expression with no punctuation.

6.43.2.8 x86 Floating-Point 'asm' Operands
..........................................

On x86 targets, there are several rules on the usage of stack-like
registers in the operands of an 'asm'.  These rules apply only to the
operands that are stack-like registers:

  1. Given a set of input registers that die in an 'asm', it is
     necessary to know which are implicitly popped by the 'asm', and
     which must be explicitly popped by GCC.

     An input register that is implicitly popped by the 'asm' must be
     explicitly clobbered, unless it is constrained to match an output
     operand.

  2. For any input register that is implicitly popped by an 'asm', it is
     necessary to know how to adjust the stack to compensate for the
     pop.  If any non-popped input is closer to the top of the reg-stack
     than the implicitly popped register, it would not be possible to
     know what the stack looked like--it's not clear how the rest of the
     stack "slides up".

     All implicitly popped input registers must be closer to the top of
     the reg-stack than any input that is not implicitly popped.

     It is possible that if an input dies in an 'asm', the compiler
     might use the input register for an output reload.  Consider this
     example:

          asm ("foo" : "=t" (a) : "f" (b));

     This code says that input 'b' is not popped by the 'asm', and that
     the 'asm' pushes a result onto the reg-stack, i.e., the stack is
     one deeper after the 'asm' than it was before.  But, it is possible
     that reload may think that it can use the same register for both
     the input and the output.

     To prevent this from happening, if any input operand uses the 'f'
     constraint, all output register constraints must use the '&'
     early-clobber modifier.

     The example above is correctly written as:

          asm ("foo" : "=&t" (a) : "f" (b));

  3. Some operands need to be in particular places on the stack.  All
     output operands fall in this category--GCC has no other way to know
     which registers the outputs appear in unless you indicate this in
     the constraints.

     Output operands must specifically indicate which register an output
     appears in after an 'asm'.  '=f' is not allowed: the operand
     constraints must select a class with a single register.

  4. Output operands may not be "inserted" between existing stack
     registers.  Since no 387 opcode uses a read/write operand, all
     output operands are dead before the 'asm', and are pushed by the
     'asm'.  It makes no sense to push anywhere but the top of the
     reg-stack.

     Output operands must start at the top of the reg-stack: output
     operands may not "skip" a register.

  5. Some 'asm' statements may need extra stack space for internal
     calculations.  This can be guaranteed by clobbering stack registers
     unrelated to the inputs and outputs.

 This 'asm' takes one input, which is internally popped, and produces
two outputs.

     asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));

This 'asm' takes two inputs, which are popped by the 'fyl2xp1' opcode,
and replaces them with one output.  The 'st(1)' clobber is necessary for
the compiler to know that 'fyl2xp1' pops both inputs.

     asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");


File: llvm.info,  Node: Constraints,  Next: Asm Labels,  Prev: Extended Asm,  Up: Using Assembly Language with C

6.43.3 Constraints for 'asm' Operands
-------------------------------------

Here are specific details on what constraint letters you can use with
'asm' operands.  Constraints can say whether an operand may be in a
register, and which kinds of register; whether the operand can be a
memory reference, and which kinds of address; whether the operand may be
an immediate constant, and which possible values it may have.
Constraints can also require two operands to match.  Side-effects aren't
allowed in operands of inline 'asm', unless '<' or '>' constraints are
used, because there is no guarantee that the side-effects will happen
exactly once in an instruction that can update the addressing register.

* Menu:

* Simple Constraints::  Basic use of constraints.
* Multi-Alternative::   When an insn has two alternative constraint-patterns.
* Modifiers::           More precise control over effects of constraints.
* Machine Constraints:: Special constraints for some particular machines.


File: llvm.info,  Node: Simple Constraints,  Next: Multi-Alternative,  Up: Constraints

6.43.3.1 Simple Constraints
...........................

The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are the
letters that are allowed:

whitespace
     Whitespace characters are ignored and can be inserted at any
     position except the first.  This enables each alternative for
     different operands to be visually aligned in the machine
     description even if they have different number of constraints and
     modifiers.

'm'
     A memory operand is allowed, with any kind of address that the
     machine supports in general.  Note that the letter used for the
     general memory constraint can be re-defined by a back end using the
     'TARGET_MEM_CONSTRAINT' macro.

'o'
     A memory operand is allowed, but only if the address is
     "offsettable".  This means that adding a small integer (actually,
     the width in bytes of the operand, as determined by its machine
     mode) may be added to the address and the result is also a valid
     memory address.

     For example, an address which is constant is offsettable; so is an
     address that is the sum of a register and a constant (as long as a
     slightly larger constant is also within the range of
     address-offsets supported by the machine); but an autoincrement or
     autodecrement address is not offsettable.  More complicated
     indirect/indexed addresses may or may not be offsettable depending
     on the other addressing modes that the machine supports.

     Note that in an output operand which can be matched by another
     operand, the constraint letter 'o' is valid only when accompanied
     by both '<' (if the target machine has predecrement addressing) and
     '>' (if the target machine has preincrement addressing).

'V'
     A memory operand that is not offsettable.  In other words, anything
     that would fit the 'm' constraint but not the 'o' constraint.

'<'
     A memory operand with autodecrement addressing (either predecrement
     or postdecrement) is allowed.  In inline 'asm' this constraint is
     only allowed if the operand is used exactly once in an instruction
     that can handle the side-effects.  Not using an operand with '<' in
     constraint string in the inline 'asm' pattern at all or using it in
     multiple instructions isn't valid, because the side-effects
     wouldn't be performed or would be performed more than once.
     Furthermore, on some targets the operand with '<' in constraint
     string must be accompanied by special instruction suffixes like
     '%U0' instruction suffix on PowerPC or '%P0' on IA-64.

'>'
     A memory operand with autoincrement addressing (either preincrement
     or postincrement) is allowed.  In inline 'asm' the same
     restrictions as for '<' apply.

'r'
     A register operand is allowed provided that it is in a general
     register.

'i'
     An immediate integer operand (one with constant value) is allowed.
     This includes symbolic constants whose values will be known only at
     assembly time or later.

'n'
     An immediate integer operand with a known numeric value is allowed.
     Many systems cannot support assembly-time constants for operands
     less than a word wide.  Constraints for these operands should use
     'n' rather than 'i'.

'I', 'J', 'K', ... 'P'
     Other letters in the range 'I' through 'P' may be defined in a
     machine-dependent fashion to permit immediate integer operands with
     explicit integer values in specified ranges.  For example, on the
     68000, 'I' is defined to stand for the range of values 1 to 8.
     This is the range permitted as a shift count in the shift
     instructions.

'E'
     An immediate floating operand (expression code 'const_double') is
     allowed, but only if the target floating point format is the same
     as that of the host machine (on which the compiler is running).

'F'
     An immediate floating operand (expression code 'const_double' or
     'const_vector') is allowed.

'G', 'H'
     'G' and 'H' may be defined in a machine-dependent fashion to permit
     immediate floating operands in particular ranges of values.

's'
     An immediate integer operand whose value is not an explicit integer
     is allowed.

     This might appear strange; if an insn allows a constant operand
     with a value not known at compile time, it certainly must allow any
     known value.  So why use 's' instead of 'i'?  Sometimes it allows
     better code to be generated.

     For example, on the 68000 in a fullword instruction it is possible
     to use an immediate operand; but if the immediate value is between
     -128 and 127, better code results from loading the value into a
     register and using the register.  This is because the load into the
     register can be done with a 'moveq' instruction.  We arrange for
     this to happen by defining the letter 'K' to mean "any integer
     outside the range -128 to 127", and then specifying 'Ks' in the
     operand constraints.

'g'
     Any register, memory or immediate integer operand is allowed,
     except for registers that are not general registers.

'X'
     Any operand whatsoever is allowed.

'0', '1', '2', ... '9'
     An operand that matches the specified operand number is allowed.
     If a digit is used together with letters within the same
     alternative, the digit should come last.

     This number is allowed to be more than a single digit.  If multiple
     digits are encountered consecutively, they are interpreted as a
     single decimal integer.  There is scant chance for ambiguity, since
     to-date it has never been desirable that '10' be interpreted as
     matching either operand 1 _or_ operand 0.  Should this be desired,
     one can use multiple alternatives instead.

     This is called a "matching constraint" and what it really means is
     that the assembler has only a single operand that fills two roles
     which 'asm' distinguishes.  For example, an add instruction uses
     two input operands and an output operand, but on most CISC machines
     an add instruction really has only two operands, one of them an
     input-output operand:

          addl #35,r12

     Matching constraints are used in these circumstances.  More
     precisely, the two operands that match must include one input-only
     operand and one output-only operand.  Moreover, the digit must be a
     smaller number than the number of the operand that uses it in the
     constraint.

'p'
     An operand that is a valid memory address is allowed.  This is for
     "load address" and "push address" instructions.

     'p' in the constraint must be accompanied by 'address_operand' as
     the predicate in the 'match_operand'.  This predicate interprets
     the mode specified in the 'match_operand' as the mode of the memory
     reference for which the address would be valid.

OTHER-LETTERS
     Other letters can be defined in machine-dependent fashion to stand
     for particular classes of registers or other arbitrary operand
     types.  'd', 'a' and 'f' are defined on the 68000/68020 to stand
     for data, address and floating point registers.


File: llvm.info,  Node: Multi-Alternative,  Next: Modifiers,  Prev: Simple Constraints,  Up: Constraints

6.43.3.2 Multiple Alternative Constraints
.........................................

Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can
combine register or an immediate value into memory, or it can combine
any kind of operand into a register; but it cannot combine one memory
location into another.

 These constraints are represented as multiple alternatives.  An
alternative can be described by a series of letters for each operand.
The overall constraint for an operand is made from the letters for this
operand from the first alternative, a comma, the letters for this
operand from the second alternative, a comma, and so on until the last
alternative.

 If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many
instructions must be added to copy the operands so that that alternative
applies.  The alternative requiring the least copying is chosen.  If two
alternatives need the same amount of copying, the one that comes first
is chosen.  These choices can be altered with the '?' and '!'
characters:

'?'
     Disparage slightly the alternative that the '?' appears in, as a
     choice when no alternative applies exactly.  The compiler regards
     this alternative as one unit more costly for each '?' that appears
     in it.

'!'
     Disparage severely the alternative that the '!' appears in.  This
     alternative can still be used if it fits without reloading, but if
     reloading is needed, some other alternative will be used.

'^'
     This constraint is analogous to '?' but it disparages slightly the
     alternative only if the operand with the '^' needs a reload.

'$'
     This constraint is analogous to '!' but it disparages severely the
     alternative only if the operand with the '$' needs a reload.


File: llvm.info,  Node: Modifiers,  Next: Machine Constraints,  Prev: Multi-Alternative,  Up: Constraints

6.43.3.3 Constraint Modifier Characters
.......................................

Here are constraint modifier characters.

'='
     Means that this operand is written to by this instruction: the
     previous value is discarded and replaced by new data.

'+'
     Means that this operand is both read and written by the
     instruction.

     When the compiler fixes up the operands to satisfy the constraints,
     it needs to know which operands are read by the instruction and
     which are written by it.  '=' identifies an operand which is only
     written; '+' identifies an operand that is both read and written;
     all other operands are assumed to only be read.

     If you specify '=' or '+' in a constraint, you put it in the first
     character of the constraint string.

'&'
     Means (in a particular alternative) that this operand is an
     "earlyclobber" operand, which is written before the instruction is
     finished using the input operands.  Therefore, this operand may not
     lie in a register that is read by the instruction or as part of any
     memory address.

     '&' applies only to the alternative in which it is written.  In
     constraints with multiple alternatives, sometimes one alternative
     requires '&' while others do not.  See, for example, the 'movdf'
     insn of the 68000.

     A operand which is read by the instruction can be tied to an
     earlyclobber operand if its only use as an input occurs before the
     early result is written.  Adding alternatives of this form often
     allows GCC to produce better code when only some of the read
     operands can be affected by the earlyclobber.  See, for example,
     the 'mulsi3' insn of the ARM.

     Furthermore, if the "earlyclobber" operand is also a read/write
     operand, then that operand is written only after it's used.

     '&' does not obviate the need to write '=' or '+'.  As
     "earlyclobber" operands are always written, a read-only
     "earlyclobber" operand is ill-formed and will be rejected by the
     compiler.

'%'
     Declares the instruction to be commutative for this operand and the
     following operand.  This means that the compiler may interchange
     the two operands if that is the cheapest way to make all operands
     fit the constraints.  '%' applies to all alternatives and must
     appear as the first character in the constraint.  Only read-only
     operands can use '%'.

     GCC can only handle one commutative pair in an asm; if you use
     more, the compiler may fail.  Note that you need not use the
     modifier if the two alternatives are strictly identical; this would
     only waste time in the reload pass.  The modifier is not
     operational after register allocation, so the result of
     'define_peephole2' and 'define_split's performed after reload
     cannot rely on '%' to make the intended insn match.

'#'
     Says that all following characters, up to the next comma, are to be
     ignored as a constraint.  They are significant only for choosing
     register preferences.

'*'
     Says that the following character should be ignored when choosing
     register preferences.  '*' has no effect on the meaning of the
     constraint as a constraint, and no effect on reloading.  For LRA
     '*' additionally disparages slightly the alternative if the
     following character matches the operand.


File: llvm.info,  Node: Machine Constraints,  Prev: Modifiers,  Up: Constraints

6.43.3.4 Constraints for Particular Machines
............................................

Whenever possible, you should use the general-purpose constraint letters
in 'asm' arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters that
usually have very similar meanings across architectures.  The most
commonly used constraints are 'm' and 'r' (for memory and
general-purpose registers respectively; *note Simple Constraints::), and
'I', usually the letter indicating the most common immediate-constant
format.

 Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for 'asm' statements; therefore, some of the constraints are not
particularly useful for 'asm'.  Here is a summary of some of the
machine-dependent constraints available on some particular machines; it
includes both constraints that are useful for 'asm' and constraints that
aren't.  The compiler source file mentioned in the table heading for
each architecture is the definitive reference for the meanings of that
architecture's constraints.

_AArch64 family--'config/aarch64/constraints.md'_
     'k'
          The stack pointer register ('SP')

     'w'
          Floating point or SIMD vector register

     'I'
          Integer constant that is valid as an immediate operand in an
          'ADD' instruction

     'J'
          Integer constant that is valid as an immediate operand in a
          'SUB' instruction (once negated)

     'K'
          Integer constant that can be used with a 32-bit logical
          instruction

     'L'
          Integer constant that can be used with a 64-bit logical
          instruction

     'M'
          Integer constant that is valid as an immediate operand in a
          32-bit 'MOV' pseudo instruction.  The 'MOV' may be assembled
          to one of several different machine instructions depending on
          the value

     'N'
          Integer constant that is valid as an immediate operand in a
          64-bit 'MOV' pseudo instruction

     'S'
          An absolute symbolic address or a label reference

     'Y'
          Floating point constant zero

     'Z'
          Integer constant zero

     'Ush'
          The high part (bits 12 and upwards) of the pc-relative address
          of a symbol within 4GB of the instruction

     'Q'
          A memory address which uses a single base register with no
          offset

     'Ump'
          A memory address suitable for a load/store pair instruction in
          SI, DI, SF and DF modes

_ARC --'config/arc/constraints.md'_
     'q'
          Registers usable in ARCompact 16-bit instructions: 'r0'-'r3',
          'r12'-'r15'.  This constraint can only match when the '-mq'
          option is in effect.

     'e'
          Registers usable as base-regs of memory addresses in ARCompact
          16-bit memory instructions: 'r0'-'r3', 'r12'-'r15', 'sp'.
          This constraint can only match when the '-mq' option is in
          effect.
     'D'
          ARC FPX (dpfp) 64-bit registers.  'D0', 'D1'.

     'I'
          A signed 12-bit integer constant.

     'Cal'
          constant for arithmetic/logical operations.  This might be any
          constant that can be put into a long immediate by the assmbler
          or linker without involving a PIC relocation.

     'K'
          A 3-bit unsigned integer constant.

     'L'
          A 6-bit unsigned integer constant.

     'CnL'
          One's complement of a 6-bit unsigned integer constant.

     'CmL'
          Two's complement of a 6-bit unsigned integer constant.

     'M'
          A 5-bit unsigned integer constant.

     'O'
          A 7-bit unsigned integer constant.

     'P'
          A 8-bit unsigned integer constant.

     'H'
          Any const_double value.

_ARM family--'config/arm/constraints.md'_

     'h'
          In Thumb state, the core registers 'r8'-'r15'.

     'k'
          The stack pointer register.

     'l'
          In Thumb State the core registers 'r0'-'r7'.  In ARM state
          this is an alias for the 'r' constraint.

     't'
          VFP floating-point registers 's0'-'s31'.  Used for 32 bit
          values.

     'w'
          VFP floating-point registers 'd0'-'d31' and the appropriate
          subset 'd0'-'d15' based on command line options.  Used for 64
          bit values only.  Not valid for Thumb1.

     'y'
          The iWMMX co-processor registers.

     'z'
          The iWMMX GR registers.

     'G'
          The floating-point constant 0.0

     'I'
          Integer that is valid as an immediate operand in a data
          processing instruction.  That is, an integer in the range 0 to
          255 rotated by a multiple of 2

     'J'
          Integer in the range -4095 to 4095

     'K'
          Integer that satisfies constraint 'I' when inverted (ones
          complement)

     'L'
          Integer that satisfies constraint 'I' when negated (twos
          complement)

     'M'
          Integer in the range 0 to 32

     'Q'
          A memory reference where the exact address is in a single
          register (''m'' is preferable for 'asm' statements)

     'R'
          An item in the constant pool

     'S'
          A symbol in the text segment of the current file

     'Uv'
          A memory reference suitable for VFP load/store insns
          (reg+constant offset)

     'Uy'
          A memory reference suitable for iWMMXt load/store
          instructions.

     'Uq'
          A memory reference suitable for the ARMv4 ldrsb instruction.

_AVR family--'config/avr/constraints.md'_
     'l'
          Registers from r0 to r15

     'a'
          Registers from r16 to r23

     'd'
          Registers from r16 to r31

     'w'
          Registers from r24 to r31.  These registers can be used in
          'adiw' command

     'e'
          Pointer register (r26-r31)

     'b'
          Base pointer register (r28-r31)

     'q'
          Stack pointer register (SPH:SPL)

     't'
          Temporary register r0

     'x'
          Register pair X (r27:r26)

     'y'
          Register pair Y (r29:r28)

     'z'
          Register pair Z (r31:r30)

     'I'
          Constant greater than -1, less than 64

     'J'
          Constant greater than -64, less than 1

     'K'
          Constant integer 2

     'L'
          Constant integer 0

     'M'
          Constant that fits in 8 bits

     'N'
          Constant integer -1

     'O'
          Constant integer 8, 16, or 24

     'P'
          Constant integer 1

     'G'
          A floating point constant 0.0

     'Q'
          A memory address based on Y or Z pointer with displacement.

_Blackfin family--'config/bfin/constraints.md'_
     'a'
          P register

     'd'
          D register

     'z'
          A call clobbered P register.

     'qN'
          A single register.  If N is in the range 0 to 7, the
          corresponding D register.  If it is 'A', then the register P0.

     'D'
          Even-numbered D register

     'W'
          Odd-numbered D register

     'e'
          Accumulator register.

     'A'
          Even-numbered accumulator register.

     'B'
          Odd-numbered accumulator register.

     'b'
          I register

     'v'
          B register

     'f'
          M register

     'c'
          Registers used for circular buffering, i.e.  I, B, or L
          registers.

     'C'
          The CC register.

     't'
          LT0 or LT1.

     'k'
          LC0 or LC1.

     'u'
          LB0 or LB1.

     'x'
          Any D, P, B, M, I or L register.

     'y'
          Additional registers typically used only in prologues and
          epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and
          USP.

     'w'
          Any register except accumulators or CC.

     'Ksh'
          Signed 16 bit integer (in the range -32768 to 32767)

     'Kuh'
          Unsigned 16 bit integer (in the range 0 to 65535)

     'Ks7'
          Signed 7 bit integer (in the range -64 to 63)

     'Ku7'
          Unsigned 7 bit integer (in the range 0 to 127)

     'Ku5'
          Unsigned 5 bit integer (in the range 0 to 31)

     'Ks4'
          Signed 4 bit integer (in the range -8 to 7)

     'Ks3'
          Signed 3 bit integer (in the range -3 to 4)

     'Ku3'
          Unsigned 3 bit integer (in the range 0 to 7)

     'PN'
          Constant N, where N is a single-digit constant in the range 0
          to 4.

     'PA'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use with either accumulator.

     'PB'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use only with accumulator A1.

     'M1'
          Constant 255.

     'M2'
          Constant 65535.

     'J'
          An integer constant with exactly a single bit set.

     'L'
          An integer constant with all bits set except exactly one.

     'H'

     'Q'
          Any SYMBOL_REF.

_CR16 Architecture--'config/cr16/cr16.h'_

     'b'
          Registers from r0 to r14 (registers without stack pointer)

     't'
          Register from r0 to r11 (all 16-bit registers)

     'p'
          Register from r12 to r15 (all 32-bit registers)

     'I'
          Signed constant that fits in 4 bits

     'J'
          Signed constant that fits in 5 bits

     'K'
          Signed constant that fits in 6 bits

     'L'
          Unsigned constant that fits in 4 bits

     'M'
          Signed constant that fits in 32 bits

     'N'
          Check for 64 bits wide constants for add/sub instructions

     'G'
          Floating point constant that is legal for store immediate

_Epiphany--'config/epiphany/constraints.md'_
     'U16'
          An unsigned 16-bit constant.

     'K'
          An unsigned 5-bit constant.

     'L'
          A signed 11-bit constant.

     'Cm1'
          A signed 11-bit constant added to -1.  Can only match when the
          '-m1reg-REG' option is active.

     'Cl1'
          Left-shift of -1, i.e., a bit mask with a block of leading
          ones, the rest being a block of trailing zeroes.  Can only
          match when the '-m1reg-REG' option is active.

     'Cr1'
          Right-shift of -1, i.e., a bit mask with a trailing block of
          ones, the rest being zeroes.  Or to put it another way, one
          less than a power of two.  Can only match when the
          '-m1reg-REG' option is active.

     'Cal'
          Constant for arithmetic/logical operations.  This is like 'i',
          except that for position independent code, no symbols /
          expressions needing relocations are allowed.

     'Csy'
          Symbolic constant for call/jump instruction.

     'Rcs'
          The register class usable in short insns.  This is a register
          class constraint, and can thus drive register allocation.
          This constraint won't match unless '-mprefer-short-insn-regs'
          is in effect.

     'Rsc'
          The the register class of registers that can be used to hold a
          sibcall call address.  I.e., a caller-saved register.

     'Rct'
          Core control register class.

     'Rgs'
          The register group usable in short insns.  This constraint
          does not use a register class, so that it only passively
          matches suitable registers, and doesn't drive register
          allocation.

     'Rra'
          Matches the return address if it can be replaced with the link
          register.

     'Rcc'
          Matches the integer condition code register.

     'Sra'
          Matches the return address if it is in a stack slot.

     'Cfm'
          Matches control register values to switch fp mode, which are
          encapsulated in 'UNSPEC_FP_MODE'.

_FRV--'config/frv/frv.h'_
     'a'
          Register in the class 'ACC_REGS' ('acc0' to 'acc7').

     'b'
          Register in the class 'EVEN_ACC_REGS' ('acc0' to 'acc7').

     'c'
          Register in the class 'CC_REGS' ('fcc0' to 'fcc3' and 'icc0'
          to 'icc3').

     'd'
          Register in the class 'GPR_REGS' ('gr0' to 'gr63').

     'e'
          Register in the class 'EVEN_REGS' ('gr0' to 'gr63').  Odd
          registers are excluded not in the class but through the use of
          a machine mode larger than 4 bytes.

     'f'
          Register in the class 'FPR_REGS' ('fr0' to 'fr63').

     'h'
          Register in the class 'FEVEN_REGS' ('fr0' to 'fr63').  Odd
          registers are excluded not in the class but through the use of
          a machine mode larger than 4 bytes.

     'l'
          Register in the class 'LR_REG' (the 'lr' register).

     'q'
          Register in the class 'QUAD_REGS' ('gr2' to 'gr63').  Register
          numbers not divisible by 4 are excluded not in the class but
          through the use of a machine mode larger than 8 bytes.

     't'
          Register in the class 'ICC_REGS' ('icc0' to 'icc3').

     'u'
          Register in the class 'FCC_REGS' ('fcc0' to 'fcc3').

     'v'
          Register in the class 'ICR_REGS' ('cc4' to 'cc7').

     'w'
          Register in the class 'FCR_REGS' ('cc0' to 'cc3').

     'x'
          Register in the class 'QUAD_FPR_REGS' ('fr0' to 'fr63').
          Register numbers not divisible by 4 are excluded not in the
          class but through the use of a machine mode larger than 8
          bytes.

     'z'
          Register in the class 'SPR_REGS' ('lcr' and 'lr').

     'A'
          Register in the class 'QUAD_ACC_REGS' ('acc0' to 'acc7').

     'B'
          Register in the class 'ACCG_REGS' ('accg0' to 'accg7').

     'C'
          Register in the class 'CR_REGS' ('cc0' to 'cc7').

     'G'
          Floating point constant zero

     'I'
          6-bit signed integer constant

     'J'
          10-bit signed integer constant

     'L'
          16-bit signed integer constant

     'M'
          16-bit unsigned integer constant

     'N'
          12-bit signed integer constant that is negative--i.e. in the
          range of -2048 to -1

     'O'
          Constant zero

     'P'
          12-bit signed integer constant that is greater than zero--i.e.
          in the range of 1 to 2047.

_Hewlett-Packard PA-RISC--'config/pa/pa.h'_
     'a'
          General register 1

     'f'
          Floating point register

     'q'
          Shift amount register

     'x'
          Floating point register (deprecated)

     'y'
          Upper floating point register (32-bit), floating point
          register (64-bit)

     'Z'
          Any register

     'I'
          Signed 11-bit integer constant

     'J'
          Signed 14-bit integer constant

     'K'
          Integer constant that can be deposited with a 'zdepi'
          instruction

     'L'
          Signed 5-bit integer constant

     'M'
          Integer constant 0

     'N'
          Integer constant that can be loaded with a 'ldil' instruction

     'O'
          Integer constant whose value plus one is a power of 2

     'P'
          Integer constant that can be used for 'and' operations in
          'depi' and 'extru' instructions

     'S'
          Integer constant 31

     'U'
          Integer constant 63

     'G'
          Floating-point constant 0.0

     'A'
          A 'lo_sum' data-linkage-table memory operand

     'Q'
          A memory operand that can be used as the destination operand
          of an integer store instruction

     'R'
          A scaled or unscaled indexed memory operand

     'T'
          A memory operand for floating-point loads and stores

     'W'
          A register indirect memory operand

_Intel IA-64--'config/ia64/ia64.h'_
     'a'
          General register 'r0' to 'r3' for 'addl' instruction

     'b'
          Branch register

     'c'
          Predicate register ('c' as in "conditional")

     'd'
          Application register residing in M-unit

     'e'
          Application register residing in I-unit

     'f'
          Floating-point register

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement and postdecrement which require
          printing with '%Pn' on IA-64.

     'G'
          Floating-point constant 0.0 or 1.0

     'I'
          14-bit signed integer constant

     'J'
          22-bit signed integer constant

     'K'
          8-bit signed integer constant for logical instructions

     'L'
          8-bit adjusted signed integer constant for compare pseudo-ops

     'M'
          6-bit unsigned integer constant for shift counts

     'N'
          9-bit signed integer constant for load and store
          postincrements

     'O'
          The constant zero

     'P'
          0 or -1 for 'dep' instruction

     'Q'
          Non-volatile memory for floating-point loads and stores

     'R'
          Integer constant in the range 1 to 4 for 'shladd' instruction

     'S'
          Memory operand except postincrement and postdecrement.  This
          is now roughly the same as 'm' when not used together with '<'
          or '>'.

_M32C--'config/m32c/m32c.c'_
     'Rsp'
     'Rfb'
     'Rsb'
          '$sp', '$fb', '$sb'.

     'Rcr'
          Any control register, when they're 16 bits wide (nothing if
          control registers are 24 bits wide)

     'Rcl'
          Any control register, when they're 24 bits wide.

     'R0w'
     'R1w'
     'R2w'
     'R3w'
          $r0, $r1, $r2, $r3.

     'R02'
          $r0 or $r2, or $r2r0 for 32 bit values.

     'R13'
          $r1 or $r3, or $r3r1 for 32 bit values.

     'Rdi'
          A register that can hold a 64 bit value.

     'Rhl'
          $r0 or $r1 (registers with addressable high/low bytes)

     'R23'
          $r2 or $r3

     'Raa'
          Address registers

     'Raw'
          Address registers when they're 16 bits wide.

     'Ral'
          Address registers when they're 24 bits wide.

     'Rqi'
          Registers that can hold QI values.

     'Rad'
          Registers that can be used with displacements ($a0, $a1, $sb).

     'Rsi'
          Registers that can hold 32 bit values.

     'Rhi'
          Registers that can hold 16 bit values.

     'Rhc'
          Registers chat can hold 16 bit values, including all control
          registers.

     'Rra'
          $r0 through R1, plus $a0 and $a1.

     'Rfl'
          The flags register.

     'Rmm'
          The memory-based pseudo-registers $mem0 through $mem15.

     'Rpi'
          Registers that can hold pointers (16 bit registers for r8c,
          m16c; 24 bit registers for m32cm, m32c).

     'Rpa'
          Matches multiple registers in a PARALLEL to form a larger
          register.  Used to match function return values.

     'Is3'
          -8 ... 7

     'IS1'
          -128 ... 127

     'IS2'
          -32768 ... 32767

     'IU2'
          0 ... 65535

     'In4'
          -8 ... -1 or 1 ... 8

     'In5'
          -16 ... -1 or 1 ... 16

     'In6'
          -32 ... -1 or 1 ... 32

     'IM2'
          -65536 ... -1

     'Ilb'
          An 8 bit value with exactly one bit set.

     'Ilw'
          A 16 bit value with exactly one bit set.

     'Sd'
          The common src/dest memory addressing modes.

     'Sa'
          Memory addressed using $a0 or $a1.

     'Si'
          Memory addressed with immediate addresses.

     'Ss'
          Memory addressed using the stack pointer ($sp).

     'Sf'
          Memory addressed using the frame base register ($fb).

     'Ss'
          Memory addressed using the small base register ($sb).

     'S1'
          $r1h

_MeP--'config/mep/constraints.md'_

     'a'
          The $sp register.

     'b'
          The $tp register.

     'c'
          Any control register.

     'd'
          Either the $hi or the $lo register.

     'em'
          Coprocessor registers that can be directly loaded ($c0-$c15).

     'ex'
          Coprocessor registers that can be moved to each other.

     'er'
          Coprocessor registers that can be moved to core registers.

     'h'
          The $hi register.

     'j'
          The $rpc register.

     'l'
          The $lo register.

     't'
          Registers which can be used in $tp-relative addressing.

     'v'
          The $gp register.

     'x'
          The coprocessor registers.

     'y'
          The coprocessor control registers.

     'z'
          The $0 register.

     'A'
          User-defined register set A.

     'B'
          User-defined register set B.

     'C'
          User-defined register set C.

     'D'
          User-defined register set D.

     'I'
          Offsets for $gp-rel addressing.

     'J'
          Constants that can be used directly with boolean insns.

     'K'
          Constants that can be moved directly to registers.

     'L'
          Small constants that can be added to registers.

     'M'
          Long shift counts.

     'N'
          Small constants that can be compared to registers.

     'O'
          Constants that can be loaded into the top half of registers.

     'S'
          Signed 8-bit immediates.

     'T'
          Symbols encoded for $tp-rel or $gp-rel addressing.

     'U'
          Non-constant addresses for loading/saving coprocessor
          registers.

     'W'
          The top half of a symbol's value.

     'Y'
          A register indirect address without offset.

     'Z'
          Symbolic references to the control bus.

_MicroBlaze--'config/microblaze/constraints.md'_
     'd'
          A general register ('r0' to 'r31').

     'z'
          A status register ('rmsr', '$fcc1' to '$fcc7').

_MIPS--'config/mips/constraints.md'_
     'd'
          An address register.  This is equivalent to 'r' unless
          generating MIPS16 code.

     'f'
          A floating-point register (if available).

     'h'
          Formerly the 'hi' register.  This constraint is no longer
          supported.

     'l'
          The 'lo' register.  Use this register to store values that are
          no bigger than a word.

     'x'
          The concatenated 'hi' and 'lo' registers.  Use this register
          to store doubleword values.

     'c'
          A register suitable for use in an indirect jump.  This will
          always be '$25' for '-mabicalls'.

     'v'
          Register '$3'.  Do not use this constraint in new code; it is
          retained only for compatibility with glibc.

     'y'
          Equivalent to 'r'; retained for backwards compatibility.

     'z'
          A floating-point condition code register.

     'I'
          A signed 16-bit constant (for arithmetic instructions).

     'J'
          Integer zero.

     'K'
          An unsigned 16-bit constant (for logic instructions).

     'L'
          A signed 32-bit constant in which the lower 16 bits are zero.
          Such constants can be loaded using 'lui'.

     'M'
          A constant that cannot be loaded using 'lui', 'addiu' or
          'ori'.

     'N'
          A constant in the range -65535 to -1 (inclusive).

     'O'
          A signed 15-bit constant.

     'P'
          A constant in the range 1 to 65535 (inclusive).

     'G'
          Floating-point zero.

     'R'
          An address that can be used in a non-macro load or store.

     'ZC'
          A memory operand whose address is formed by a base register
          and offset that is suitable for use in instructions with the
          same addressing mode as 'll' and 'sc'.

     'ZD'
          An address suitable for a 'prefetch' instruction, or for any
          other instruction with the same addressing mode as 'prefetch'.

_Motorola 680x0--'config/m68k/constraints.md'_
     'a'
          Address register

     'd'
          Data register

     'f'
          68881 floating-point register, if available

     'I'
          Integer in the range 1 to 8

     'J'
          16-bit signed number

     'K'
          Signed number whose magnitude is greater than 0x80

     'L'
          Integer in the range -8 to -1

     'M'
          Signed number whose magnitude is greater than 0x100

     'N'
          Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate

     'O'
          16 (for rotate using swap)

     'P'
          Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate

     'R'
          Numbers that mov3q can handle

     'G'
          Floating point constant that is not a 68881 constant

     'S'
          Operands that satisfy 'm' when -mpcrel is in effect

     'T'
          Operands that satisfy 's' when -mpcrel is not in effect

     'Q'
          Address register indirect addressing mode

     'U'
          Register offset addressing

     'W'
          const_call_operand

     'Cs'
          symbol_ref or const

     'Ci'
          const_int

     'C0'
          const_int 0

     'Cj'
          Range of signed numbers that don't fit in 16 bits

     'Cmvq'
          Integers valid for mvq

     'Capsw'
          Integers valid for a moveq followed by a swap

     'Cmvz'
          Integers valid for mvz

     'Cmvs'
          Integers valid for mvs

     'Ap'
          push_operand

     'Ac'
          Non-register operands allowed in clr

_Moxie--'config/moxie/constraints.md'_
     'A'
          An absolute address

     'B'
          An offset address

     'W'
          A register indirect memory operand

     'I'
          A constant in the range of 0 to 255.

     'N'
          A constant in the range of 0 to -255.

_MSP430-'config/msp430/constraints.md'_

     'R12'
          Register R12.

     'R13'
          Register R13.

     'K'
          Integer constant 1.

     'L'
          Integer constant -1^20..1^19.

     'M'
          Integer constant 1-4.

     'Ya'
          Memory references which do not require an extended MOVX
          instruction.

     'Yl'
          Memory reference, labels only.

     'Ys'
          Memory reference, stack only.

_NDS32--'config/nds32/constraints.md'_
     'w'
          LOW register class $r0 to $r7 constraint for V3/V3M ISA.
     'l'
          LOW register class $r0 to $r7.
     'd'
          MIDDLE register class $r0 to $r11, $r16 to $r19.
     'h'
          HIGH register class $r12 to $r14, $r20 to $r31.
     't'
          Temporary assist register $ta (i.e. $r15).
     'k'
          Stack register $sp.
     'Iu03'
          Unsigned immediate 3-bit value.
     'In03'
          Negative immediate 3-bit value in the range of -7-0.
     'Iu04'
          Unsigned immediate 4-bit value.
     'Is05'
          Signed immediate 5-bit value.
     'Iu05'
          Unsigned immediate 5-bit value.
     'In05'
          Negative immediate 5-bit value in the range of -31-0.
     'Ip05'
          Unsigned immediate 5-bit value for movpi45 instruction with
          range 16-47.
     'Iu06'
          Unsigned immediate 6-bit value constraint for addri36.sp
          instruction.
     'Iu08'
          Unsigned immediate 8-bit value.
     'Iu09'
          Unsigned immediate 9-bit value.
     'Is10'
          Signed immediate 10-bit value.
     'Is11'
          Signed immediate 11-bit value.
     'Is15'
          Signed immediate 15-bit value.
     'Iu15'
          Unsigned immediate 15-bit value.
     'Ic15'
          A constant which is not in the range of imm15u but ok for bclr
          instruction.
     'Ie15'
          A constant which is not in the range of imm15u but ok for bset
          instruction.
     'It15'
          A constant which is not in the range of imm15u but ok for btgl
          instruction.
     'Ii15'
          A constant whose compliment value is in the range of imm15u
          and ok for bitci instruction.
     'Is16'
          Signed immediate 16-bit value.
     'Is17'
          Signed immediate 17-bit value.
     'Is19'
          Signed immediate 19-bit value.
     'Is20'
          Signed immediate 20-bit value.
     'Ihig'
          The immediate value that can be simply set high 20-bit.
     'Izeb'
          The immediate value 0xff.
     'Izeh'
          The immediate value 0xffff.
     'Ixls'
          The immediate value 0x01.
     'Ix11'
          The immediate value 0x7ff.
     'Ibms'
          The immediate value with power of 2.
     'Ifex'
          The immediate value with power of 2 minus 1.
     'U33'
          Memory constraint for 333 format.
     'U45'
          Memory constraint for 45 format.
     'U37'
          Memory constraint for 37 format.

_Nios II family--'config/nios2/constraints.md'_

     'I'
          Integer that is valid as an immediate operand in an
          instruction taking a signed 16-bit number.  Range -32768 to
          32767.

     'J'
          Integer that is valid as an immediate operand in an
          instruction taking an unsigned 16-bit number.  Range 0 to
          65535.

     'K'
          Integer that is valid as an immediate operand in an
          instruction taking only the upper 16-bits of a 32-bit number.
          Range 32-bit numbers with the lower 16-bits being 0.

     'L'
          Integer that is valid as an immediate operand for a shift
          instruction.  Range 0 to 31.

     'M'
          Integer that is valid as an immediate operand for only the
          value 0.  Can be used in conjunction with the format modifier
          'z' to use 'r0' instead of '0' in the assembly output.

     'N'
          Integer that is valid as an immediate operand for a custom
          instruction opcode.  Range 0 to 255.

     'S'
          Matches immediates which are addresses in the small data
          section and therefore can be added to 'gp' as a 16-bit
          immediate to re-create their 32-bit value.

_PDP-11--'config/pdp11/constraints.md'_
     'a'
          Floating point registers AC0 through AC3.  These can be loaded
          from/to memory with a single instruction.

     'd'
          Odd numbered general registers (R1, R3, R5).  These are used
          for 16-bit multiply operations.

     'f'
          Any of the floating point registers (AC0 through AC5).

     'G'
          Floating point constant 0.

     'I'
          An integer constant that fits in 16 bits.

     'J'
          An integer constant whose low order 16 bits are zero.

     'K'
          An integer constant that does not meet the constraints for
          codes 'I' or 'J'.

     'L'
          The integer constant 1.

     'M'
          The integer constant -1.

     'N'
          The integer constant 0.

     'O'
          Integer constants -4 through -1 and 1 through 4; shifts by
          these amounts are handled as multiple single-bit shifts rather
          than a single variable-length shift.

     'Q'
          A memory reference which requires an additional word (address
          or offset) after the opcode.

     'R'
          A memory reference that is encoded within the opcode.

_PowerPC and IBM RS6000--'config/rs6000/constraints.md'_
     'b'
          Address base register

     'd'
          Floating point register (containing 64-bit value)

     'f'
          Floating point register (containing 32-bit value)

     'v'
          Altivec vector register

     'wa'
          Any VSX register if the -mvsx option was used or NO_REGS.

     'wd'
          VSX vector register to hold vector double data or NO_REGS.

     'wf'
          VSX vector register to hold vector float data or NO_REGS.

     'wg'
          If '-mmfpgpr' was used, a floating point register or NO_REGS.

     'wh'
          Floating point register if direct moves are available, or
          NO_REGS.

     'wi'
          FP or VSX register to hold 64-bit integers for VSX insns or
          NO_REGS.

     'wj'
          FP or VSX register to hold 64-bit integers for direct moves or
          NO_REGS.

     'wk'
          FP or VSX register to hold 64-bit doubles for direct moves or
          NO_REGS.

     'wl'
          Floating point register if the LFIWAX instruction is enabled
          or NO_REGS.

     'wm'
          VSX register if direct move instructions are enabled, or
          NO_REGS.

     'wn'
          No register (NO_REGS).

     'wr'
          General purpose register if 64-bit instructions are enabled or
          NO_REGS.

     'ws'
          VSX vector register to hold scalar double values or NO_REGS.

     'wt'
          VSX vector register to hold 128 bit integer or NO_REGS.

     'wu'
          Altivec register to use for float/32-bit int loads/stores or
          NO_REGS.

     'wv'
          Altivec register to use for double loads/stores or NO_REGS.

     'ww'
          FP or VSX register to perform float operations under '-mvsx'
          or NO_REGS.

     'wx'
          Floating point register if the STFIWX instruction is enabled
          or NO_REGS.

     'wy'
          FP or VSX register to perform ISA 2.07 float ops or NO_REGS.

     'wz'
          Floating point register if the LFIWZX instruction is enabled
          or NO_REGS.

     'wD'
          Int constant that is the element number of the 64-bit scalar
          in a vector.

     'wQ'
          A memory address that will work with the 'lq' and 'stq'
          instructions.

     'h'
          'MQ', 'CTR', or 'LINK' register

     'q'
          'MQ' register

     'c'
          'CTR' register

     'l'
          'LINK' register

     'x'
          'CR' register (condition register) number 0

     'y'
          'CR' register (condition register)

     'z'
          'XER[CA]' carry bit (part of the XER register)

     'I'
          Signed 16-bit constant

     'J'
          Unsigned 16-bit constant shifted left 16 bits (use 'L' instead
          for 'SImode' constants)

     'K'
          Unsigned 16-bit constant

     'L'
          Signed 16-bit constant shifted left 16 bits

     'M'
          Constant larger than 31

     'N'
          Exact power of 2

     'O'
          Zero

     'P'
          Constant whose negation is a signed 16-bit constant

     'G'
          Floating point constant that can be loaded into a register
          with one instruction per word

     'H'
          Integer/Floating point constant that can be loaded into a
          register using three instructions

     'm'
          Memory operand.  Normally, 'm' does not allow addresses that
          update the base register.  If '<' or '>' constraint is also
          used, they are allowed and therefore on PowerPC targets in
          that case it is only safe to use 'm<>' in an 'asm' statement
          if that 'asm' statement accesses the operand exactly once.
          The 'asm' statement must also use '%U<OPNO>' as a placeholder
          for the "update" flag in the corresponding load or store
          instruction.  For example:

               asm ("st%U0 %1,%0" : "=m<>" (mem) : "r" (val));

          is correct but:

               asm ("st %1,%0" : "=m<>" (mem) : "r" (val));

          is not.

     'es'
          A "stable" memory operand; that is, one which does not include
          any automodification of the base register.  This used to be
          useful when 'm' allowed automodification of the base register,
          but as those are now only allowed when '<' or '>' is used,
          'es' is basically the same as 'm' without '<' and '>'.

     'Q'
          Memory operand that is an offset from a register (it is
          usually better to use 'm' or 'es' in 'asm' statements)

     'Z'
          Memory operand that is an indexed or indirect from a register
          (it is usually better to use 'm' or 'es' in 'asm' statements)

     'R'
          AIX TOC entry

     'a'
          Address operand that is an indexed or indirect from a register
          ('p' is preferable for 'asm' statements)

     'S'
          Constant suitable as a 64-bit mask operand

     'T'
          Constant suitable as a 32-bit mask operand

     'U'
          System V Release 4 small data area reference

     't'
          AND masks that can be performed by two rldic{l, r}
          instructions

     'W'
          Vector constant that does not require memory

     'j'
          Vector constant that is all zeros.

_RL78--'config/rl78/constraints.md'_

     'Int3'
          An integer constant in the range 1 ... 7.
     'Int8'
          An integer constant in the range 0 ... 255.
     'J'
          An integer constant in the range -255 ... 0
     'K'
          The integer constant 1.
     'L'
          The integer constant -1.
     'M'
          The integer constant 0.
     'N'
          The integer constant 2.
     'O'
          The integer constant -2.
     'P'
          An integer constant in the range 1 ... 15.
     'Qbi'
          The built-in compare types-eq, ne, gtu, ltu, geu, and leu.
     'Qsc'
          The synthetic compare types-gt, lt, ge, and le.
     'Wab'
          A memory reference with an absolute address.
     'Wbc'
          A memory reference using 'BC' as a base register, with an
          optional offset.
     'Wca'
          A memory reference using 'AX', 'BC', 'DE', or 'HL' for the
          address, for calls.
     'Wcv'
          A memory reference using any 16-bit register pair for the
          address, for calls.
     'Wd2'
          A memory reference using 'DE' as a base register, with an
          optional offset.
     'Wde'
          A memory reference using 'DE' as a base register, without any
          offset.
     'Wfr'
          Any memory reference to an address in the far address space.
     'Wh1'
          A memory reference using 'HL' as a base register, with an
          optional one-byte offset.
     'Whb'
          A memory reference using 'HL' as a base register, with 'B' or
          'C' as the index register.
     'Whl'
          A memory reference using 'HL' as a base register, without any
          offset.
     'Ws1'
          A memory reference using 'SP' as a base register, with an
          optional one-byte offset.
     'Y'
          Any memory reference to an address in the near address space.
     'A'
          The 'AX' register.
     'B'
          The 'BC' register.
     'D'
          The 'DE' register.
     'R'
          'A' through 'L' registers.
     'S'
          The 'SP' register.
     'T'
          The 'HL' register.
     'Z08W'
          The 16-bit 'R8' register.
     'Z10W'
          The 16-bit 'R10' register.
     'Zint'
          The registers reserved for interrupts ('R24' to 'R31').
     'a'
          The 'A' register.
     'b'
          The 'B' register.
     'c'
          The 'C' register.
     'd'
          The 'D' register.
     'e'
          The 'E' register.
     'h'
          The 'H' register.
     'l'
          The 'L' register.
     'v'
          The virtual registers.
     'w'
          The 'PSW' register.
     'x'
          The 'X' register.

_RX--'config/rx/constraints.md'_
     'Q'
          An address which does not involve register indirect addressing
          or pre/post increment/decrement addressing.

     'Symbol'
          A symbol reference.

     'Int08'
          A constant in the range -256 to 255, inclusive.

     'Sint08'
          A constant in the range -128 to 127, inclusive.

     'Sint16'
          A constant in the range -32768 to 32767, inclusive.

     'Sint24'
          A constant in the range -8388608 to 8388607, inclusive.

     'Uint04'
          A constant in the range 0 to 15, inclusive.

_S/390 and zSeries--'config/s390/s390.h'_
     'a'
          Address register (general purpose register except r0)

     'c'
          Condition code register

     'd'
          Data register (arbitrary general purpose register)

     'f'
          Floating-point register

     'I'
          Unsigned 8-bit constant (0-255)

     'J'
          Unsigned 12-bit constant (0-4095)

     'K'
          Signed 16-bit constant (-32768-32767)

     'L'
          Value appropriate as displacement.
          '(0..4095)'
               for short displacement
          '(-524288..524287)'
               for long displacement

     'M'
          Constant integer with a value of 0x7fffffff.

     'N'
          Multiple letter constraint followed by 4 parameter letters.
          '0..9:'
               number of the part counting from most to least
               significant
          'H,Q:'
               mode of the part
          'D,S,H:'
               mode of the containing operand
          '0,F:'
               value of the other parts (F--all bits set)
          The constraint matches if the specified part of a constant has
          a value different from its other parts.

     'Q'
          Memory reference without index register and with short
          displacement.

     'R'
          Memory reference with index register and short displacement.

     'S'
          Memory reference without index register but with long
          displacement.

     'T'
          Memory reference with index register and long displacement.

     'U'
          Pointer with short displacement.

     'W'
          Pointer with long displacement.

     'Y'
          Shift count operand.

_SPARC--'config/sparc/sparc.h'_
     'f'
          Floating-point register on the SPARC-V8 architecture and lower
          floating-point register on the SPARC-V9 architecture.

     'e'
          Floating-point register.  It is equivalent to 'f' on the
          SPARC-V8 architecture and contains both lower and upper
          floating-point registers on the SPARC-V9 architecture.

     'c'
          Floating-point condition code register.

     'd'
          Lower floating-point register.  It is only valid on the
          SPARC-V9 architecture when the Visual Instruction Set is
          available.

     'b'
          Floating-point register.  It is only valid on the SPARC-V9
          architecture when the Visual Instruction Set is available.

     'h'
          64-bit global or out register for the SPARC-V8+ architecture.

     'C'
          The constant all-ones, for floating-point.

     'A'
          Signed 5-bit constant

     'D'
          A vector constant

     'I'
          Signed 13-bit constant

     'J'
          Zero

     'K'
          32-bit constant with the low 12 bits clear (a constant that
          can be loaded with the 'sethi' instruction)

     'L'
          A constant in the range supported by 'movcc' instructions
          (11-bit signed immediate)

     'M'
          A constant in the range supported by 'movrcc' instructions
          (10-bit signed immediate)

     'N'
          Same as 'K', except that it verifies that bits that are not in
          the lower 32-bit range are all zero.  Must be used instead of
          'K' for modes wider than 'SImode'

     'O'
          The constant 4096

     'G'
          Floating-point zero

     'H'
          Signed 13-bit constant, sign-extended to 32 or 64 bits

     'P'
          The constant -1

     'Q'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single sethi
          instruction

     'R'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single mov instruction

     'S'
          Floating-point constant whose integral representation can be
          moved into an integer register using a high/lo_sum instruction
          sequence

     'T'
          Memory address aligned to an 8-byte boundary

     'U'
          Even register

     'W'
          Memory address for 'e' constraint registers

     'w'
          Memory address with only a base register

     'Y'
          Vector zero

_SPU--'config/spu/spu.h'_
     'a'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is treated as a 64 bit value.

     'c'
          An immediate for and/xor/or instructions.  const_int is
          treated as a 64 bit value.

     'd'
          An immediate for the 'iohl' instruction.  const_int is treated
          as a 64 bit value.

     'f'
          An immediate which can be loaded with 'fsmbi'.

     'A'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is treated as a 32 bit value.

     'B'
          An immediate for most arithmetic instructions.  const_int is
          treated as a 32 bit value.

     'C'
          An immediate for and/xor/or instructions.  const_int is
          treated as a 32 bit value.

     'D'
          An immediate for the 'iohl' instruction.  const_int is treated
          as a 32 bit value.

     'I'
          A constant in the range [-64, 63] for shift/rotate
          instructions.

     'J'
          An unsigned 7-bit constant for conversion/nop/channel
          instructions.

     'K'
          A signed 10-bit constant for most arithmetic instructions.

     'M'
          A signed 16 bit immediate for 'stop'.

     'N'
          An unsigned 16-bit constant for 'iohl' and 'fsmbi'.

     'O'
          An unsigned 7-bit constant whose 3 least significant bits are
          0.

     'P'
          An unsigned 3-bit constant for 16-byte rotates and shifts

     'R'
          Call operand, reg, for indirect calls

     'S'
          Call operand, symbol, for relative calls.

     'T'
          Call operand, const_int, for absolute calls.

     'U'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is sign extended to 128 bit.

     'W'
          An immediate for shift and rotate instructions.  const_int is
          treated as a 32 bit value.

     'Y'
          An immediate for and/xor/or instructions.  const_int is sign
          extended as a 128 bit.

     'Z'
          An immediate for the 'iohl' instruction.  const_int is sign
          extended to 128 bit.

_TI C6X family--'config/c6x/constraints.md'_
     'a'
          Register file A (A0-A31).

     'b'
          Register file B (B0-B31).

     'A'
          Predicate registers in register file A (A0-A2 on C64X and
          higher, A1 and A2 otherwise).

     'B'
          Predicate registers in register file B (B0-B2).

     'C'
          A call-used register in register file B (B0-B9, B16-B31).

     'Da'
          Register file A, excluding predicate registers (A3-A31, plus
          A0 if not C64X or higher).

     'Db'
          Register file B, excluding predicate registers (B3-B31).

     'Iu4'
          Integer constant in the range 0 ... 15.

     'Iu5'
          Integer constant in the range 0 ... 31.

     'In5'
          Integer constant in the range -31 ... 0.

     'Is5'
          Integer constant in the range -16 ... 15.

     'I5x'
          Integer constant that can be the operand of an ADDA or a SUBA
          insn.

     'IuB'
          Integer constant in the range 0 ... 65535.

     'IsB'
          Integer constant in the range -32768 ... 32767.

     'IsC'
          Integer constant in the range -2^{20} ... 2^{20} - 1.

     'Jc'
          Integer constant that is a valid mask for the clr instruction.

     'Js'
          Integer constant that is a valid mask for the set instruction.

     'Q'
          Memory location with A base register.

     'R'
          Memory location with B base register.

     'Z'
          Register B14 (aka DP).

_TILE-Gx--'config/tilegx/constraints.md'_
     'R00'
     'R01'
     'R02'
     'R03'
     'R04'
     'R05'
     'R06'
     'R07'
     'R08'
     'R09'
     'R10'
          Each of these represents a register constraint for an
          individual register, from r0 to r10.

     'I'
          Signed 8-bit integer constant.

     'J'
          Signed 16-bit integer constant.

     'K'
          Unsigned 16-bit integer constant.

     'L'
          Integer constant that fits in one signed byte when incremented
          by one (-129 ... 126).

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement which requires printing with '%In' and
          '%in' on TILE-Gx.  For example:

               asm ("st_add %I0,%1,%i0" : "=m<>" (*mem) : "r" (val));

     'M'
          A bit mask suitable for the BFINS instruction.

     'N'
          Integer constant that is a byte tiled out eight times.

     'O'
          The integer zero constant.

     'P'
          Integer constant that is a sign-extended byte tiled out as
          four shorts.

     'Q'
          Integer constant that fits in one signed byte when incremented
          (-129 ... 126), but excluding -1.

     'S'
          Integer constant that has all 1 bits consecutive and starting
          at bit 0.

     'T'
          A 16-bit fragment of a got, tls, or pc-relative reference.

     'U'
          Memory operand except postincrement.  This is roughly the same
          as 'm' when not used together with '<' or '>'.

     'W'
          An 8-element vector constant with identical elements.

     'Y'
          A 4-element vector constant with identical elements.

     'Z0'
          The integer constant 0xffffffff.

     'Z1'
          The integer constant 0xffffffff00000000.

_TILEPro--'config/tilepro/constraints.md'_
     'R00'
     'R01'
     'R02'
     'R03'
     'R04'
     'R05'
     'R06'
     'R07'
     'R08'
     'R09'
     'R10'
          Each of these represents a register constraint for an
          individual register, from r0 to r10.

     'I'
          Signed 8-bit integer constant.

     'J'
          Signed 16-bit integer constant.

     'K'
          Nonzero integer constant with low 16 bits zero.

     'L'
          Integer constant that fits in one signed byte when incremented
          by one (-129 ... 126).

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement which requires printing with '%In' and
          '%in' on TILEPro.  For example:

               asm ("swadd %I0,%1,%i0" : "=m<>" (mem) : "r" (val));

     'M'
          A bit mask suitable for the MM instruction.

     'N'
          Integer constant that is a byte tiled out four times.

     'O'
          The integer zero constant.

     'P'
          Integer constant that is a sign-extended byte tiled out as two
          shorts.

     'Q'
          Integer constant that fits in one signed byte when incremented
          (-129 ... 126), but excluding -1.

     'T'
          A symbolic operand, or a 16-bit fragment of a got, tls, or
          pc-relative reference.

     'U'
          Memory operand except postincrement.  This is roughly the same
          as 'm' when not used together with '<' or '>'.

     'W'
          A 4-element vector constant with identical elements.

     'Y'
          A 2-element vector constant with identical elements.

_Visium--'config/visium/constraints.md'_
     'b'
          EAM register 'mdb'

     'c'
          EAM register 'mdc'

     'f'
          Floating point register

     'l'
          General register, but not 'r29', 'r30' and 'r31'

     't'
          Register 'r1'

     'u'
          Register 'r2'

     'v'
          Register 'r3'

     'G'
          Floating-point constant 0.0

     'J'
          Integer constant in the range 0 ..  65535 (16-bit immediate)

     'K'
          Integer constant in the range 1 ..  31 (5-bit immediate)

     'L'
          Integer constant in the range -65535 ..  -1 (16-bit negative
          immediate)

     'M'
          Integer constant -1

     'O'
          Integer constant 0

     'P'
          Integer constant 32

_x86 family--'config/i386/constraints.md'_
     'R'
          Legacy register--the eight integer registers available on all
          i386 processors ('a', 'b', 'c', 'd', 'si', 'di', 'bp', 'sp').

     'q'
          Any register accessible as 'Rl'.  In 32-bit mode, 'a', 'b',
          'c', and 'd'; in 64-bit mode, any integer register.

     'Q'
          Any register accessible as 'Rh': 'a', 'b', 'c', and 'd'.

     'a'
          The 'a' register.

     'b'
          The 'b' register.

     'c'
          The 'c' register.

     'd'
          The 'd' register.

     'S'
          The 'si' register.

     'D'
          The 'di' register.

     'A'
          The 'a' and 'd' registers.  This class is used for
          instructions that return double word results in the 'ax:dx'
          register pair.  Single word values will be allocated either in
          'ax' or 'dx'.  For example on i386 the following implements
          'rdtsc':

               unsigned long long rdtsc (void)
               {
                 unsigned long long tick;
                 __asm__ __volatile__("rdtsc":"=A"(tick));
                 return tick;
               }

          This is not correct on x86-64 as it would allocate tick in
          either 'ax' or 'dx'.  You have to use the following variant
          instead:

               unsigned long long rdtsc (void)
               {
                 unsigned int tickl, tickh;
                 __asm__ __volatile__("rdtsc":"=a"(tickl),"=d"(tickh));
                 return ((unsigned long long)tickh << 32)|tickl;
               }

     'f'
          Any 80387 floating-point (stack) register.

     't'
          Top of 80387 floating-point stack ('%st(0)').

     'u'
          Second from top of 80387 floating-point stack ('%st(1)').

     'y'
          Any MMX register.

     'x'
          Any SSE register.

     'Yz'
          First SSE register ('%xmm0').

     'I'
          Integer constant in the range 0 ... 31, for 32-bit shifts.

     'J'
          Integer constant in the range 0 ... 63, for 64-bit shifts.

     'K'
          Signed 8-bit integer constant.

     'L'
          '0xFF' or '0xFFFF', for andsi as a zero-extending move.

     'M'
          0, 1, 2, or 3 (shifts for the 'lea' instruction).

     'N'
          Unsigned 8-bit integer constant (for 'in' and 'out'
          instructions).

     'G'
          Standard 80387 floating point constant.

     'C'
          Standard SSE floating point constant.

     'e'
          32-bit signed integer constant, or a symbolic reference known
          to fit that range (for immediate operands in sign-extending
          x86-64 instructions).

     'Z'
          32-bit unsigned integer constant, or a symbolic reference
          known to fit that range (for immediate operands in
          zero-extending x86-64 instructions).

_Xstormy16--'config/stormy16/stormy16.h'_
     'a'
          Register r0.

     'b'
          Register r1.

     'c'
          Register r2.

     'd'
          Register r8.

     'e'
          Registers r0 through r7.

     't'
          Registers r0 and r1.

     'y'
          The carry register.

     'z'
          Registers r8 and r9.

     'I'
          A constant between 0 and 3 inclusive.

     'J'
          A constant that has exactly one bit set.

     'K'
          A constant that has exactly one bit clear.

     'L'
          A constant between 0 and 255 inclusive.

     'M'
          A constant between -255 and 0 inclusive.

     'N'
          A constant between -3 and 0 inclusive.

     'O'
          A constant between 1 and 4 inclusive.

     'P'
          A constant between -4 and -1 inclusive.

     'Q'
          A memory reference that is a stack push.

     'R'
          A memory reference that is a stack pop.

     'S'
          A memory reference that refers to a constant address of known
          value.

     'T'
          The register indicated by Rx (not implemented yet).

     'U'
          A constant that is not between 2 and 15 inclusive.

     'Z'
          The constant 0.

_Xtensa--'config/xtensa/constraints.md'_
     'a'
          General-purpose 32-bit register

     'b'
          One-bit boolean register

     'A'
          MAC16 40-bit accumulator register

     'I'
          Signed 12-bit integer constant, for use in MOVI instructions

     'J'
          Signed 8-bit integer constant, for use in ADDI instructions

     'K'
          Integer constant valid for BccI instructions

     'L'
          Unsigned constant valid for BccUI instructions


File: llvm.info,  Node: Asm Labels,  Next: Explicit Reg Vars,  Prev: Constraints,  Up: Using Assembly Language with C

6.43.4 Controlling Names Used in Assembler Code
-----------------------------------------------

You can specify the name to be used in the assembler code for a C
function or variable by writing the 'asm' (or '__asm__') keyword after
the declarator as follows:

     int foo asm ("myfoo") = 2;

This specifies that the name to be used for the variable 'foo' in the
assembler code should be 'myfoo' rather than the usual '_foo'.

 On systems where an underscore is normally prepended to the name of a C
function or variable, this feature allows you to define names for the
linker that do not start with an underscore.

 It does not make sense to use this feature with a non-static local
variable since such variables do not have assembler names.  If you are
trying to put the variable in a particular register, see *note Explicit
Reg Vars::.  GCC presently accepts such code with a warning, but will
probably be changed to issue an error, rather than a warning, in the
future.

 You cannot use 'asm' in this way in a function _definition_; but you
can get the same effect by writing a declaration for the function before
its definition and putting 'asm' there, like this:

     extern func () asm ("FUNC");

     func (x, y)
          int x, y;
     /* ... */

 It is up to you to make sure that the assembler names you choose do not
conflict with any other assembler symbols.  Also, you must not use a
register name; that would produce completely invalid assembler code.
GCC does not as yet have the ability to store static variables in
registers.  Perhaps that will be added.


File: llvm.info,  Node: Explicit Reg Vars,  Next: Size of an asm,  Prev: Asm Labels,  Up: Using Assembly Language with C

6.43.5 Variables in Specified Registers
---------------------------------------

GNU C allows you to put a few global variables into specified hardware
registers.  You can also specify the register in which an ordinary
register variable should be allocated.

   * Global register variables reserve registers throughout the program.
     This may be useful in programs such as programming language
     interpreters that have a couple of global variables that are
     accessed very often.

   * Local register variables in specific registers do not reserve the
     registers, except at the point where they are used as input or
     output operands in an 'asm' statement and the 'asm' statement
     itself is not deleted.  The compiler's data flow analysis is
     capable of determining where the specified registers contain live
     values, and where they are available for other uses.  Stores into
     local register variables may be deleted when they appear to be dead
     according to dataflow analysis.  References to local register
     variables may be deleted or moved or simplified.

     These local variables are sometimes convenient for use with the
     extended 'asm' feature (*note Extended Asm::), if you want to write
     one output of the assembler instruction directly into a particular
     register.  (This works provided the register you specify fits the
     constraints specified for that operand in the 'asm'.)

* Menu:

* Global Reg Vars::
* Local Reg Vars::


File: llvm.info,  Node: Global Reg Vars,  Next: Local Reg Vars,  Up: Explicit Reg Vars

6.43.5.1 Defining Global Register Variables
...........................................

You can define a global register variable in GNU C like this:

     register int *foo asm ("a5");

Here 'a5' is the name of the register that should be used.  Choose a
register that is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.

 Naturally the register name is CPU-dependent, so you need to
conditionalize your program according to CPU type.  The register 'a5' is
a good choice on a 68000 for a variable of pointer type.  On machines
with register windows, be sure to choose a "global" register that is not
affected magically by the function call mechanism.

 In addition, different operating systems on the same CPU may differ in
how they name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register '%a5'.

 Eventually there may be a way of asking the compiler to choose a
register automatically, but first we need to figure out how it should
choose and how to enable you to guide the choice.  No solution is
evident.

 Defining a global register variable in a certain register reserves that
register entirely for this use, at least within the current compilation.
The register is not allocated for any other purpose in the functions in
the current compilation, and is not saved and restored by these
functions.  Stores into this register are never deleted even if they
appear to be dead, but references may be deleted or moved or simplified.

 It is not safe to access the global register variables from signal
handlers, or from more than one thread of control, because the system
library routines may temporarily use the register for other things
(unless you recompile them specially for the task at hand).

 It is not safe for one function that uses a global register variable to
call another such function 'foo' by way of a third function 'lose' that
is compiled without knowledge of this variable (i.e. in a different
source file in which the variable isn't declared).  This is because
'lose' might save the register and put some other value there.  For
example, you can't expect a global register variable to be available in
the comparison-function that you pass to 'qsort', since 'qsort' might
have put something else in that register.  (If you are prepared to
recompile 'qsort' with the same global register variable, you can solve
this problem.)

 If you want to recompile 'qsort' or other source files that do not
actually use your global register variable, so that they do not use that
register for any other purpose, then it suffices to specify the compiler
option '-ffixed-REG'.  You need not actually add a global register
declaration to their source code.

 A function that can alter the value of a global register variable
cannot safely be called from a function compiled without this variable,
because it could clobber the value the caller expects to find there on
return.  Therefore, the function that is the entry point into the part
of the program that uses the global register variable must explicitly
save and restore the value that belongs to its caller.

 On most machines, 'longjmp' restores to each global register variable
the value it had at the time of the 'setjmp'.  On some machines,
however, 'longjmp' does not change the value of global register
variables.  To be portable, the function that called 'setjmp' should
make other arrangements to save the values of the global register
variables, and to restore them in a 'longjmp'.  This way, the same thing
happens regardless of what 'longjmp' does.

 All global register variable declarations must precede all function
definitions.  If such a declaration could appear after function
definitions, the declaration would be too late to prevent the register
from being used for other purposes in the preceding functions.

 Global register variables may not have initial values, because an
executable file has no means to supply initial contents for a register.

 On the SPARC, there are reports that g3 ... g7 are suitable registers,
but certain library functions, such as 'getwd', as well as the
subroutines for division and remainder, modify g3 and g4.  g1 and g2 are
local temporaries.

 On the 68000, a2 ... a5 should be suitable, as should d2 ... d7.  Of
course, it does not do to use more than a few of those.


File: llvm.info,  Node: Local Reg Vars,  Prev: Global Reg Vars,  Up: Explicit Reg Vars

6.43.5.2 Specifying Registers for Local Variables
.................................................

You can define a local register variable with a specified register like
this:

     register int *foo asm ("a5");

Here 'a5' is the name of the register that should be used.  Note that
this is the same syntax used for defining global register variables, but
for a local variable it appears within a function.

 Naturally the register name is CPU-dependent, but this is not a
problem, since specific registers are most often useful with explicit
assembler instructions (*note Extended Asm::).  Both of these things
generally require that you conditionalize your program according to CPU
type.

 In addition, operating systems on one type of CPU may differ in how
they name the registers; then you need additional conditionals.  For
example, some 68000 operating systems call this register '%a5'.

 Defining such a register variable does not reserve the register; it
remains available for other uses in places where flow control determines
the variable's value is not live.

 This option does not guarantee that GCC generates code that has this
variable in the register you specify at all times.  You may not code an
explicit reference to this register in the assembler instruction
template part of an 'asm' statement and assume it always refers to this
variable.  However, using the variable as an input or output operand to
the 'asm' guarantees that the specified register is used for that
operand.  *Note Extended Asm::, for more information.

 Stores into local register variables may be deleted when they appear to
be dead according to dataflow analysis.  References to local register
variables may be deleted or moved or simplified.

 As with global register variables, it is recommended that you choose a
register that is normally saved and restored by function calls on your
machine, so that library routines will not clobber it.

 Sometimes when writing inline 'asm' code, you need to make an operand
be a specific register, but there's no matching constraint letter for
that register.  To force the operand into that register, create a local
variable and specify the register in the variable's declaration.  Then
use the local variable for the asm operand and specify any constraint
letter that matches the register:

     register int *p1 asm ("r0") = ...;
     register int *p2 asm ("r1") = ...;
     register int *result asm ("r0");
     asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));

 _Warning:_ In the above example, be aware that a register (for example
r0) can be call-clobbered by subsequent code, including function calls
and library calls for arithmetic operators on other variables (for
example the initialization of p2).  In this case, use temporary
variables for expressions between the register assignments:

     int t1 = ...;
     register int *p1 asm ("r0") = ...;
     register int *p2 asm ("r1") = t1;
     register int *result asm ("r0");
     asm ("sysint" : "=r" (result) : "0" (p1), "r" (p2));


File: llvm.info,  Node: Size of an asm,  Prev: Explicit Reg Vars,  Up: Using Assembly Language with C

6.43.6 Size of an 'asm'
-----------------------

Some targets require that GCC track the size of each instruction used in
order to generate correct code.  Because the final length of the code
produced by an 'asm' statement is only known by the assembler, GCC must
make an estimate as to how big it will be.  It does this by counting the
number of instructions in the pattern of the 'asm' and multiplying that
by the length of the longest instruction supported by that processor.
(When working out the number of instructions, it assumes that any
occurrence of a newline or of whatever statement separator character is
supported by the assembler - typically ';' -- indicates the end of an
instruction.)

 Normally, GCC's estimate is adequate to ensure that correct code is
generated, but it is possible to confuse the compiler if you use pseudo
instructions or assembler macros that expand into multiple real
instructions, or if you use assembler directives that expand to more
space in the object file than is needed for a single instruction.  If
this happens then the assembler may produce a diagnostic saying that a
label is unreachable.


File: llvm.info,  Node: Alternate Keywords,  Next: Incomplete Enums,  Prev: Using Assembly Language with C,  Up: C Extensions

6.44 Alternate Keywords
=======================

'-ansi' and the various '-std' options disable certain keywords.  This
causes trouble when you want to use GNU C extensions, or a
general-purpose header file that should be usable by all programs,
including ISO C programs.  The keywords 'asm', 'typeof' and 'inline' are
not available in programs compiled with '-ansi' or '-std' (although
'inline' can be used in a program compiled with '-std=c99' or
'-std=c11').  The ISO C99 keyword 'restrict' is only available when
'-std=gnu99' (which will eventually be the default) or '-std=c99' (or
the equivalent '-std=iso9899:1999'), or an option for a later standard
version, is used.

 The way to solve these problems is to put '__' at the beginning and end
of each problematical keyword.  For example, use '__asm__' instead of
'asm', and '__inline__' instead of 'inline'.

 Other C compilers won't accept these alternative keywords; if you want
to compile with another compiler, you can define the alternate keywords
as macros to replace them with the customary keywords.  It looks like
this:

     #ifndef __GNUC__
     #define __asm__ asm
     #endif

 '-pedantic' and other options cause warnings for many GNU C extensions.
You can prevent such warnings within one expression by writing
'__extension__' before the expression.  '__extension__' has no effect
aside from this.


File: llvm.info,  Node: Incomplete Enums,  Next: Function Names,  Prev: Alternate Keywords,  Up: C Extensions

6.45 Incomplete 'enum' Types
============================

You can define an 'enum' tag without specifying its possible values.
This results in an incomplete type, much like what you get if you write
'struct foo' without describing the elements.  A later declaration that
does specify the possible values completes the type.

 You can't allocate variables or storage using the type while it is
incomplete.  However, you can work with pointers to that type.

 This extension may not be very useful, but it makes the handling of
'enum' more consistent with the way 'struct' and 'union' are handled.

 This extension is not supported by GNU C++.


File: llvm.info,  Node: Function Names,  Next: Return Address,  Prev: Incomplete Enums,  Up: C Extensions

6.46 Function Names as Strings
==============================

GCC provides three magic variables that hold the name of the current
function, as a string.  The first of these is '__func__', which is part
of the C99 standard:

 The identifier '__func__' is implicitly declared by the translator as
if, immediately following the opening brace of each function definition,
the declaration

     static const char __func__[] = "function-name";

appeared, where function-name is the name of the lexically-enclosing
function.  This name is the unadorned name of the function.

 '__FUNCTION__' is another name for '__func__', provided for backward
compatibility with old versions of GCC.

 In C, '__PRETTY_FUNCTION__' is yet another name for '__func__'.
However, in C++, '__PRETTY_FUNCTION__' contains the type signature of
the function as well as its bare name.  For example, this program:

     extern "C" {
     extern int printf (char *, ...);
     }

     class a {
      public:
       void sub (int i)
         {
           printf ("__FUNCTION__ = %s\n", __FUNCTION__);
           printf ("__PRETTY_FUNCTION__ = %s\n", __PRETTY_FUNCTION__);
         }
     };

     int
     main (void)
     {
       a ax;
       ax.sub (0);
       return 0;
     }

gives this output:

     __FUNCTION__ = sub
     __PRETTY_FUNCTION__ = void a::sub(int)

 These identifiers are variables, not preprocessor macros, and may not
be used to initialize 'char' arrays or be concatenated with other string
literals.


File: llvm.info,  Node: Return Address,  Next: Vector Extensions,  Prev: Function Names,  Up: C Extensions

6.47 Getting the Return or Frame Address of a Function
======================================================

These functions may be used to get information about the callers of a
function.

 -- Built-in Function: void * __builtin_return_address (unsigned int
          LEVEL)
     This function returns the return address of the current function,
     or of one of its callers.  The LEVEL argument is number of frames
     to scan up the call stack.  A value of '0' yields the return
     address of the current function, a value of '1' yields the return
     address of the caller of the current function, and so forth.  When
     inlining the expected behavior is that the function returns the
     address of the function that is returned to.  To work around this
     behavior use the 'noinline' function attribute.

     The LEVEL argument must be a constant integer.

     On some machines it may be impossible to determine the return
     address of any function other than the current one; in such cases,
     or when the top of the stack has been reached, this function
     returns '0' or a random value.  In addition,
     '__builtin_frame_address' may be used to determine if the top of
     the stack has been reached.

     Additional post-processing of the returned value may be needed, see
     '__builtin_extract_return_addr'.

     This function should only be used with a nonzero argument for
     debugging purposes.

 -- Built-in Function: void * __builtin_extract_return_addr (void *ADDR)
     The address as returned by '__builtin_return_address' may have to
     be fed through this function to get the actual encoded address.
     For example, on the 31-bit S/390 platform the highest bit has to be
     masked out, or on SPARC platforms an offset has to be added for the
     true next instruction to be executed.

     If no fixup is needed, this function simply passes through ADDR.

 -- Built-in Function: void * __builtin_frob_return_address (void *ADDR)
     This function does the reverse of '__builtin_extract_return_addr'.

 -- Built-in Function: void * __builtin_frame_address (unsigned int
          LEVEL)
     This function is similar to '__builtin_return_address', but it
     returns the address of the function frame rather than the return
     address of the function.  Calling '__builtin_frame_address' with a
     value of '0' yields the frame address of the current function, a
     value of '1' yields the frame address of the caller of the current
     function, and so forth.

     The frame is the area on the stack that holds local variables and
     saved registers.  The frame address is normally the address of the
     first word pushed on to the stack by the function.  However, the
     exact definition depends upon the processor and the calling
     convention.  If the processor has a dedicated frame pointer
     register, and the function has a frame, then
     '__builtin_frame_address' returns the value of the frame pointer
     register.

     On some machines it may be impossible to determine the frame
     address of any function other than the current one; in such cases,
     or when the top of the stack has been reached, this function
     returns '0' if the first frame pointer is properly initialized by
     the startup code.

     This function should only be used with a nonzero argument for
     debugging purposes.


File: llvm.info,  Node: Vector Extensions,  Next: Offsetof,  Prev: Return Address,  Up: C Extensions

6.48 Using Vector Instructions through Built-in Functions
=========================================================

On some targets, the instruction set contains SIMD vector instructions
which operate on multiple values contained in one large register at the
same time.  For example, on the x86 the MMX, 3DNow! and SSE extensions
can be used this way.

 The first step in using these extensions is to provide the necessary
data types.  This should be done using an appropriate 'typedef':

     typedef int v4si __attribute__ ((vector_size (16)));

The 'int' type specifies the base type, while the attribute specifies
the vector size for the variable, measured in bytes.  For example, the
declaration above causes the compiler to set the mode for the 'v4si'
type to be 16 bytes wide and divided into 'int' sized units.  For a
32-bit 'int' this means a vector of 4 units of 4 bytes, and the
corresponding mode of 'foo' is V4SI.

 The 'vector_size' attribute is only applicable to integral and float
scalars, although arrays, pointers, and function return values are
allowed in conjunction with this construct.  Only sizes that are a power
of two are currently allowed.

 All the basic integer types can be used as base types, both as signed
and as unsigned: 'char', 'short', 'int', 'long', 'long long'.  In
addition, 'float' and 'double' can be used to build floating-point
vector types.

 Specifying a combination that is not valid for the current architecture
causes GCC to synthesize the instructions using a narrower mode.  For
example, if you specify a variable of type 'V4SI' and your architecture
does not allow for this specific SIMD type, GCC produces code that uses
4 'SIs'.

 The types defined in this manner can be used with a subset of normal C
operations.  Currently, GCC allows using the following operators on
these types: '+, -, *, /, unary minus, ^, |, &, ~, %'.

 The operations behave like C++ 'valarrays'.  Addition is defined as the
addition of the corresponding elements of the operands.  For example, in
the code below, each of the 4 elements in A is added to the
corresponding 4 elements in B and the resulting vector is stored in C.

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a, b, c;

     c = a + b;

 Subtraction, multiplication, division, and the logical operations
operate in a similar manner.  Likewise, the result of using the unary
minus or complement operators on a vector type is a vector whose
elements are the negative or complemented values of the corresponding
elements in the operand.

 It is possible to use shifting operators '<<', '>>' on integer-type
vectors.  The operation is defined as following: '{a0, a1, ..., an} >>
{b0, b1, ..., bn} == {a0 >> b0, a1 >> b1, ..., an >> bn}'.  Vector
operands must have the same number of elements.

 For convenience, it is allowed to use a binary vector operation where
one operand is a scalar.  In that case the compiler transforms the
scalar operand into a vector where each element is the scalar from the
operation.  The transformation happens only if the scalar could be
safely converted to the vector-element type.  Consider the following
code.

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a, b, c;
     long l;

     a = b + 1;    /* a = b + {1,1,1,1}; */
     a = 2 * b;    /* a = {2,2,2,2} * b; */

     a = l + a;    /* Error, cannot convert long to int. */

 Vectors can be subscripted as if the vector were an array with the same
number of elements and base type.  Out of bound accesses invoke
undefined behavior at run time.  Warnings for out of bound accesses for
vector subscription can be enabled with '-Warray-bounds'.

 Vector comparison is supported with standard comparison operators: '==,
!=, <, <=, >, >='.  Comparison operands can be vector expressions of
integer-type or real-type.  Comparison between integer-type vectors and
real-type vectors are not supported.  The result of the comparison is a
vector of the same width and number of elements as the comparison
operands with a signed integral element type.

 Vectors are compared element-wise producing 0 when comparison is false
and -1 (constant of the appropriate type where all bits are set)
otherwise.  Consider the following example.

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a = {1,2,3,4};
     v4si b = {3,2,1,4};
     v4si c;

     c = a >  b;     /* The result would be {0, 0,-1, 0}  */
     c = a == b;     /* The result would be {0,-1, 0,-1}  */

 In C++, the ternary operator '?:' is available.  'a?b:c', where 'b' and
'c' are vectors of the same type and 'a' is an integer vector with the
same number of elements of the same size as 'b' and 'c', computes all
three arguments and creates a vector '{a[0]?b[0]:c[0], a[1]?b[1]:c[1],
...}'.  Note that unlike in OpenCL, 'a' is thus interpreted as 'a != 0'
and not 'a < 0'.  As in the case of binary operations, this syntax is
also accepted when one of 'b' or 'c' is a scalar that is then
transformed into a vector.  If both 'b' and 'c' are scalars and the type
of 'true?b:c' has the same size as the element type of 'a', then 'b' and
'c' are converted to a vector type whose elements have this type and
with the same number of elements as 'a'.

 In C++, the logic operators '!, &&, ||' are available for vectors.
'!v' is equivalent to 'v == 0', 'a && b' is equivalent to 'a!=0 & b!=0'
and 'a || b' is equivalent to 'a!=0 | b!=0'.  For mixed operations
between a scalar 's' and a vector 'v', 's && v' is equivalent to
's?v!=0:0' (the evaluation is short-circuit) and 'v && s' is equivalent
to 'v!=0 & (s?-1:0)'.

 Vector shuffling is available using functions '__builtin_shuffle (vec,
mask)' and '__builtin_shuffle (vec0, vec1, mask)'.  Both functions
construct a permutation of elements from one or two vectors and return a
vector of the same type as the input vector(s).  The MASK is an integral
vector with the same width (W) and element count (N) as the output
vector.

 The elements of the input vectors are numbered in memory ordering of
VEC0 beginning at 0 and VEC1 beginning at N.  The elements of MASK are
considered modulo N in the single-operand case and modulo 2*N in the
two-operand case.

 Consider the following example,

     typedef int v4si __attribute__ ((vector_size (16)));

     v4si a = {1,2,3,4};
     v4si b = {5,6,7,8};
     v4si mask1 = {0,1,1,3};
     v4si mask2 = {0,4,2,5};
     v4si res;

     res = __builtin_shuffle (a, mask1);       /* res is {1,2,2,4}  */
     res = __builtin_shuffle (a, b, mask2);    /* res is {1,5,3,6}  */

 Note that '__builtin_shuffle' is intentionally semantically compatible
with the OpenCL 'shuffle' and 'shuffle2' functions.

 You can declare variables and use them in function calls and returns,
as well as in assignments and some casts.  You can specify a vector type
as a return type for a function.  Vector types can also be used as
function arguments.  It is possible to cast from one vector type to
another, provided they are of the same size (in fact, you can also cast
vectors to and from other datatypes of the same size).

 You cannot operate between vectors of different lengths or different
signedness without a cast.


File: llvm.info,  Node: Offsetof,  Next: __sync Builtins,  Prev: Vector Extensions,  Up: C Extensions

6.49 Support for 'offsetof'
===========================

GCC implements for both C and C++ a syntactic extension to implement the
'offsetof' macro.

     primary:
             "__builtin_offsetof" "(" typename "," offsetof_member_designator ")"

     offsetof_member_designator:
               identifier
             | offsetof_member_designator "." identifier
             | offsetof_member_designator "[" expr "]"

 This extension is sufficient such that

     #define offsetof(TYPE, MEMBER)  __builtin_offsetof (TYPE, MEMBER)

is a suitable definition of the 'offsetof' macro.  In C++, TYPE may be
dependent.  In either case, MEMBER may consist of a single identifier,
or a sequence of member accesses and array references.


File: llvm.info,  Node: __sync Builtins,  Next: __atomic Builtins,  Prev: Offsetof,  Up: C Extensions

6.50 Legacy '__sync' Built-in Functions for Atomic Memory Access
================================================================

The following built-in functions are intended to be compatible with
those described in the 'Intel Itanium Processor-specific Application
Binary Interface', section 7.4.  As such, they depart from the normal
GCC practice of using the '__builtin_' prefix, and further that they are
overloaded such that they work on multiple types.

 The definition given in the Intel documentation allows only for the use
of the types 'int', 'long', 'long long' as well as their unsigned
counterparts.  GCC allows any integral scalar or pointer type that is 1,
2, 4 or 8 bytes in length.

 Not all operations are supported by all target processors.  If a
particular operation cannot be implemented on the target processor, a
warning is generated and a call an external function is generated.  The
external function carries the same name as the built-in version, with an
additional suffix '_N' where N is the size of the data type.

 In most cases, these built-in functions are considered a "full
barrier".  That is, no memory operand is moved across the operation,
either forward or backward.  Further, instructions are issued as
necessary to prevent the processor from speculating loads across the
operation and from queuing stores after the operation.

 All of the routines are described in the Intel documentation to take
"an optional list of variables protected by the memory barrier".  It's
not clear what is meant by that; it could mean that _only_ the following
variables are protected, or it could mean that these variables should in
addition be protected.  At present GCC ignores this list and protects
all variables that are globally accessible.  If in the future we make
some use of this list, an empty list will continue to mean all globally
accessible variables.

'TYPE __sync_fetch_and_add (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_sub (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_or (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_and (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_xor (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_fetch_and_nand (TYPE *ptr, TYPE value, ...)'
     These built-in functions perform the operation suggested by the
     name, and returns the value that had previously been in memory.
     That is,

          { tmp = *ptr; *ptr OP= value; return tmp; }
          { tmp = *ptr; *ptr = ~(tmp & value); return tmp; }   // nand

     _Note:_ GCC 4.4 and later implement '__sync_fetch_and_nand' as
     '*ptr = ~(tmp & value)' instead of '*ptr = ~tmp & value'.

'TYPE __sync_add_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_sub_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_or_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_and_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_xor_and_fetch (TYPE *ptr, TYPE value, ...)'
'TYPE __sync_nand_and_fetch (TYPE *ptr, TYPE value, ...)'
     These built-in functions perform the operation suggested by the
     name, and return the new value.  That is,

          { *ptr OP= value; return *ptr; }
          { *ptr = ~(*ptr & value); return *ptr; }   // nand

     _Note:_ GCC 4.4 and later implement '__sync_nand_and_fetch' as
     '*ptr = ~(*ptr & value)' instead of '*ptr = ~*ptr & value'.

'bool __sync_bool_compare_and_swap (TYPE *ptr, TYPE oldval, TYPE newval, ...)'
'TYPE __sync_val_compare_and_swap (TYPE *ptr, TYPE oldval, TYPE newval, ...)'
     These built-in functions perform an atomic compare and swap.  That
     is, if the current value of '*PTR' is OLDVAL, then write NEWVAL
     into '*PTR'.

     The "bool" version returns true if the comparison is successful and
     NEWVAL is written.  The "val" version returns the contents of
     '*PTR' before the operation.

'__sync_synchronize (...)'
     This built-in function issues a full memory barrier.

'TYPE __sync_lock_test_and_set (TYPE *ptr, TYPE value, ...)'
     This built-in function, as described by Intel, is not a traditional
     test-and-set operation, but rather an atomic exchange operation.
     It writes VALUE into '*PTR', and returns the previous contents of
     '*PTR'.

     Many targets have only minimal support for such locks, and do not
     support a full exchange operation.  In this case, a target may
     support reduced functionality here by which the _only_ valid value
     to store is the immediate constant 1.  The exact value actually
     stored in '*PTR' is implementation defined.

     This built-in function is not a full barrier, but rather an
     "acquire barrier".  This means that references after the operation
     cannot move to (or be speculated to) before the operation, but
     previous memory stores may not be globally visible yet, and
     previous memory loads may not yet be satisfied.

'void __sync_lock_release (TYPE *ptr, ...)'
     This built-in function releases the lock acquired by
     '__sync_lock_test_and_set'.  Normally this means writing the
     constant 0 to '*PTR'.

     This built-in function is not a full barrier, but rather a "release
     barrier".  This means that all previous memory stores are globally
     visible, and all previous memory loads have been satisfied, but
     following memory reads are not prevented from being speculated to
     before the barrier.


File: llvm.info,  Node: __atomic Builtins,  Next: Integer Overflow Builtins,  Prev: __sync Builtins,  Up: C Extensions

6.51 Built-in Functions for Memory Model Aware Atomic Operations
================================================================

The following built-in functions approximately match the requirements
for C++11 memory model.  Many are similar to the '__sync' prefixed
built-in functions, but all also have a memory model parameter.  These
are all identified by being prefixed with '__atomic', and most are
overloaded such that they work with multiple types.

 GCC allows any integral scalar or pointer type that is 1, 2, 4, or 8
bytes in length.  16-byte integral types are also allowed if '__int128'
(*note __int128::) is supported by the architecture.

 Target architectures are encouraged to provide their own patterns for
each of these built-in functions.  If no target is provided, the
original non-memory model set of '__sync' atomic built-in functions are
utilized, along with any required synchronization fences surrounding it
in order to achieve the proper behavior.  Execution in this case is
subject to the same restrictions as those built-in functions.

 If there is no pattern or mechanism to provide a lock free instruction
sequence, a call is made to an external routine with the same parameters
to be resolved at run time.

 The four non-arithmetic functions (load, store, exchange, and
compare_exchange) all have a generic version as well.  This generic
version works on any data type.  If the data type size maps to one of
the integral sizes that may have lock free support, the generic version
utilizes the lock free built-in function.  Otherwise an external call is
left to be resolved at run time.  This external call is the same format
with the addition of a 'size_t' parameter inserted as the first
parameter indicating the size of the object being pointed to.  All
objects must be the same size.

 There are 6 different memory models that can be specified.  These map
to the same names in the C++11 standard.  Refer there or to the GCC wiki
on atomic synchronization
(http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync) for more detailed
definitions.  These memory models integrate both barriers to code motion
as well as synchronization requirements with other threads.  These are
listed in approximately ascending order of strength.  It is also
possible to use target specific flags for memory model flags, like
Hardware Lock Elision.

'__ATOMIC_RELAXED'
     No barriers or synchronization.
'__ATOMIC_CONSUME'
     Data dependency only for both barrier and synchronization with
     another thread.
'__ATOMIC_ACQUIRE'
     Barrier to hoisting of code and synchronizes with release (or
     stronger) semantic stores from another thread.
'__ATOMIC_RELEASE'
     Barrier to sinking of code and synchronizes with acquire (or
     stronger) semantic loads from another thread.
'__ATOMIC_ACQ_REL'
     Full barrier in both directions and synchronizes with acquire loads
     and release stores in another thread.
'__ATOMIC_SEQ_CST'
     Full barrier in both directions and synchronizes with acquire loads
     and release stores in all threads.

 When implementing patterns for these built-in functions, the memory
model parameter can be ignored as long as the pattern implements the
most restrictive '__ATOMIC_SEQ_CST' model.  Any of the other memory
models execute correctly with this memory model but they may not execute
as efficiently as they could with a more appropriate implementation of
the relaxed requirements.

 Note that the C++11 standard allows for the memory model parameter to
be determined at run time rather than at compile time.  These built-in
functions map any run-time value to '__ATOMIC_SEQ_CST' rather than
invoke a runtime library call or inline a switch statement.  This is
standard compliant, safe, and the simplest approach for now.

 The memory model parameter is a signed int, but only the lower 8 bits
are reserved for the memory model.  The remainder of the signed int is
reserved for future use and should be 0.  Use of the predefined atomic
values ensures proper usage.

 -- Built-in Function: TYPE __atomic_load_n (TYPE *ptr, int memmodel)
     This built-in function implements an atomic load operation.  It
     returns the contents of '*PTR'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', '__ATOMIC_ACQUIRE', and '__ATOMIC_CONSUME'.

 -- Built-in Function: void __atomic_load (TYPE *ptr, TYPE *ret, int
          memmodel)
     This is the generic version of an atomic load.  It returns the
     contents of '*PTR' in '*RET'.

 -- Built-in Function: void __atomic_store_n (TYPE *ptr, TYPE val, int
          memmodel)
     This built-in function implements an atomic store operation.  It
     writes 'VAL' into '*PTR'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', and '__ATOMIC_RELEASE'.

 -- Built-in Function: void __atomic_store (TYPE *ptr, TYPE *val, int
          memmodel)
     This is the generic version of an atomic store.  It stores the
     value of '*VAL' into '*PTR'.

 -- Built-in Function: TYPE __atomic_exchange_n (TYPE *ptr, TYPE val,
          int memmodel)
     This built-in function implements an atomic exchange operation.  It
     writes VAL into '*PTR', and returns the previous contents of
     '*PTR'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', '__ATOMIC_ACQUIRE', '__ATOMIC_RELEASE', and
     '__ATOMIC_ACQ_REL'.

 -- Built-in Function: void __atomic_exchange (TYPE *ptr, TYPE *val,
          TYPE *ret, int memmodel)
     This is the generic version of an atomic exchange.  It stores the
     contents of '*VAL' into '*PTR'.  The original value of '*PTR' is
     copied into '*RET'.

 -- Built-in Function: bool __atomic_compare_exchange_n (TYPE *ptr, TYPE
          *expected, TYPE desired, bool weak, int success_memmodel, int
          failure_memmodel)
     This built-in function implements an atomic compare and exchange
     operation.  This compares the contents of '*PTR' with the contents
     of '*EXPECTED' and if equal, writes DESIRED into '*PTR'.  If they
     are not equal, the current contents of '*PTR' is written into
     '*EXPECTED'.  WEAK is true for weak compare_exchange, and false for
     the strong variation.  Many targets only offer the strong variation
     and ignore the parameter.  When in doubt, use the strong variation.

     True is returned if DESIRED is written into '*PTR' and the
     execution is considered to conform to the memory model specified by
     SUCCESS_MEMMODEL.  There are no restrictions on what memory model
     can be used here.

     False is returned otherwise, and the execution is considered to
     conform to FAILURE_MEMMODEL.  This memory model cannot be
     '__ATOMIC_RELEASE' nor '__ATOMIC_ACQ_REL'.  It also cannot be a
     stronger model than that specified by SUCCESS_MEMMODEL.

 -- Built-in Function: bool __atomic_compare_exchange (TYPE *ptr, TYPE
          *expected, TYPE *desired, bool weak, int success_memmodel, int
          failure_memmodel)
     This built-in function implements the generic version of
     '__atomic_compare_exchange'.  The function is virtually identical
     to '__atomic_compare_exchange_n', except the desired value is also
     a pointer.

 -- Built-in Function: TYPE __atomic_add_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_sub_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_and_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_xor_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_or_fetch (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_nand_fetch (TYPE *ptr, TYPE val,
          int memmodel)
     These built-in functions perform the operation suggested by the
     name, and return the result of the operation.  That is,

          { *ptr OP= val; return *ptr; }

     All memory models are valid.

 -- Built-in Function: TYPE __atomic_fetch_add (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_sub (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_and (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_xor (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_or (TYPE *ptr, TYPE val, int
          memmodel)
 -- Built-in Function: TYPE __atomic_fetch_nand (TYPE *ptr, TYPE val,
          int memmodel)
     These built-in functions perform the operation suggested by the
     name, and return the value that had previously been in '*PTR'.
     That is,

          { tmp = *ptr; *ptr OP= val; return tmp; }

     All memory models are valid.

 -- Built-in Function: bool __atomic_test_and_set (void *ptr, int
          memmodel)

     This built-in function performs an atomic test-and-set operation on
     the byte at '*PTR'.  The byte is set to some implementation defined
     nonzero "set" value and the return value is 'true' if and only if
     the previous contents were "set".  It should be only used for
     operands of type 'bool' or 'char'.  For other types only part of
     the value may be set.

     All memory models are valid.

 -- Built-in Function: void __atomic_clear (bool *ptr, int memmodel)

     This built-in function performs an atomic clear operation on
     '*PTR'.  After the operation, '*PTR' contains 0.  It should be only
     used for operands of type 'bool' or 'char' and in conjunction with
     '__atomic_test_and_set'.  For other types it may only clear
     partially.  If the type is not 'bool' prefer using
     '__atomic_store'.

     The valid memory model variants are '__ATOMIC_RELAXED',
     '__ATOMIC_SEQ_CST', and '__ATOMIC_RELEASE'.

 -- Built-in Function: void __atomic_thread_fence (int memmodel)

     This built-in function acts as a synchronization fence between
     threads based on the specified memory model.

     All memory orders are valid.

 -- Built-in Function: void __atomic_signal_fence (int memmodel)

     This built-in function acts as a synchronization fence between a
     thread and signal handlers based in the same thread.

     All memory orders are valid.

 -- Built-in Function: bool __atomic_always_lock_free (size_t size, void
          *ptr)

     This built-in function returns true if objects of SIZE bytes always
     generate lock free atomic instructions for the target architecture.
     SIZE must resolve to a compile-time constant and the result also
     resolves to a compile-time constant.

     PTR is an optional pointer to the object that may be used to
     determine alignment.  A value of 0 indicates typical alignment
     should be used.  The compiler may also ignore this parameter.

          if (_atomic_always_lock_free (sizeof (long long), 0))

 -- Built-in Function: bool __atomic_is_lock_free (size_t size, void
          *ptr)

     This built-in function returns true if objects of SIZE bytes always
     generate lock free atomic instructions for the target architecture.
     If it is not known to be lock free a call is made to a runtime
     routine named '__atomic_is_lock_free'.

     PTR is an optional pointer to the object that may be used to
     determine alignment.  A value of 0 indicates typical alignment
     should be used.  The compiler may also ignore this parameter.


File: llvm.info,  Node: Integer Overflow Builtins,  Next: x86 specific memory model extensions for transactional memory,  Prev: __atomic Builtins,  Up: C Extensions

6.52 Built-in Functions to Perform Arithmetic with Overflow Checking
====================================================================

The following built-in functions allow performing simple arithmetic
operations together with checking whether the operations overflowed.

 -- Built-in Function: bool __builtin_add_overflow (TYPE1 a, TYPE2 b,
          TYPE3 *res)
 -- Built-in Function: bool __builtin_sadd_overflow (int a, int b, int
          *res)
 -- Built-in Function: bool __builtin_saddl_overflow (long int a, long
          int b, long int *res)
 -- Built-in Function: bool __builtin_saddll_overflow (long long int a,
          long long int b, long int *res)
 -- Built-in Function: bool __builtin_uadd_overflow (unsigned int a,
          unsigned int b, unsigned int *res)
 -- Built-in Function: bool __builtin_uaddl_overflow (unsigned long int
          a, unsigned long int b, unsigned long int *res)
 -- Built-in Function: bool __builtin_uaddll_overflow (unsigned long
          long int a, unsigned long long int b, unsigned long int *res)

     These built-in functions promote the first two operands into
     infinite precision signed type and perform addition on those
     promoted operands.  The result is then cast to the type the third
     pointer argument points to and stored there.  If the stored result
     is equal to the infinite precision result, the built-in functions
     return false, otherwise they return true.  As the addition is
     performed in infinite signed precision, these built-in functions
     have fully defined behavior for all argument values.

     The first built-in function allows arbitrary integral types for
     operands and the result type must be pointer to some integer type,
     the rest of the built-in functions have explicit integer types.

     The compiler will attempt to use hardware instructions to implement
     these built-in functions where possible, like conditional jump on
     overflow after addition, conditional jump on carry etc.

 -- Built-in Function: bool __builtin_sub_overflow (TYPE1 a, TYPE2 b,
          TYPE3 *res)
 -- Built-in Function: bool __builtin_ssub_overflow (int a, int b, int
          *res)
 -- Built-in Function: bool __builtin_ssubl_overflow (long int a, long
          int b, long int *res)
 -- Built-in Function: bool __builtin_ssubll_overflow (long long int a,
          long long int b, long int *res)
 -- Built-in Function: bool __builtin_usub_overflow (unsigned int a,
          unsigned int b, unsigned int *res)
 -- Built-in Function: bool __builtin_usubl_overflow (unsigned long int
          a, unsigned long int b, unsigned long int *res)
 -- Built-in Function: bool __builtin_usubll_overflow (unsigned long
          long int a, unsigned long long int b, unsigned long int *res)

     These built-in functions are similar to the add overflow checking
     built-in functions above, except they perform subtraction, subtract
     the second argument from the first one, instead of addition.

 -- Built-in Function: bool __builtin_mul_overflow (TYPE1 a, TYPE2 b,
          TYPE3 *res)
 -- Built-in Function: bool __builtin_smul_overflow (int a, int b, int
          *res)
 -- Built-in Function: bool __builtin_smull_overflow (long int a, long
          int b, long int *res)
 -- Built-in Function: bool __builtin_smulll_overflow (long long int a,
          long long int b, long int *res)
 -- Built-in Function: bool __builtin_umul_overflow (unsigned int a,
          unsigned int b, unsigned int *res)
 -- Built-in Function: bool __builtin_umull_overflow (unsigned long int
          a, unsigned long int b, unsigned long int *res)
 -- Built-in Function: bool __builtin_umulll_overflow (unsigned long
          long int a, unsigned long long int b, unsigned long int *res)

     These built-in functions are similar to the add overflow checking
     built-in functions above, except they perform multiplication,
     instead of addition.


File: llvm.info,  Node: x86 specific memory model extensions for transactional memory,  Next: Object Size Checking,  Prev: Integer Overflow Builtins,  Up: C Extensions

6.53 x86-Specific Memory Model Extensions for Transactional Memory
==================================================================

The x86 architecture supports additional memory ordering flags to mark
lock critical sections for hardware lock elision.  These must be
specified in addition to an existing memory model to atomic intrinsics.

'__ATOMIC_HLE_ACQUIRE'
     Start lock elision on a lock variable.  Memory model must be
     '__ATOMIC_ACQUIRE' or stronger.
'__ATOMIC_HLE_RELEASE'
     End lock elision on a lock variable.  Memory model must be
     '__ATOMIC_RELEASE' or stronger.

 When a lock acquire fails it is required for good performance to abort
the transaction quickly.  This can be done with a '_mm_pause'

     #include <immintrin.h> // For _mm_pause

     int lockvar;

     /* Acquire lock with lock elision */
     while (__atomic_exchange_n(&lockvar, 1, __ATOMIC_ACQUIRE|__ATOMIC_HLE_ACQUIRE))
         _mm_pause(); /* Abort failed transaction */
     ...
     /* Free lock with lock elision */
     __atomic_store_n(&lockvar, 0, __ATOMIC_RELEASE|__ATOMIC_HLE_RELEASE);


File: llvm.info,  Node: Object Size Checking,  Next: Pointer Bounds Checker builtins,  Prev: x86 specific memory model extensions for transactional memory,  Up: C Extensions

6.54 Object Size Checking Built-in Functions
============================================

GCC implements a limited buffer overflow protection mechanism that can
prevent some buffer overflow attacks.

 -- Built-in Function: size_t __builtin_object_size (void * PTR, int
          TYPE)
     is a built-in construct that returns a constant number of bytes
     from PTR to the end of the object PTR pointer points to (if known
     at compile time).  '__builtin_object_size' never evaluates its
     arguments for side-effects.  If there are any side-effects in them,
     it returns '(size_t) -1' for TYPE 0 or 1 and '(size_t) 0' for TYPE
     2 or 3.  If there are multiple objects PTR can point to and all of
     them are known at compile time, the returned number is the maximum
     of remaining byte counts in those objects if TYPE & 2 is 0 and
     minimum if nonzero.  If it is not possible to determine which
     objects PTR points to at compile time, '__builtin_object_size'
     should return '(size_t) -1' for TYPE 0 or 1 and '(size_t) 0' for
     TYPE 2 or 3.

     TYPE is an integer constant from 0 to 3.  If the least significant
     bit is clear, objects are whole variables, if it is set, a closest
     surrounding subobject is considered the object a pointer points to.
     The second bit determines if maximum or minimum of remaining bytes
     is computed.

          struct V { char buf1[10]; int b; char buf2[10]; } var;
          char *p = &var.buf1[1], *q = &var.b;

          /* Here the object p points to is var.  */
          assert (__builtin_object_size (p, 0) == sizeof (var) - 1);
          /* The subobject p points to is var.buf1.  */
          assert (__builtin_object_size (p, 1) == sizeof (var.buf1) - 1);
          /* The object q points to is var.  */
          assert (__builtin_object_size (q, 0)
                  == (char *) (&var + 1) - (char *) &var.b);
          /* The subobject q points to is var.b.  */
          assert (__builtin_object_size (q, 1) == sizeof (var.b));

 There are built-in functions added for many common string operation
functions, e.g., for 'memcpy' '__builtin___memcpy_chk' built-in is
provided.  This built-in has an additional last argument, which is the
number of bytes remaining in object the DEST argument points to or
'(size_t) -1' if the size is not known.

 The built-in functions are optimized into the normal string functions
like 'memcpy' if the last argument is '(size_t) -1' or if it is known at
compile time that the destination object will not be overflown.  If the
compiler can determine at compile time the object will be always
overflown, it issues a warning.

 The intended use can be e.g.

     #undef memcpy
     #define bos0(dest) __builtin_object_size (dest, 0)
     #define memcpy(dest, src, n) \
       __builtin___memcpy_chk (dest, src, n, bos0 (dest))

     char *volatile p;
     char buf[10];
     /* It is unknown what object p points to, so this is optimized
        into plain memcpy - no checking is possible.  */
     memcpy (p, "abcde", n);
     /* Destination is known and length too.  It is known at compile
        time there will be no overflow.  */
     memcpy (&buf[5], "abcde", 5);
     /* Destination is known, but the length is not known at compile time.
        This will result in __memcpy_chk call that can check for overflow
        at run time.  */
     memcpy (&buf[5], "abcde", n);
     /* Destination is known and it is known at compile time there will
        be overflow.  There will be a warning and __memcpy_chk call that
        will abort the program at run time.  */
     memcpy (&buf[6], "abcde", 5);

 Such built-in functions are provided for 'memcpy', 'mempcpy',
'memmove', 'memset', 'strcpy', 'stpcpy', 'strncpy', 'strcat' and
'strncat'.

 There are also checking built-in functions for formatted output
functions.
     int __builtin___sprintf_chk (char *s, int flag, size_t os, const char *fmt, ...);
     int __builtin___snprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                                   const char *fmt, ...);
     int __builtin___vsprintf_chk (char *s, int flag, size_t os, const char *fmt,
                                   va_list ap);
     int __builtin___vsnprintf_chk (char *s, size_t maxlen, int flag, size_t os,
                                    const char *fmt, va_list ap);

 The added FLAG argument is passed unchanged to '__sprintf_chk' etc.
functions and can contain implementation specific flags on what
additional security measures the checking function might take, such as
handling '%n' differently.

 The OS argument is the object size S points to, like in the other
built-in functions.  There is a small difference in the behavior though,
if OS is '(size_t) -1', the built-in functions are optimized into the
non-checking functions only if FLAG is 0, otherwise the checking
function is called with OS argument set to '(size_t) -1'.

 In addition to this, there are checking built-in functions
'__builtin___printf_chk', '__builtin___vprintf_chk',
'__builtin___fprintf_chk' and '__builtin___vfprintf_chk'.  These have
just one additional argument, FLAG, right before format string FMT.  If
the compiler is able to optimize them to 'fputc' etc. functions, it
does, otherwise the checking function is called and the FLAG argument
passed to it.


File: llvm.info,  Node: Pointer Bounds Checker builtins,  Next: Cilk Plus Builtins,  Prev: Object Size Checking,  Up: C Extensions

6.55 Pointer Bounds Checker Built-in Functions
==============================================

GCC provides a set of built-in functions to control Pointer Bounds
Checker instrumentation.  Note that all Pointer Bounds Checker builtins
are allowed to use even if you compile with Pointer Bounds Checker off.
The builtins behavior may differ in such case as documented below.

 -- Built-in Function: void * __builtin___bnd_set_ptr_bounds (const void
          * Q, size_t SIZE)

     This built-in function returns a new pointer with the value of Q,
     and associate it with the bounds [Q, Q+SIZE-1].  With Pointer
     Bounds Checker off built-in function just returns the first
     argument.

          extern void *__wrap_malloc (size_t n)
          {
            void *p = (void *)__real_malloc (n);
            if (!p) return __builtin___bnd_null_ptr_bounds (p);
            return __builtin___bnd_set_ptr_bounds (p, n);
          }

 -- Built-in Function: void * __builtin___bnd_narrow_ptr_bounds (const
          void * P, const void * Q, size_t SIZE)

     This built-in function returns a new pointer with the value of P
     and associate it with the narrowed bounds formed by the
     intersection of bounds associated with Q and the [P, P + SIZE - 1].
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

          void init_objects (object *objs, size_t size)
          {
            size_t i;
            /* Initialize objects one-by-one passing pointers with bounds of an object,
               not the full array of objects.  */
            for (i = 0; i < size; i++)
              init_object (__builtin___bnd_narrow_ptr_bounds (objs + i, objs, sizeof(object)));
          }

 -- Built-in Function: void * __builtin___bnd_copy_ptr_bounds (const
          void * Q, const void * R)

     This built-in function returns a new pointer with the value of Q,
     and associate it with the bounds already associated with pointer R.
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

          /* Here is a way to get pointer to object's field but
             still with the full object's bounds.  */
          int *field_ptr = __builtin___bnd_copy_ptr_bounds (&objptr->int_filed, objptr);

 -- Built-in Function: void * __builtin___bnd_init_ptr_bounds (const
          void * Q)

     This built-in function returns a new pointer with the value of Q,
     and associate it with INIT (allowing full memory access) bounds.
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

 -- Built-in Function: void * __builtin___bnd_null_ptr_bounds (const
          void * Q)

     This built-in function returns a new pointer with the value of Q,
     and associate it with NULL (allowing no memory access) bounds.
     With Pointer Bounds Checker off built-in function just returns the
     first argument.

 -- Built-in Function: void __builtin___bnd_store_ptr_bounds (const void
          ** PTR_ADDR, const void * PTR_VAL)

     This built-in function stores the bounds associated with pointer
     PTR_VAL and location PTR_ADDR into Bounds Table.  This can be
     useful to propagate bounds from legacy code without touching the
     associated pointer's memory when pointers were copied as integers.
     With Pointer Bounds Checker off built-in function call is ignored.

 -- Built-in Function: void __builtin___bnd_chk_ptr_lbounds (const void
          * Q)

     This built-in function checks if the pointer Q is within the lower
     bound of its associated bounds.  With Pointer Bounds Checker off
     built-in function call is ignored.

          extern void *__wrap_memset (void *dst, int c, size_t len)
          {
            if (len > 0)
              {
                __builtin___bnd_chk_ptr_lbounds (dst);
                __builtin___bnd_chk_ptr_ubounds ((char *)dst + len - 1);
                __real_memset (dst, c, len);
              }
            return dst;
          }

 -- Built-in Function: void __builtin___bnd_chk_ptr_ubounds (const void
          * Q)

     This built-in function checks if the pointer Q is within the upper
     bound of its associated bounds.  With Pointer Bounds Checker off
     built-in function call is ignored.

 -- Built-in Function: void __builtin___bnd_chk_ptr_bounds (const void *
          Q, size_t SIZE)

     This built-in function checks if [Q, Q + SIZE - 1] is within the
     lower and upper bounds associated with Q.  With Pointer Bounds
     Checker off built-in function call is ignored.

          extern void *__wrap_memcpy (void *dst, const void *src, size_t n)
          {
            if (n > 0)
              {
                __bnd_chk_ptr_bounds (dst, n);
                __bnd_chk_ptr_bounds (src, n);
                __real_memcpy (dst, src, n);
              }
            return dst;
          }

 -- Built-in Function: const void * __builtin___bnd_get_ptr_lbound
          (const void * Q)

     This built-in function returns the lower bound (which is a pointer)
     associated with the pointer Q.  This is at least useful for
     debugging using printf.  With Pointer Bounds Checker off built-in
     function returns 0.

          void *lb = __builtin___bnd_get_ptr_lbound (q);
          void *ub = __builtin___bnd_get_ptr_ubound (q);
          printf ("q = %p  lb(q) = %p  ub(q) = %p", q, lb, ub);

 -- Built-in Function: const void * __builtin___bnd_get_ptr_ubound
          (const void * Q)

     This built-in function returns the upper bound (which is a pointer)
     associated with the pointer Q.  With Pointer Bounds Checker off
     built-in function returns -1.


File: llvm.info,  Node: Cilk Plus Builtins,  Next: Other Builtins,  Prev: Pointer Bounds Checker builtins,  Up: C Extensions

6.56 Cilk Plus C/C++ Language Extension Built-in Functions
==========================================================

GCC provides support for the following built-in reduction functions if
Cilk Plus is enabled.  Cilk Plus can be enabled using the '-fcilkplus'
flag.

   * __sec_implicit_index
   * __sec_reduce
   * __sec_reduce_add
   * __sec_reduce_all_nonzero
   * __sec_reduce_all_zero
   * __sec_reduce_any_nonzero
   * __sec_reduce_any_zero
   * __sec_reduce_max
   * __sec_reduce_min
   * __sec_reduce_max_ind
   * __sec_reduce_min_ind
   * __sec_reduce_mul
   * __sec_reduce_mutating

 Further details and examples about these built-in functions are
described in the Cilk Plus language manual which can be found at
<http://www.cilkplus.org>.


File: llvm.info,  Node: Other Builtins,  Next: Target Builtins,  Prev: Cilk Plus Builtins,  Up: C Extensions

6.57 Other Built-in Functions Provided by GCC
=============================================

GCC provides a large number of built-in functions other than the ones
mentioned above.  Some of these are for internal use in the processing
of exceptions or variable-length argument lists and are not documented
here because they may change from time to time; we do not recommend
general use of these functions.

 The remaining functions are provided for optimization purposes.

 GCC includes built-in versions of many of the functions in the standard
C library.  The versions prefixed with '__builtin_' are always treated
as having the same meaning as the C library function even if you specify
the '-fno-builtin' option.  (*note C Dialect Options::) Many of these
functions are only optimized in certain cases; if they are not optimized
in a particular case, a call to the library function is emitted.

 Outside strict ISO C mode ('-ansi', '-std=c90', '-std=c99' or
'-std=c11'), the functions '_exit', 'alloca', 'bcmp', 'bzero',
'dcgettext', 'dgettext', 'dremf', 'dreml', 'drem', 'exp10f', 'exp10l',
'exp10', 'ffsll', 'ffsl', 'ffs', 'fprintf_unlocked', 'fputs_unlocked',
'gammaf', 'gammal', 'gamma', 'gammaf_r', 'gammal_r', 'gamma_r',
'gettext', 'index', 'isascii', 'j0f', 'j0l', 'j0', 'j1f', 'j1l', 'j1',
'jnf', 'jnl', 'jn', 'lgammaf_r', 'lgammal_r', 'lgamma_r', 'mempcpy',
'pow10f', 'pow10l', 'pow10', 'printf_unlocked', 'rindex', 'scalbf',
'scalbl', 'scalb', 'signbit', 'signbitf', 'signbitl', 'signbitd32',
'signbitd64', 'signbitd128', 'significandf', 'significandl',
'significand', 'sincosf', 'sincosl', 'sincos', 'stpcpy', 'stpncpy',
'strcasecmp', 'strdup', 'strfmon', 'strncasecmp', 'strndup', 'toascii',
'y0f', 'y0l', 'y0', 'y1f', 'y1l', 'y1', 'ynf', 'ynl' and 'yn' may be
handled as built-in functions.  All these functions have corresponding
versions prefixed with '__builtin_', which may be used even in strict
C90 mode.

 The ISO C99 functions '_Exit', 'acoshf', 'acoshl', 'acosh', 'asinhf',
'asinhl', 'asinh', 'atanhf', 'atanhl', 'atanh', 'cabsf', 'cabsl',
'cabs', 'cacosf', 'cacoshf', 'cacoshl', 'cacosh', 'cacosl', 'cacos',
'cargf', 'cargl', 'carg', 'casinf', 'casinhf', 'casinhl', 'casinh',
'casinl', 'casin', 'catanf', 'catanhf', 'catanhl', 'catanh', 'catanl',
'catan', 'cbrtf', 'cbrtl', 'cbrt', 'ccosf', 'ccoshf', 'ccoshl', 'ccosh',
'ccosl', 'ccos', 'cexpf', 'cexpl', 'cexp', 'cimagf', 'cimagl', 'cimag',
'clogf', 'clogl', 'clog', 'conjf', 'conjl', 'conj', 'copysignf',
'copysignl', 'copysign', 'cpowf', 'cpowl', 'cpow', 'cprojf', 'cprojl',
'cproj', 'crealf', 'creall', 'creal', 'csinf', 'csinhf', 'csinhl',
'csinh', 'csinl', 'csin', 'csqrtf', 'csqrtl', 'csqrt', 'ctanf',
'ctanhf', 'ctanhl', 'ctanh', 'ctanl', 'ctan', 'erfcf', 'erfcl', 'erfc',
'erff', 'erfl', 'erf', 'exp2f', 'exp2l', 'exp2', 'expm1f', 'expm1l',
'expm1', 'fdimf', 'fdiml', 'fdim', 'fmaf', 'fmal', 'fmaxf', 'fmaxl',
'fmax', 'fma', 'fminf', 'fminl', 'fmin', 'hypotf', 'hypotl', 'hypot',
'ilogbf', 'ilogbl', 'ilogb', 'imaxabs', 'isblank', 'iswblank',
'lgammaf', 'lgammal', 'lgamma', 'llabs', 'llrintf', 'llrintl', 'llrint',
'llroundf', 'llroundl', 'llround', 'log1pf', 'log1pl', 'log1p', 'log2f',
'log2l', 'log2', 'logbf', 'logbl', 'logb', 'lrintf', 'lrintl', 'lrint',
'lroundf', 'lroundl', 'lround', 'nearbyintf', 'nearbyintl', 'nearbyint',
'nextafterf', 'nextafterl', 'nextafter', 'nexttowardf', 'nexttowardl',
'nexttoward', 'remainderf', 'remainderl', 'remainder', 'remquof',
'remquol', 'remquo', 'rintf', 'rintl', 'rint', 'roundf', 'roundl',
'round', 'scalblnf', 'scalblnl', 'scalbln', 'scalbnf', 'scalbnl',
'scalbn', 'snprintf', 'tgammaf', 'tgammal', 'tgamma', 'truncf',
'truncl', 'trunc', 'vfscanf', 'vscanf', 'vsnprintf' and 'vsscanf' are
handled as built-in functions except in strict ISO C90 mode ('-ansi' or
'-std=c90').

 There are also built-in versions of the ISO C99 functions 'acosf',
'acosl', 'asinf', 'asinl', 'atan2f', 'atan2l', 'atanf', 'atanl',
'ceilf', 'ceill', 'cosf', 'coshf', 'coshl', 'cosl', 'expf', 'expl',
'fabsf', 'fabsl', 'floorf', 'floorl', 'fmodf', 'fmodl', 'frexpf',
'frexpl', 'ldexpf', 'ldexpl', 'log10f', 'log10l', 'logf', 'logl',
'modfl', 'modf', 'powf', 'powl', 'sinf', 'sinhf', 'sinhl', 'sinl',
'sqrtf', 'sqrtl', 'tanf', 'tanhf', 'tanhl' and 'tanl' that are
recognized in any mode since ISO C90 reserves these names for the
purpose to which ISO C99 puts them.  All these functions have
corresponding versions prefixed with '__builtin_'.

 The ISO C94 functions 'iswalnum', 'iswalpha', 'iswcntrl', 'iswdigit',
'iswgraph', 'iswlower', 'iswprint', 'iswpunct', 'iswspace', 'iswupper',
'iswxdigit', 'towlower' and 'towupper' are handled as built-in functions
except in strict ISO C90 mode ('-ansi' or '-std=c90').

 The ISO C90 functions 'abort', 'abs', 'acos', 'asin', 'atan2', 'atan',
'calloc', 'ceil', 'cosh', 'cos', 'exit', 'exp', 'fabs', 'floor', 'fmod',
'fprintf', 'fputs', 'frexp', 'fscanf', 'isalnum', 'isalpha', 'iscntrl',
'isdigit', 'isgraph', 'islower', 'isprint', 'ispunct', 'isspace',
'isupper', 'isxdigit', 'tolower', 'toupper', 'labs', 'ldexp', 'log10',
'log', 'malloc', 'memchr', 'memcmp', 'memcpy', 'memset', 'modf', 'pow',
'printf', 'putchar', 'puts', 'scanf', 'sinh', 'sin', 'snprintf',
'sprintf', 'sqrt', 'sscanf', 'strcat', 'strchr', 'strcmp', 'strcpy',
'strcspn', 'strlen', 'strncat', 'strncmp', 'strncpy', 'strpbrk',
'strrchr', 'strspn', 'strstr', 'tanh', 'tan', 'vfprintf', 'vprintf' and
'vsprintf' are all recognized as built-in functions unless
'-fno-builtin' is specified (or '-fno-builtin-FUNCTION' is specified for
an individual function).  All of these functions have corresponding
versions prefixed with '__builtin_'.

 GCC provides built-in versions of the ISO C99 floating-point comparison
macros that avoid raising exceptions for unordered operands.  They have
the same names as the standard macros ( 'isgreater', 'isgreaterequal',
'isless', 'islessequal', 'islessgreater', and 'isunordered') , with
'__builtin_' prefixed.  We intend for a library implementor to be able
to simply '#define' each standard macro to its built-in equivalent.  In
the same fashion, GCC provides 'fpclassify', 'isfinite', 'isinf_sign'
and 'isnormal' built-ins used with '__builtin_' prefixed.  The 'isinf'
and 'isnan' built-in functions appear both with and without the
'__builtin_' prefix.

 -- Built-in Function: int __builtin_types_compatible_p (TYPE1, TYPE2)

     You can use the built-in function '__builtin_types_compatible_p' to
     determine whether two types are the same.

     This built-in function returns 1 if the unqualified versions of the
     types TYPE1 and TYPE2 (which are types, not expressions) are
     compatible, 0 otherwise.  The result of this built-in function can
     be used in integer constant expressions.

     This built-in function ignores top level qualifiers (e.g., 'const',
     'volatile').  For example, 'int' is equivalent to 'const int'.

     The type 'int[]' and 'int[5]' are compatible.  On the other hand,
     'int' and 'char *' are not compatible, even if the size of their
     types, on the particular architecture are the same.  Also, the
     amount of pointer indirection is taken into account when
     determining similarity.  Consequently, 'short *' is not similar to
     'short **'.  Furthermore, two types that are typedefed are
     considered compatible if their underlying types are compatible.

     An 'enum' type is not considered to be compatible with another
     'enum' type even if both are compatible with the same integer type;
     this is what the C standard specifies.  For example, 'enum {foo,
     bar}' is not similar to 'enum {hot, dog}'.

     You typically use this function in code whose execution varies
     depending on the arguments' types.  For example:

          #define foo(x)                                                  \
            ({                                                           \
              typeof (x) tmp = (x);                                       \
              if (__builtin_types_compatible_p (typeof (x), long double)) \
                tmp = foo_long_double (tmp);                              \
              else if (__builtin_types_compatible_p (typeof (x), double)) \
                tmp = foo_double (tmp);                                   \
              else if (__builtin_types_compatible_p (typeof (x), float))  \
                tmp = foo_float (tmp);                                    \
              else                                                        \
                abort ();                                                 \
              tmp;                                                        \
            })

     _Note:_ This construct is only available for C.

 -- Built-in Function: TYPE __builtin_call_with_static_chain (CALL_EXP,
          POINTER_EXP)

     The CALL_EXP expression must be a function call, and the
     POINTER_EXP expression must be a pointer.  The POINTER_EXP is
     passed to the function call in the target's static chain location.
     The result of builtin is the result of the function call.

     _Note:_ This builtin is only available for C.  This builtin can be
     used to call Go closures from C.

 -- Built-in Function: TYPE __builtin_choose_expr (CONST_EXP, EXP1,
          EXP2)

     You can use the built-in function '__builtin_choose_expr' to
     evaluate code depending on the value of a constant expression.
     This built-in function returns EXP1 if CONST_EXP, which is an
     integer constant expression, is nonzero.  Otherwise it returns
     EXP2.

     This built-in function is analogous to the '? :' operator in C,
     except that the expression returned has its type unaltered by
     promotion rules.  Also, the built-in function does not evaluate the
     expression that is not chosen.  For example, if CONST_EXP evaluates
     to true, EXP2 is not evaluated even if it has side-effects.

     This built-in function can return an lvalue if the chosen argument
     is an lvalue.

     If EXP1 is returned, the return type is the same as EXP1's type.
     Similarly, if EXP2 is returned, its return type is the same as
     EXP2.

     Example:

          #define foo(x)                                                    \
            __builtin_choose_expr (                                         \
              __builtin_types_compatible_p (typeof (x), double),            \
              foo_double (x),                                               \
              __builtin_choose_expr (                                       \
                __builtin_types_compatible_p (typeof (x), float),           \
                foo_float (x),                                              \
                /* The void expression results in a compile-time error  \
                   when assigning the result to something.  */          \
                (void)0))

     _Note:_ This construct is only available for C.  Furthermore, the
     unused expression (EXP1 or EXP2 depending on the value of
     CONST_EXP) may still generate syntax errors.  This may change in
     future revisions.

 -- Built-in Function: TYPE __builtin_complex (REAL, IMAG)

     The built-in function '__builtin_complex' is provided for use in
     implementing the ISO C11 macros 'CMPLXF', 'CMPLX' and 'CMPLXL'.
     REAL and IMAG must have the same type, a real binary floating-point
     type, and the result has the corresponding complex type with real
     and imaginary parts REAL and IMAG.  Unlike 'REAL + I * IMAG', this
     works even when infinities, NaNs and negative zeros are involved.

 -- Built-in Function: int __builtin_constant_p (EXP)
     You can use the built-in function '__builtin_constant_p' to
     determine if a value is known to be constant at compile time and
     hence that GCC can perform constant-folding on expressions
     involving that value.  The argument of the function is the value to
     test.  The function returns the integer 1 if the argument is known
     to be a compile-time constant and 0 if it is not known to be a
     compile-time constant.  A return of 0 does not indicate that the
     value is _not_ a constant, but merely that GCC cannot prove it is a
     constant with the specified value of the '-O' option.

     You typically use this function in an embedded application where
     memory is a critical resource.  If you have some complex
     calculation, you may want it to be folded if it involves constants,
     but need to call a function if it does not.  For example:

          #define Scale_Value(X)      \
            (__builtin_constant_p (X) \
            ? ((X) * SCALE + OFFSET) : Scale (X))

     You may use this built-in function in either a macro or an inline
     function.  However, if you use it in an inlined function and pass
     an argument of the function as the argument to the built-in, GCC
     never returns 1 when you call the inline function with a string
     constant or compound literal (*note Compound Literals::) and does
     not return 1 when you pass a constant numeric value to the inline
     function unless you specify the '-O' option.

     You may also use '__builtin_constant_p' in initializers for static
     data.  For instance, you can write

          static const int table[] = {
             __builtin_constant_p (EXPRESSION) ? (EXPRESSION) : -1,
             /* ... */
          };

     This is an acceptable initializer even if EXPRESSION is not a
     constant expression, including the case where
     '__builtin_constant_p' returns 1 because EXPRESSION can be folded
     to a constant but EXPRESSION contains operands that are not
     otherwise permitted in a static initializer (for example, '0 && foo
     ()').  GCC must be more conservative about evaluating the built-in
     in this case, because it has no opportunity to perform
     optimization.

 -- Built-in Function: long __builtin_expect (long EXP, long C)
     You may use '__builtin_expect' to provide the compiler with branch
     prediction information.  In general, you should prefer to use
     actual profile feedback for this ('-fprofile-arcs'), as programmers
     are notoriously bad at predicting how their programs actually
     perform.  However, there are applications in which this data is
     hard to collect.

     The return value is the value of EXP, which should be an integral
     expression.  The semantics of the built-in are that it is expected
     that EXP == C.  For example:

          if (__builtin_expect (x, 0))
            foo ();

     indicates that we do not expect to call 'foo', since we expect 'x'
     to be zero.  Since you are limited to integral expressions for EXP,
     you should use constructions such as

          if (__builtin_expect (ptr != NULL, 1))
            foo (*ptr);

     when testing pointer or floating-point values.

 -- Built-in Function: void __builtin_trap (void)
     This function causes the program to exit abnormally.  GCC
     implements this function by using a target-dependent mechanism
     (such as intentionally executing an illegal instruction) or by
     calling 'abort'.  The mechanism used may vary from release to
     release so you should not rely on any particular implementation.

 -- Built-in Function: void __builtin_unreachable (void)
     If control flow reaches the point of the '__builtin_unreachable',
     the program is undefined.  It is useful in situations where the
     compiler cannot deduce the unreachability of the code.

     One such case is immediately following an 'asm' statement that
     either never terminates, or one that transfers control elsewhere
     and never returns.  In this example, without the
     '__builtin_unreachable', GCC issues a warning that control reaches
     the end of a non-void function.  It also generates code to return
     after the 'asm'.

          int f (int c, int v)
          {
            if (c)
              {
                return v;
              }
            else
              {
                asm("jmp error_handler");
                __builtin_unreachable ();
              }
          }

     Because the 'asm' statement unconditionally transfers control out
     of the function, control never reaches the end of the function
     body.  The '__builtin_unreachable' is in fact unreachable and
     communicates this fact to the compiler.

     Another use for '__builtin_unreachable' is following a call a
     function that never returns but that is not declared
     '__attribute__((noreturn))', as in this example:

          void function_that_never_returns (void);

          int g (int c)
          {
            if (c)
              {
                return 1;
              }
            else
              {
                function_that_never_returns ();
                __builtin_unreachable ();
              }
          }

 -- Built-in Function: void *__builtin_assume_aligned (const void *EXP,
          size_t ALIGN, ...)
     This function returns its first argument, and allows the compiler
     to assume that the returned pointer is at least ALIGN bytes
     aligned.  This built-in can have either two or three arguments, if
     it has three, the third argument should have integer type, and if
     it is nonzero means misalignment offset.  For example:

          void *x = __builtin_assume_aligned (arg, 16);

     means that the compiler can assume 'x', set to 'arg', is at least
     16-byte aligned, while:

          void *x = __builtin_assume_aligned (arg, 32, 8);

     means that the compiler can assume for 'x', set to 'arg', that
     '(char *) x - 8' is 32-byte aligned.

 -- Built-in Function: int __builtin_LINE ()
     This function is the equivalent to the preprocessor '__LINE__'
     macro and returns the line number of the invocation of the
     built-in.  In a C++ default argument for a function F, it gets the
     line number of the call to F.

 -- Built-in Function: const char * __builtin_FUNCTION ()
     This function is the equivalent to the preprocessor '__FUNCTION__'
     macro and returns the function name the invocation of the built-in
     is in.

 -- Built-in Function: const char * __builtin_FILE ()
     This function is the equivalent to the preprocessor '__FILE__'
     macro and returns the file name the invocation of the built-in is
     in.  In a C++ default argument for a function F, it gets the file
     name of the call to F.

 -- Built-in Function: void __builtin___clear_cache (char *BEGIN, char
          *END)
     This function is used to flush the processor's instruction cache
     for the region of memory between BEGIN inclusive and END exclusive.
     Some targets require that the instruction cache be flushed, after
     modifying memory containing code, in order to obtain deterministic
     behavior.

     If the target does not require instruction cache flushes,
     '__builtin___clear_cache' has no effect.  Otherwise either
     instructions are emitted in-line to clear the instruction cache or
     a call to the '__clear_cache' function in libgcc is made.

 -- Built-in Function: void __builtin_prefetch (const void *ADDR, ...)
     This function is used to minimize cache-miss latency by moving data
     into a cache before it is accessed.  You can insert calls to
     '__builtin_prefetch' into code for which you know addresses of data
     in memory that is likely to be accessed soon.  If the target
     supports them, data prefetch instructions are generated.  If the
     prefetch is done early enough before the access then the data will
     be in the cache by the time it is accessed.

     The value of ADDR is the address of the memory to prefetch.  There
     are two optional arguments, RW and LOCALITY.  The value of RW is a
     compile-time constant one or zero; one means that the prefetch is
     preparing for a write to the memory address and zero, the default,
     means that the prefetch is preparing for a read.  The value
     LOCALITY must be a compile-time constant integer between zero and
     three.  A value of zero means that the data has no temporal
     locality, so it need not be left in the cache after the access.  A
     value of three means that the data has a high degree of temporal
     locality and should be left in all levels of cache possible.
     Values of one and two mean, respectively, a low or moderate degree
     of temporal locality.  The default is three.

          for (i = 0; i < n; i++)
            {
              a[i] = a[i] + b[i];
              __builtin_prefetch (&a[i+j], 1, 1);
              __builtin_prefetch (&b[i+j], 0, 1);
              /* ... */
            }

     Data prefetch does not generate faults if ADDR is invalid, but the
     address expression itself must be valid.  For example, a prefetch
     of 'p->next' does not fault if 'p->next' is not a valid address,
     but evaluation faults if 'p' is not a valid address.

     If the target does not support data prefetch, the address
     expression is evaluated if it includes side effects but no other
     code is generated and GCC does not issue a warning.

 -- Built-in Function: double __builtin_huge_val (void)
     Returns a positive infinity, if supported by the floating-point
     format, else 'DBL_MAX'.  This function is suitable for implementing
     the ISO C macro 'HUGE_VAL'.

 -- Built-in Function: float __builtin_huge_valf (void)
     Similar to '__builtin_huge_val', except the return type is 'float'.

 -- Built-in Function: long double __builtin_huge_vall (void)
     Similar to '__builtin_huge_val', except the return type is 'long
     double'.

 -- Built-in Function: int __builtin_fpclassify (int, int, int, int,
          int, ...)
     This built-in implements the C99 fpclassify functionality.  The
     first five int arguments should be the target library's notion of
     the possible FP classes and are used for return values.  They must
     be constant values and they must appear in this order: 'FP_NAN',
     'FP_INFINITE', 'FP_NORMAL', 'FP_SUBNORMAL' and 'FP_ZERO'.  The
     ellipsis is for exactly one floating-point value to classify.  GCC
     treats the last argument as type-generic, which means it does not
     do default promotion from float to double.

 -- Built-in Function: double __builtin_inf (void)
     Similar to '__builtin_huge_val', except a warning is generated if
     the target floating-point format does not support infinities.

 -- Built-in Function: _Decimal32 __builtin_infd32 (void)
     Similar to '__builtin_inf', except the return type is '_Decimal32'.

 -- Built-in Function: _Decimal64 __builtin_infd64 (void)
     Similar to '__builtin_inf', except the return type is '_Decimal64'.

 -- Built-in Function: _Decimal128 __builtin_infd128 (void)
     Similar to '__builtin_inf', except the return type is
     '_Decimal128'.

 -- Built-in Function: float __builtin_inff (void)
     Similar to '__builtin_inf', except the return type is 'float'.
     This function is suitable for implementing the ISO C99 macro
     'INFINITY'.

 -- Built-in Function: long double __builtin_infl (void)
     Similar to '__builtin_inf', except the return type is 'long
     double'.

 -- Built-in Function: int __builtin_isinf_sign (...)
     Similar to 'isinf', except the return value is -1 for an argument
     of '-Inf' and 1 for an argument of '+Inf'.  Note while the
     parameter list is an ellipsis, this function only accepts exactly
     one floating-point argument.  GCC treats this parameter as
     type-generic, which means it does not do default promotion from
     float to double.

 -- Built-in Function: double __builtin_nan (const char *str)
     This is an implementation of the ISO C99 function 'nan'.

     Since ISO C99 defines this function in terms of 'strtod', which we
     do not implement, a description of the parsing is in order.  The
     string is parsed as by 'strtol'; that is, the base is recognized by
     leading '0' or '0x' prefixes.  The number parsed is placed in the
     significand such that the least significant bit of the number is at
     the least significant bit of the significand.  The number is
     truncated to fit the significand field provided.  The significand
     is forced to be a quiet NaN.

     This function, if given a string literal all of which would have
     been consumed by 'strtol', is evaluated early enough that it is
     considered a compile-time constant.

 -- Built-in Function: _Decimal32 __builtin_nand32 (const char *str)
     Similar to '__builtin_nan', except the return type is '_Decimal32'.

 -- Built-in Function: _Decimal64 __builtin_nand64 (const char *str)
     Similar to '__builtin_nan', except the return type is '_Decimal64'.

 -- Built-in Function: _Decimal128 __builtin_nand128 (const char *str)
     Similar to '__builtin_nan', except the return type is
     '_Decimal128'.

 -- Built-in Function: float __builtin_nanf (const char *str)
     Similar to '__builtin_nan', except the return type is 'float'.

 -- Built-in Function: long double __builtin_nanl (const char *str)
     Similar to '__builtin_nan', except the return type is 'long
     double'.

 -- Built-in Function: double __builtin_nans (const char *str)
     Similar to '__builtin_nan', except the significand is forced to be
     a signaling NaN.  The 'nans' function is proposed by WG14 N965.

 -- Built-in Function: float __builtin_nansf (const char *str)
     Similar to '__builtin_nans', except the return type is 'float'.

 -- Built-in Function: long double __builtin_nansl (const char *str)
     Similar to '__builtin_nans', except the return type is 'long
     double'.

 -- Built-in Function: int __builtin_ffs (int x)
     Returns one plus the index of the least significant 1-bit of X, or
     if X is zero, returns zero.

 -- Built-in Function: int __builtin_clz (unsigned int x)
     Returns the number of leading 0-bits in X, starting at the most
     significant bit position.  If X is 0, the result is undefined.

 -- Built-in Function: int __builtin_ctz (unsigned int x)
     Returns the number of trailing 0-bits in X, starting at the least
     significant bit position.  If X is 0, the result is undefined.

 -- Built-in Function: int __builtin_clrsb (int x)
     Returns the number of leading redundant sign bits in X, i.e. the
     number of bits following the most significant bit that are
     identical to it.  There are no special cases for 0 or other values.

 -- Built-in Function: int __builtin_popcount (unsigned int x)
     Returns the number of 1-bits in X.

 -- Built-in Function: int __builtin_parity (unsigned int x)
     Returns the parity of X, i.e. the number of 1-bits in X modulo 2.

 -- Built-in Function: int __builtin_ffsl (long)
     Similar to '__builtin_ffs', except the argument type is 'long'.

 -- Built-in Function: int __builtin_clzl (unsigned long)
     Similar to '__builtin_clz', except the argument type is 'unsigned
     long'.

 -- Built-in Function: int __builtin_ctzl (unsigned long)
     Similar to '__builtin_ctz', except the argument type is 'unsigned
     long'.

 -- Built-in Function: int __builtin_clrsbl (long)
     Similar to '__builtin_clrsb', except the argument type is 'long'.

 -- Built-in Function: int __builtin_popcountl (unsigned long)
     Similar to '__builtin_popcount', except the argument type is
     'unsigned long'.

 -- Built-in Function: int __builtin_parityl (unsigned long)
     Similar to '__builtin_parity', except the argument type is
     'unsigned long'.

 -- Built-in Function: int __builtin_ffsll (long long)
     Similar to '__builtin_ffs', except the argument type is 'long
     long'.

 -- Built-in Function: int __builtin_clzll (unsigned long long)
     Similar to '__builtin_clz', except the argument type is 'unsigned
     long long'.

 -- Built-in Function: int __builtin_ctzll (unsigned long long)
     Similar to '__builtin_ctz', except the argument type is 'unsigned
     long long'.

 -- Built-in Function: int __builtin_clrsbll (long long)
     Similar to '__builtin_clrsb', except the argument type is 'long
     long'.

 -- Built-in Function: int __builtin_popcountll (unsigned long long)
     Similar to '__builtin_popcount', except the argument type is
     'unsigned long long'.

 -- Built-in Function: int __builtin_parityll (unsigned long long)
     Similar to '__builtin_parity', except the argument type is
     'unsigned long long'.

 -- Built-in Function: double __builtin_powi (double, int)
     Returns the first argument raised to the power of the second.
     Unlike the 'pow' function no guarantees about precision and
     rounding are made.

 -- Built-in Function: float __builtin_powif (float, int)
     Similar to '__builtin_powi', except the argument and return types
     are 'float'.

 -- Built-in Function: long double __builtin_powil (long double, int)
     Similar to '__builtin_powi', except the argument and return types
     are 'long double'.

 -- Built-in Function: uint16_t __builtin_bswap16 (uint16_t x)
     Returns X with the order of the bytes reversed; for example,
     '0xaabb' becomes '0xbbaa'.  Byte here always means exactly 8 bits.

 -- Built-in Function: uint32_t __builtin_bswap32 (uint32_t x)
     Similar to '__builtin_bswap16', except the argument and return
     types are 32 bit.

 -- Built-in Function: uint64_t __builtin_bswap64 (uint64_t x)
     Similar to '__builtin_bswap32', except the argument and return
     types are 64 bit.

