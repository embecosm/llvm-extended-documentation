This is llvm.info, produced by makeinfo version 6.0 from llvm.texi.

Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies published by
Embecosm support introducing others to free and open source software and
hardware.
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* llvm: (llvm).                The LLVM compiler
END-INFO-DIR-ENTRY

 This file documents the use of the LLVM compiler.

 Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU software.
Copies published by the Free Software Foundation raise funds for GNU
development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies published by
Embecosm support introducing others to free and open source software and
hardware.


File: llvm.info,  Node: Floating Types,  Next: Half-Precision,  Prev: Complex,  Up: C Extensions

6.11 Additional Floating Types
==============================

As an extension, GNU C supports additional floating types, '__float80'
and '__float128' to support 80-bit ('XFmode') and 128-bit ('TFmode')
floating types.  Support for additional types includes the arithmetic
operators: add, subtract, multiply, divide; unary arithmetic operators;
relational operators; equality operators; and conversions to and from
integer and other floating types.  Use a suffix 'w' or 'W' in a literal
constant of type '__float80' and 'q' or 'Q' for '_float128'.  You can
declare complex types using the corresponding internal complex type,
'XCmode' for '__float80' type and 'TCmode' for '__float128' type:

     typedef _Complex float __attribute__((mode(TC))) _Complex128;
     typedef _Complex float __attribute__((mode(XC))) _Complex80;

 Not all targets support additional floating-point types.  '__float80'
and '__float128' types are supported on x86 and IA-64 targets.  The
'__float128' type is supported on hppa HP-UX targets.


File: llvm.info,  Node: Half-Precision,  Next: Decimal Float,  Prev: Floating Types,  Up: C Extensions

6.12 Half-Precision Floating Point
==================================

On ARM targets, GCC supports half-precision (16-bit) floating point via
the '__fp16' type.  You must enable this type explicitly with the
'-mfp16-format' command-line option in order to use it.

 ARM supports two incompatible representations for half-precision
floating-point values.  You must choose one of the representations and
use it consistently in your program.

 Specifying '-mfp16-format=ieee' selects the IEEE 754-2008 format.  This
format can represent normalized values in the range of 2^{-14} to 65504.
There are 11 bits of significand precision, approximately 3 decimal
digits.

 Specifying '-mfp16-format=alternative' selects the ARM alternative
format.  This representation is similar to the IEEE format, but does not
support infinities or NaNs.  Instead, the range of exponents is
extended, so that this format can represent normalized values in the
range of 2^{-14} to 131008.

 The '__fp16' type is a storage format only.  For purposes of arithmetic
and other operations, '__fp16' values in C or C++ expressions are
automatically promoted to 'float'.  In addition, you cannot declare a
function with a return value or parameters of type '__fp16'.

 Note that conversions from 'double' to '__fp16' involve an intermediate
conversion to 'float'.  Because of rounding, this can sometimes produce
a different result than a direct conversion.

 ARM provides hardware support for conversions between '__fp16' and
'float' values as an extension to VFP and NEON (Advanced SIMD). GCC
generates code using these hardware instructions if you compile with
options to select an FPU that provides them; for example,
'-mfpu=neon-fp16 -mfloat-abi=softfp', in addition to the '-mfp16-format'
option to select a half-precision format.

 Language-level support for the '__fp16' data type is independent of
whether GCC generates code using hardware floating-point instructions.
In cases where hardware support is not specified, GCC implements
conversions between '__fp16' and 'float' values as library calls.


File: llvm.info,  Node: Decimal Float,  Next: Hex Floats,  Prev: Half-Precision,  Up: C Extensions

6.13 Decimal Floating Types
===========================

As an extension, GNU C supports decimal floating types as defined in the
N1312 draft of ISO/IEC WDTR24732.  Support for decimal floating types in
GCC will evolve as the draft technical report changes.  Calling
conventions for any target might also change.  Not all targets support
decimal floating types.

 The decimal floating types are '_Decimal32', '_Decimal64', and
'_Decimal128'.  They use a radix of ten, unlike the floating types
'float', 'double', and 'long double' whose radix is not specified by the
C standard but is usually two.

 Support for decimal floating types includes the arithmetic operators
add, subtract, multiply, divide; unary arithmetic operators; relational
operators; equality operators; and conversions to and from integer and
other floating types.  Use a suffix 'df' or 'DF' in a literal constant
of type '_Decimal32', 'dd' or 'DD' for '_Decimal64', and 'dl' or 'DL'
for '_Decimal128'.

 GCC support of decimal float as specified by the draft technical report
is incomplete:

   * When the value of a decimal floating type cannot be represented in
     the integer type to which it is being converted, the result is
     undefined rather than the result value specified by the draft
     technical report.

   * GCC does not provide the C library functionality associated with
     'math.h', 'fenv.h', 'stdio.h', 'stdlib.h', and 'wchar.h', which
     must come from a separate C library implementation.  Because of
     this the GNU C compiler does not define macro '__STDC_DEC_FP__' to
     indicate that the implementation conforms to the technical report.

 Types '_Decimal32', '_Decimal64', and '_Decimal128' are supported by
the DWARF 2 debug information format.


File: llvm.info,  Node: Hex Floats,  Next: Fixed-Point,  Prev: Decimal Float,  Up: C Extensions

6.14 Hex Floats
===============

ISO C99 supports floating-point numbers written not only in the usual
decimal notation, such as '1.55e1', but also numbers such as '0x1.fp3'
written in hexadecimal format.  As a GNU extension, GCC supports this in
C90 mode (except in some cases when strictly conforming) and in C++.  In
that format the '0x' hex introducer and the 'p' or 'P' exponent field
are mandatory.  The exponent is a decimal number that indicates the
power of 2 by which the significant part is multiplied.  Thus '0x1.f' is
1 15/16, 'p3' multiplies it by 8, and the value of '0x1.fp3' is the same
as '1.55e1'.

 Unlike for floating-point numbers in the decimal notation the exponent
is always required in the hexadecimal notation.  Otherwise the compiler
would not be able to resolve the ambiguity of, e.g., '0x1.f'.  This
could mean '1.0f' or '1.9375' since 'f' is also the extension for
floating-point constants of type 'float'.


File: llvm.info,  Node: Fixed-Point,  Next: Named Address Spaces,  Prev: Hex Floats,  Up: C Extensions

6.15 Fixed-Point Types
======================

As an extension, GNU C supports fixed-point types as defined in the
N1169 draft of ISO/IEC DTR 18037.  Support for fixed-point types in GCC
will evolve as the draft technical report changes.  Calling conventions
for any target might also change.  Not all targets support fixed-point
types.

 The fixed-point types are 'short _Fract', '_Fract', 'long _Fract',
'long long _Fract', 'unsigned short _Fract', 'unsigned _Fract',
'unsigned long _Fract', 'unsigned long long _Fract', '_Sat short
_Fract', '_Sat _Fract', '_Sat long _Fract', '_Sat long long _Fract',
'_Sat unsigned short _Fract', '_Sat unsigned _Fract', '_Sat unsigned
long _Fract', '_Sat unsigned long long _Fract', 'short _Accum',
'_Accum', 'long _Accum', 'long long _Accum', 'unsigned short _Accum',
'unsigned _Accum', 'unsigned long _Accum', 'unsigned long long _Accum',
'_Sat short _Accum', '_Sat _Accum', '_Sat long _Accum', '_Sat long long
_Accum', '_Sat unsigned short _Accum', '_Sat unsigned _Accum', '_Sat
unsigned long _Accum', '_Sat unsigned long long _Accum'.

 Fixed-point data values contain fractional and optional integral parts.
The format of fixed-point data varies and depends on the target machine.

 Support for fixed-point types includes:
   * prefix and postfix increment and decrement operators ('++', '--')
   * unary arithmetic operators ('+', '-', '!')
   * binary arithmetic operators ('+', '-', '*', '/')
   * binary shift operators ('<<', '>>')
   * relational operators ('<', '<=', '>=', '>')
   * equality operators ('==', '!=')
   * assignment operators ('+=', '-=', '*=', '/=', '<<=', '>>=')
   * conversions to and from integer, floating-point, or fixed-point
     types

 Use a suffix in a fixed-point literal constant:
   * 'hr' or 'HR' for 'short _Fract' and '_Sat short _Fract'
   * 'r' or 'R' for '_Fract' and '_Sat _Fract'
   * 'lr' or 'LR' for 'long _Fract' and '_Sat long _Fract'
   * 'llr' or 'LLR' for 'long long _Fract' and '_Sat long long _Fract'
   * 'uhr' or 'UHR' for 'unsigned short _Fract' and '_Sat unsigned short
     _Fract'
   * 'ur' or 'UR' for 'unsigned _Fract' and '_Sat unsigned _Fract'
   * 'ulr' or 'ULR' for 'unsigned long _Fract' and '_Sat unsigned long
     _Fract'
   * 'ullr' or 'ULLR' for 'unsigned long long _Fract' and '_Sat unsigned
     long long _Fract'
   * 'hk' or 'HK' for 'short _Accum' and '_Sat short _Accum'
   * 'k' or 'K' for '_Accum' and '_Sat _Accum'
   * 'lk' or 'LK' for 'long _Accum' and '_Sat long _Accum'
   * 'llk' or 'LLK' for 'long long _Accum' and '_Sat long long _Accum'
   * 'uhk' or 'UHK' for 'unsigned short _Accum' and '_Sat unsigned short
     _Accum'
   * 'uk' or 'UK' for 'unsigned _Accum' and '_Sat unsigned _Accum'
   * 'ulk' or 'ULK' for 'unsigned long _Accum' and '_Sat unsigned long
     _Accum'
   * 'ullk' or 'ULLK' for 'unsigned long long _Accum' and '_Sat unsigned
     long long _Accum'

 GCC support of fixed-point types as specified by the draft technical
report is incomplete:

   * Pragmas to control overflow and rounding behaviors are not
     implemented.

 Fixed-point types are supported by the DWARF 2 debug information
format.


File: llvm.info,  Node: Named Address Spaces,  Next: Zero Length,  Prev: Fixed-Point,  Up: C Extensions

6.16 Named Address Spaces
=========================

As an extension, GNU C supports named address spaces as defined in the
N1275 draft of ISO/IEC DTR 18037.  Support for named address spaces in
GCC will evolve as the draft technical report changes.  Calling
conventions for any target might also change.  At present, only the AVR,
SPU, M32C, and RL78 targets support address spaces other than the
generic address space.

 Address space identifiers may be used exactly like any other C type
qualifier (e.g., 'const' or 'volatile').  See the N1275 document for
more details.

6.16.1 AVR Named Address Spaces
-------------------------------

On the AVR target, there are several address spaces that can be used in
order to put read-only data into the flash memory and access that data
by means of the special instructions 'LPM' or 'ELPM' needed to read from
flash.

 Per default, any data including read-only data is located in RAM (the
generic address space) so that non-generic address spaces are needed to
locate read-only data in flash memory _and_ to generate the right
instructions to access this data without using (inline) assembler code.

'__flash'
     The '__flash' qualifier locates data in the '.progmem.data'
     section.  Data is read using the 'LPM' instruction.  Pointers to
     this address space are 16 bits wide.

'__flash1'
'__flash2'
'__flash3'
'__flash4'
'__flash5'
     These are 16-bit address spaces locating data in section
     '.progmemN.data' where N refers to address space '__flashN'.  The
     compiler sets the 'RAMPZ' segment register appropriately before
     reading data by means of the 'ELPM' instruction.

'__memx'
     This is a 24-bit address space that linearizes flash and RAM: If
     the high bit of the address is set, data is read from RAM using the
     lower two bytes as RAM address.  If the high bit of the address is
     clear, data is read from flash with 'RAMPZ' set according to the
     high byte of the address.  *Note '__builtin_avr_flash_segment': AVR
     Built-in Functions.

     Objects in this address space are located in '.progmemx.data'.

 Example

     char my_read (const __flash char ** p)
     {
         /* p is a pointer to RAM that points to a pointer to flash.
            The first indirection of p reads that flash pointer
            from RAM and the second indirection reads a char from this
            flash address.  */

         return **p;
     }

     /* Locate array[] in flash memory */
     const __flash int array[] = { 3, 5, 7, 11, 13, 17, 19 };

     int i = 1;

     int main (void)
     {
        /* Return 17 by reading from flash memory */
        return array[array[i]];
     }

For each named address space supported by avr-gcc there is an equally
named but uppercase built-in macro defined.  The purpose is to
facilitate testing if respective address space support is available or
not:

     #ifdef __FLASH
     const __flash int var = 1;

     int read_var (void)
     {
         return var;
     }
     #else
     #include <avr/pgmspace.h> /* From AVR-LibC */

     const int var PROGMEM = 1;

     int read_var (void)
     {
         return (int) pgm_read_word (&var);
     }
     #endif /* __FLASH */

Notice that attribute *note 'progmem': AVR Variable Attributes. locates
data in flash but accesses to these data read from generic address
space, i.e. from RAM, so that you need special accessors like
'pgm_read_byte' from AVR-LibC (http://nongnu.org/avr-libc/user-manual/)
together with attribute 'progmem'.

Limitations and caveats

   * Reading across the 64 KiB section boundary of the '__flash' or
     '__flashN' address spaces shows undefined behavior.  The only
     address space that supports reading across the 64 KiB flash segment
     boundaries is '__memx'.

   * If you use one of the '__flashN' address spaces you must arrange
     your linker script to locate the '.progmemN.data' sections
     according to your needs.

   * Any data or pointers to the non-generic address spaces must be
     qualified as 'const', i.e. as read-only data.  This still applies
     if the data in one of these address spaces like software version
     number or calibration lookup table are intended to be changed after
     load time by, say, a boot loader.  In this case the right
     qualification is 'const' 'volatile' so that the compiler must not
     optimize away known values or insert them as immediates into
     operands of instructions.

   * The following code initializes a variable 'pfoo' located in static
     storage with a 24-bit address:
          extern const __memx char foo;
          const __memx void *pfoo = &foo;

     Such code requires at least binutils 2.23, see
     PR13503 (http://sourceware.org/PR13503).

6.16.2 M32C Named Address Spaces
--------------------------------

On the M32C target, with the R8C and M16C CPU variants, variables
qualified with '__far' are accessed using 32-bit addresses in order to
access memory beyond the first 64 Ki bytes.  If '__far' is used with the
M32CM or M32C CPU variants, it has no effect.

6.16.3 RL78 Named Address Spaces
--------------------------------

On the RL78 target, variables qualified with '__far' are accessed with
32-bit pointers (20-bit addresses) rather than the default 16-bit
addresses.  Non-far variables are assumed to appear in the topmost
64 KiB of the address space.

6.16.4 SPU Named Address Spaces
-------------------------------

On the SPU target variables may be declared as belonging to another
address space by qualifying the type with the '__ea' address space
identifier:

     extern int __ea i;

The compiler generates special code to access the variable 'i'.  It may
use runtime library support, or generate special machine instructions to
access that address space.


File: llvm.info,  Node: Zero Length,  Next: Empty Structures,  Prev: Named Address Spaces,  Up: C Extensions

6.17 Arrays of Length Zero
==========================

Zero-length arrays are allowed in GNU C.  They are very useful as the
last element of a structure that is really a header for a
variable-length object:

     struct line {
       int length;
       char contents[0];
     };

     struct line *thisline = (struct line *)
       malloc (sizeof (struct line) + this_length);
     thisline->length = this_length;

 In ISO C90, you would have to give 'contents' a length of 1, which
means either you waste space or complicate the argument to 'malloc'.

 In ISO C99, you would use a "flexible array member", which is slightly
different in syntax and semantics:

   * Flexible array members are written as 'contents[]' without the '0'.

   * Flexible array members have incomplete type, and so the 'sizeof'
     operator may not be applied.  As a quirk of the original
     implementation of zero-length arrays, 'sizeof' evaluates to zero.

   * Flexible array members may only appear as the last member of a
     'struct' that is otherwise non-empty.

   * A structure containing a flexible array member, or a union
     containing such a structure (possibly recursively), may not be a
     member of a structure or an element of an array.  (However, these
     uses are permitted by GCC as extensions.)

 Non-empty initialization of zero-length arrays is treated like any case
where there are more initializer elements than the array holds, in that
a suitable warning about "excess elements in array" is given, and the
excess elements (all of them, in this case) are ignored.

 GCC allows static initialization of flexible array members.  This is
equivalent to defining a new structure containing the original structure
followed by an array of sufficient size to contain the data.  E.g. in
the following, 'f1' is constructed as if it were declared like 'f2'.

     struct f1 {
       int x; int y[];
     } f1 = { 1, { 2, 3, 4 } };

     struct f2 {
       struct f1 f1; int data[3];
     } f2 = { { 1 }, { 2, 3, 4 } };

The convenience of this extension is that 'f1' has the desired type,
eliminating the need to consistently refer to 'f2.f1'.

 This has symmetry with normal static arrays, in that an array of
unknown size is also written with '[]'.

 Of course, this extension only makes sense if the extra data comes at
the end of a top-level object, as otherwise we would be overwriting data
at subsequent offsets.  To avoid undue complication and confusion with
initialization of deeply nested arrays, we simply disallow any non-empty
initialization except when the structure is the top-level object.  For
example:

     struct foo { int x; int y[]; };
     struct bar { struct foo z; };

     struct foo a = { 1, { 2, 3, 4 } };        // Valid.
     struct bar b = { { 1, { 2, 3, 4 } } };    // Invalid.
     struct bar c = { { 1, { } } };            // Valid.
     struct foo d[1] = { { 1, { 2, 3, 4 } } };  // Invalid.


File: llvm.info,  Node: Empty Structures,  Next: Variable Length,  Prev: Zero Length,  Up: C Extensions

6.18 Structures with No Members
===============================

GCC permits a C structure to have no members:

     struct empty {
     };

 The structure has size zero.  In C++, empty structures are part of the
language.  G++ treats empty structures as if they had a single member of
type 'char'.


File: llvm.info,  Node: Variable Length,  Next: Variadic Macros,  Prev: Empty Structures,  Up: C Extensions

6.19 Arrays of Variable Length
==============================

Variable-length automatic arrays are allowed in ISO C99, and as an
extension GCC accepts them in C90 mode and in C++.  These arrays are
declared like any other automatic arrays, but with a length that is not
a constant expression.  The storage is allocated at the point of
declaration and deallocated when the block scope containing the
declaration exits.  For example:

     FILE *
     concat_fopen (char *s1, char *s2, char *mode)
     {
       char str[strlen (s1) + strlen (s2) + 1];
       strcpy (str, s1);
       strcat (str, s2);
       return fopen (str, mode);
     }

 Jumping or breaking out of the scope of the array name deallocates the
storage.  Jumping into the scope is not allowed; you get an error
message for it.

 As an extension, GCC accepts variable-length arrays as a member of a
structure or a union.  For example:

     void
     foo (int n)
     {
       struct S { int x[n]; };
     }

 You can use the function 'alloca' to get an effect much like
variable-length arrays.  The function 'alloca' is available in many
other C implementations (but not in all).  On the other hand,
variable-length arrays are more elegant.

 There are other differences between these two methods.  Space allocated
with 'alloca' exists until the containing _function_ returns.  The space
for a variable-length array is deallocated as soon as the array name's
scope ends.  (If you use both variable-length arrays and 'alloca' in the
same function, deallocation of a variable-length array also deallocates
anything more recently allocated with 'alloca'.)

 You can also use variable-length arrays as arguments to functions:

     struct entry
     tester (int len, char data[len][len])
     {
       /* ... */
     }

 The length of an array is computed once when the storage is allocated
and is remembered for the scope of the array in case you access it with
'sizeof'.

 If you want to pass the array first and the length afterward, you can
use a forward declaration in the parameter list--another GNU extension.

     struct entry
     tester (int len; char data[len][len], int len)
     {
       /* ... */
     }

 The 'int len' before the semicolon is a "parameter forward
declaration", and it serves the purpose of making the name 'len' known
when the declaration of 'data' is parsed.

 You can write any number of such parameter forward declarations in the
parameter list.  They can be separated by commas or semicolons, but the
last one must end with a semicolon, which is followed by the "real"
parameter declarations.  Each forward declaration must match a "real"
declaration in parameter name and data type.  ISO C99 does not support
parameter forward declarations.


File: llvm.info,  Node: Variadic Macros,  Next: Escaped Newlines,  Prev: Variable Length,  Up: C Extensions

6.20 Macros with a Variable Number of Arguments.
================================================

In the ISO C standard of 1999, a macro can be declared to accept a
variable number of arguments much as a function can.  The syntax for
defining the macro is similar to that of a function.  Here is an
example:

     #define debug(format, ...) fprintf (stderr, format, __VA_ARGS__)

Here '...' is a "variable argument".  In the invocation of such a macro,
it represents the zero or more tokens until the closing parenthesis that
ends the invocation, including any commas.  This set of tokens replaces
the identifier '__VA_ARGS__' in the macro body wherever it appears.  See
the CPP manual for more information.

 GCC has long supported variadic macros, and used a different syntax
that allowed you to give a name to the variable arguments just like any
other argument.  Here is an example:

     #define debug(format, args...) fprintf (stderr, format, args)

This is in all ways equivalent to the ISO C example above, but arguably
more readable and descriptive.

 GNU CPP has two further variadic macro extensions, and permits them to
be used with either of the above forms of macro definition.

 In standard C, you are not allowed to leave the variable argument out
entirely; but you are allowed to pass an empty argument.  For example,
this invocation is invalid in ISO C, because there is no comma after the
string:

     debug ("A message")

 GNU CPP permits you to completely omit the variable arguments in this
way.  In the above examples, the compiler would complain, though since
the expansion of the macro still has the extra comma after the format
string.

 To help solve this problem, CPP behaves specially for variable
arguments used with the token paste operator, '##'.  If instead you
write

     #define debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)

and if the variable arguments are omitted or empty, the '##' operator
causes the preprocessor to remove the comma before it.  If you do
provide some variable arguments in your macro invocation, GNU CPP does
not complain about the paste operation and instead places the variable
arguments after the comma.  Just like any other pasted macro argument,
these arguments are not macro expanded.


File: llvm.info,  Node: Escaped Newlines,  Next: Subscripting,  Prev: Variadic Macros,  Up: C Extensions

6.21 Slightly Looser Rules for Escaped Newlines
===============================================

The preprocessor treatment of escaped newlines is more relaxed than that
specified by the C90 standard, which requires the newline to immediately
follow a backslash.  GCC's implementation allows whitespace in the form
of spaces, horizontal and vertical tabs, and form feeds between the
backslash and the subsequent newline.  The preprocessor issues a
warning, but treats it as a valid escaped newline and combines the two
lines to form a single logical line.  This works within comments and
tokens, as well as between tokens.  Comments are _not_ treated as
whitespace for the purposes of this relaxation, since they have not yet
been replaced with spaces.


File: llvm.info,  Node: Subscripting,  Next: Pointer Arith,  Prev: Escaped Newlines,  Up: C Extensions

6.22 Non-Lvalue Arrays May Have Subscripts
==========================================

In ISO C99, arrays that are not lvalues still decay to pointers, and may
be subscripted, although they may not be modified or used after the next
sequence point and the unary '&' operator may not be applied to them.
As an extension, GNU C allows such arrays to be subscripted in C90 mode,
though otherwise they do not decay to pointers outside C99 mode.  For
example, this is valid in GNU C though not valid in C90:

     struct foo {int a[4];};

     struct foo f();

     bar (int index)
     {
       return f().a[index];
     }


File: llvm.info,  Node: Pointer Arith,  Next: Pointers to Arrays,  Prev: Subscripting,  Up: C Extensions

6.23 Arithmetic on 'void'- and Function-Pointers
================================================

In GNU C, addition and subtraction operations are supported on pointers
to 'void' and on pointers to functions.  This is done by treating the
size of a 'void' or of a function as 1.

 A consequence of this is that 'sizeof' is also allowed on 'void' and on
function types, and returns 1.

 The option '-Wpointer-arith' requests a warning if these extensions are
used.


File: llvm.info,  Node: Pointers to Arrays,  Next: Initializers,  Prev: Pointer Arith,  Up: C Extensions

6.24 Pointers to Arrays with Qualifiers Work as Expected
========================================================

In GNU C, pointers to arrays with qualifiers work similar to pointers to
other qualified types.  For example, a value of type 'int (*)[5]' can be
used to initialize a variable of type 'const int (*)[5]'.  These types
are incompatible in ISO C because the 'const' qualifier is formally
attached to the element type of the array and not the array itself.

     extern void
     transpose (int N, int M, double out[M][N], const double in[N][M]);
     double x[3][2];
     double y[2][3];
     ...
     transpose(3, 2, y, x);


File: llvm.info,  Node: Initializers,  Next: Compound Literals,  Prev: Pointers to Arrays,  Up: C Extensions

6.25 Non-Constant Initializers
==============================

As in standard C++ and ISO C99, the elements of an aggregate initializer
for an automatic variable are not required to be constant expressions in
GNU C.  Here is an example of an initializer with run-time varying
elements:

     foo (float f, float g)
     {
       float beat_freqs[2] = { f-g, f+g };
       /* ... */
     }


File: llvm.info,  Node: Compound Literals,  Next: Designated Inits,  Prev: Initializers,  Up: C Extensions

6.26 Compound Literals
======================

ISO C99 supports compound literals.  A compound literal looks like a
cast containing an initializer.  Its value is an object of the type
specified in the cast, containing the elements specified in the
initializer; it is an lvalue.  As an extension, GCC supports compound
literals in C90 mode and in C++, though the semantics are somewhat
different in C++.

 Usually, the specified type is a structure.  Assume that 'struct foo'
and 'structure' are declared as shown:

     struct foo {int a; char b[2];} structure;

Here is an example of constructing a 'struct foo' with a compound
literal:

     structure = ((struct foo) {x + y, 'a', 0});

This is equivalent to writing the following:

     {
       struct foo temp = {x + y, 'a', 0};
       structure = temp;
     }

 You can also construct an array, though this is dangerous in C++, as
explained below.  If all the elements of the compound literal are (made
up of) simple constant expressions, suitable for use in initializers of
objects of static storage duration, then the compound literal can be
coerced to a pointer to its first element and used in such an
initializer, as shown here:

     char **foo = (char *[]) { "x", "y", "z" };

 Compound literals for scalar types and union types are also allowed,
but then the compound literal is equivalent to a cast.

 As a GNU extension, GCC allows initialization of objects with static
storage duration by compound literals (which is not possible in ISO C99,
because the initializer is not a constant).  It is handled as if the
object is initialized only with the bracket enclosed list if the types
of the compound literal and the object match.  The initializer list of
the compound literal must be constant.  If the object being initialized
has array type of unknown size, the size is determined by compound
literal size.

     static struct foo x = (struct foo) {1, 'a', 'b'};
     static int y[] = (int []) {1, 2, 3};
     static int z[] = (int [3]) {1};

The above lines are equivalent to the following:
     static struct foo x = {1, 'a', 'b'};
     static int y[] = {1, 2, 3};
     static int z[] = {1, 0, 0};

 In C, a compound literal designates an unnamed object with static or
automatic storage duration.  In C++, a compound literal designates a
temporary object, which only lives until the end of its full-expression.
As a result, well-defined C code that takes the address of a subobject
of a compound literal can be undefined in C++, so the C++ compiler
rejects the conversion of a temporary array to a pointer.  For instance,
if the array compound literal example above appeared inside a function,
any subsequent use of 'foo' in C++ has undefined behavior because the
lifetime of the array ends after the declaration of 'foo'.

 As an optimization, the C++ compiler sometimes gives array compound
literals longer lifetimes: when the array either appears outside a
function or has const-qualified type.  If 'foo' and its initializer had
elements of 'char *const' type rather than 'char *', or if 'foo' were a
global variable, the array would have static storage duration.  But it
is probably safest just to avoid the use of array compound literals in
code compiled as C++.


File: llvm.info,  Node: Designated Inits,  Next: Case Ranges,  Prev: Compound Literals,  Up: C Extensions

6.27 Designated Initializers
============================

Standard C90 requires the elements of an initializer to appear in a
fixed order, the same as the order of the elements in the array or
structure being initialized.

 In ISO C99 you can give the elements in any order, specifying the array
indices or structure field names they apply to, and GNU C allows this as
an extension in C90 mode as well.  This extension is not implemented in
GNU C++.

 To specify an array index, write '[INDEX] =' before the element value.
For example,

     int a[6] = { [4] = 29, [2] = 15 };

is equivalent to

     int a[6] = { 0, 0, 15, 0, 29, 0 };

The index values must be constant expressions, even if the array being
initialized is automatic.

 An alternative syntax for this that has been obsolete since GCC 2.5 but
GCC still accepts is to write '[INDEX]' before the element value, with
no '='.

 To initialize a range of elements to the same value, write '[FIRST ...
LAST] = VALUE'.  This is a GNU extension.  For example,

     int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };

If the value in it has side-effects, the side-effects happen only once,
not for each initialized field by the range initializer.

Note that the length of the array is the highest value specified plus
one.

 In a structure initializer, specify the name of a field to initialize
with '.FIELDNAME =' before the element value.  For example, given the
following structure,

     struct point { int x, y; };

the following initialization

     struct point p = { .y = yvalue, .x = xvalue };

is equivalent to

     struct point p = { xvalue, yvalue };

 Another syntax that has the same meaning, obsolete since GCC 2.5, is
'FIELDNAME:', as shown here:

     struct point p = { y: yvalue, x: xvalue };

 Omitted field members are implicitly initialized the same as objects
that have static storage duration.

 The '[INDEX]' or '.FIELDNAME' is known as a "designator".  You can also
use a designator (or the obsolete colon syntax) when initializing a
union, to specify which element of the union should be used.  For
example,

     union foo { int i; double d; };

     union foo f = { .d = 4 };

converts 4 to a 'double' to store it in the union using the second
element.  By contrast, casting 4 to type 'union foo' stores it into the
union as the integer 'i', since it is an integer.  (*Note Cast to
Union::.)

 You can combine this technique of naming elements with ordinary C
initialization of successive elements.  Each initializer element that
does not have a designator applies to the next consecutive element of
the array or structure.  For example,

     int a[6] = { [1] = v1, v2, [4] = v4 };

is equivalent to

     int a[6] = { 0, v1, v2, 0, v4, 0 };

 Labeling the elements of an array initializer is especially useful when
the indices are characters or belong to an 'enum' type.  For example:

     int whitespace[256]
       = { [' '] = 1, ['\t'] = 1, ['\h'] = 1,
           ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 };

 You can also write a series of '.FIELDNAME' and '[INDEX]' designators
before an '=' to specify a nested subobject to initialize; the list is
taken relative to the subobject corresponding to the closest surrounding
brace pair.  For example, with the 'struct point' declaration above:

     struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };

If the same field is initialized multiple times, it has the value from
the last initialization.  If any such overridden initialization has
side-effect, it is unspecified whether the side-effect happens or not.
Currently, GCC discards them and issues a warning.


File: llvm.info,  Node: Case Ranges,  Next: Cast to Union,  Prev: Designated Inits,  Up: C Extensions

6.28 Case Ranges
================

You can specify a range of consecutive values in a single 'case' label,
like this:

     case LOW ... HIGH:

This has the same effect as the proper number of individual 'case'
labels, one for each integer value from LOW to HIGH, inclusive.

 This feature is especially useful for ranges of ASCII character codes:

     case 'A' ... 'Z':

 *Be careful:* Write spaces around the '...', for otherwise it may be
parsed wrong when you use it with integer values.  For example, write
this:

     case 1 ... 5:

rather than this:

     case 1...5:


File: llvm.info,  Node: Cast to Union,  Next: Mixed Declarations,  Prev: Case Ranges,  Up: C Extensions

6.29 Cast to a Union Type
=========================

A cast to union type is similar to other casts, except that the type
specified is a union type.  You can specify the type either with 'union
TAG' or with a typedef name.  A cast to union is actually a constructor,
not a cast, and hence does not yield an lvalue like normal casts.
(*Note Compound Literals::.)

 The types that may be cast to the union type are those of the members
of the union.  Thus, given the following union and variables:

     union foo { int i; double d; };
     int x;
     double y;

both 'x' and 'y' can be cast to type 'union foo'.

 Using the cast as the right-hand side of an assignment to a variable of
union type is equivalent to storing in a member of the union:

     union foo u;
     /* ... */
     u = (union foo) x  ==  u.i = x
     u = (union foo) y  ==  u.d = y

 You can also use the union cast as a function argument:

     void hack (union foo);
     /* ... */
     hack ((union foo) x);


File: llvm.info,  Node: Mixed Declarations,  Next: Function Attributes,  Prev: Cast to Union,  Up: C Extensions

6.30 Mixed Declarations and Code
================================

ISO C99 and ISO C++ allow declarations and code to be freely mixed
within compound statements.  As an extension, GNU C also allows this in
C90 mode.  For example, you could do:

     int i;
     /* ... */
     i++;
     int j = i + 2;

 Each identifier is visible from where it is declared until the end of
the enclosing block.


File: llvm.info,  Node: Function Attributes,  Next: Label Attributes,  Prev: Mixed Declarations,  Up: C Extensions

6.31 Declaring Attributes of Functions
======================================

In GNU C, you declare certain things about functions called in your
program which help the compiler optimize function calls and check your
code more carefully.

 The keyword '__attribute__' allows you to specify special attributes
when making a declaration.  This keyword is followed by an attribute
specification inside double parentheses.  The following attributes are
currently defined for functions on all targets: 'aligned', 'alloc_size',
'alloc_align', 'assume_aligned', 'noreturn', 'returns_twice',
'noinline', 'noclone', 'no_icf', 'always_inline', 'flatten', 'pure',
'const', 'nothrow', 'sentinel', 'format', 'format_arg',
'no_instrument_function', 'no_split_stack', 'section', 'constructor',
'destructor', 'used', 'unused', 'deprecated', 'weak', 'malloc', 'alias',
'ifunc', 'warn_unused_result', 'nonnull', 'returns_nonnull',
'gnu_inline', 'externally_visible', 'hot', 'cold', 'artificial',
'no_sanitize_address', 'no_address_safety_analysis',
'no_sanitize_thread', 'no_sanitize_undefined', 'no_reorder',
'bnd_legacy', 'bnd_instrument', 'stack_protect', 'error' and 'warning'.
Several other attributes are defined for functions on particular target
systems.  Other attributes, including 'section' are supported for
variables declarations (*note Variable Attributes::), labels (*note
Label Attributes::) and for types (*note Type Attributes::).

 GCC plugins may provide their own attributes.

 You may also specify attributes with '__' preceding and following each
keyword.  This allows you to use them in header files without being
concerned about a possible macro of the same name.  For example, you may
use '__noreturn__' instead of 'noreturn'.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

'alias ("TARGET")'
     The 'alias' attribute causes the declaration to be emitted as an
     alias for another symbol, which must be specified.  For instance,

          void __f () { /* Do something. */; }
          void f () __attribute__ ((weak, alias ("__f")));

     defines 'f' to be a weak alias for '__f'.  In C++, the mangled name
     for the target must be used.  It is an error if '__f' is not
     defined in the same translation unit.

     Not all target machines support this attribute.

'aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment for the function,
     measured in bytes.

     You cannot use this attribute to decrease the alignment of a
     function, only to increase it.  However, when you explicitly
     specify a function alignment this overrides the effect of the
     '-falign-functions' (*note Optimize Options::) option for this
     function.

     Note that the effectiveness of 'aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for functions to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  See your linker
     documentation for further information.

     The 'aligned' attribute can also be used for variables and fields
     (*note Variable Attributes::.)

'alloc_size'
     The 'alloc_size' attribute is used to tell the compiler that the
     function return value points to memory, where the size is given by
     one or two of the functions parameters.  GCC uses this information
     to improve the correctness of '__builtin_object_size'.

     The function parameter(s) denoting the allocated size are specified
     by one or two integer arguments supplied to the attribute.  The
     allocated size is either the value of the single function argument
     specified or the product of the two function arguments specified.
     Argument numbering starts at one.

     For instance,

          void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))
          void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))

     declares that 'my_calloc' returns memory of the size given by the
     product of parameter 1 and 2 and that 'my_realloc' returns memory
     of the size given by parameter 2.

'alloc_align'
     The 'alloc_align' attribute is used to tell the compiler that the
     function return value points to memory, where the returned pointer
     minimum alignment is given by one of the functions parameters.  GCC
     uses this information to improve pointer alignment analysis.

     The function parameter denoting the allocated alignment is
     specified by one integer argument, whose number is the argument of
     the attribute.  Argument numbering starts at one.

     For instance,

          void* my_memalign(size_t, size_t) __attribute__((alloc_align(1)))

     declares that 'my_memalign' returns memory with minimum alignment
     given by parameter 1.

'assume_aligned'
     The 'assume_aligned' attribute is used to tell the compiler that
     the function return value points to memory, where the returned
     pointer minimum alignment is given by the first argument.  If the
     attribute has two arguments, the second argument is misalignment
     offset.

     For instance

          void* my_alloc1(size_t) __attribute__((assume_aligned(16)))
          void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))

     declares that 'my_alloc1' returns 16-byte aligned pointer and that
     'my_alloc2' returns a pointer whose value modulo 32 is equal to 8.

'always_inline'
     Generally, functions are not inlined unless optimization is
     specified.  For functions declared inline, this attribute inlines
     the function independent of any restrictions that otherwise apply
     to inlining.  Failure to inline such a function is diagnosed as an
     error.  Note that if such a function is called indirectly the
     compiler may or may not inline it depending on optimization level
     and a failure to inline an indirect call may or may not be
     diagnosed.

'gnu_inline'
     This attribute should be used with a function that is also declared
     with the 'inline' keyword.  It directs GCC to treat the function as
     if it were defined in gnu90 mode even when compiling in C99 or
     gnu99 mode.

     If the function is declared 'extern', then this definition of the
     function is used only for inlining.  In no case is the function
     compiled as a standalone function, not even if you take its address
     explicitly.  Such an address becomes an external reference, as if
     you had only declared the function, and had not defined it.  This
     has almost the effect of a macro.  The way to use this is to put a
     function definition in a header file with this attribute, and put
     another copy of the function, without 'extern', in a library file.
     The definition in the header file causes most calls to the function
     to be inlined.  If any uses of the function remain, they refer to
     the single copy in the library.  Note that the two definitions of
     the functions need not be precisely the same, although if they do
     not have the same effect your program may behave oddly.

     In C, if the function is neither 'extern' nor 'static', then the
     function is compiled as a standalone function, as well as being
     inlined where possible.

     This is how GCC traditionally handled functions declared 'inline'.
     Since ISO C99 specifies a different semantics for 'inline', this
     function attribute is provided as a transition measure and as a
     useful feature in its own right.  This attribute is available in
     GCC 4.1.3 and later.  It is available if either of the preprocessor
     macros '__GNUC_GNU_INLINE__' or '__GNUC_STDC_INLINE__' are defined.
     *Note An Inline Function is As Fast As a Macro: Inline.

     In C++, this attribute does not depend on 'extern' in any way, but
     it still requires the 'inline' keyword to enable its special
     behavior.

'artificial'
     This attribute is useful for small inline wrappers that if possible
     should appear during debugging as a unit.  Depending on the debug
     info format it either means marking the function as artificial or
     using the caller location for all instructions within the inlined
     body.

'bank_switch'
     When added to an interrupt handler with the M32C port, causes the
     prologue and epilogue to use bank switching to preserve the
     registers rather than saving them on the stack.

'flatten'
     Generally, inlining into a function is limited.  For a function
     marked with this attribute, every call inside this function is
     inlined, if possible.  Whether the function itself is considered
     for inlining depends on its size and the current inlining
     parameters.

'error ("MESSAGE")'
     If this attribute is used on a function declaration and a call to
     such a function is not eliminated through dead code elimination or
     other optimizations, an error that includes MESSAGE is diagnosed.
     This is useful for compile-time checking, especially together with
     '__builtin_constant_p' and inline functions where checking the
     inline function arguments is not possible through 'extern char
     [(condition) ? 1 : -1];' tricks.  While it is possible to leave the
     function undefined and thus invoke a link failure, when using this
     attribute the problem is diagnosed earlier and with exact location
     of the call even in presence of inline functions or when not
     emitting debugging information.

'warning ("MESSAGE")'
     If this attribute is used on a function declaration and a call to
     such a function is not eliminated through dead code elimination or
     other optimizations, a warning that includes MESSAGE is diagnosed.
     This is useful for compile-time checking, especially together with
     '__builtin_constant_p' and inline functions.  While it is possible
     to define the function with a message in '.gnu.warning*' section,
     when using this attribute the problem is diagnosed earlier and with
     exact location of the call even in presence of inline functions or
     when not emitting debugging information.

'cdecl'
     On the x86-32 targets, the 'cdecl' attribute causes the compiler to
     assume that the calling function pops off the stack space used to
     pass arguments.  This is useful to override the effects of the
     '-mrtd' switch.

'const'
     Many functions do not examine any values except their arguments,
     and have no effects except the return value.  Basically this is
     just slightly more strict class than the 'pure' attribute below,
     since function is not allowed to read global memory.

     Note that a function that has pointer arguments and examines the
     data pointed to must _not_ be declared 'const'.  Likewise, a
     function that calls a non-'const' function usually must not be
     'const'.  It does not make sense for a 'const' function to return
     'void'.

'constructor'
'destructor'
'constructor (PRIORITY)'
'destructor (PRIORITY)'
     The 'constructor' attribute causes the function to be called
     automatically before execution enters 'main ()'.  Similarly, the
     'destructor' attribute causes the function to be called
     automatically after 'main ()' completes or 'exit ()' is called.
     Functions with these attributes are useful for initializing data
     that is used implicitly during the execution of the program.

     You may provide an optional integer priority to control the order
     in which constructor and destructor functions are run.  A
     constructor with a smaller priority number runs before a
     constructor with a larger priority number; the opposite
     relationship holds for destructors.  So, if you have a constructor
     that allocates a resource and a destructor that deallocates the
     same resource, both functions typically have the same priority.
     The priorities for constructor and destructor functions are the
     same as those specified for namespace-scope C++ objects (*note C++
     Attributes::).

     These attributes are not currently implemented for Objective-C.

'deprecated'
'deprecated (MSG)'
     The 'deprecated' attribute results in a warning if the function is
     used anywhere in the source file.  This is useful when identifying
     functions that are expected to be removed in a future version of a
     program.  The warning also includes the location of the declaration
     of the deprecated function, to enable users to easily find further
     information about why the function is deprecated, or what they
     should do instead.  Note that the warnings only occurs for uses:

          int old_fn () __attribute__ ((deprecated));
          int old_fn ();
          int (*fn_ptr)() = old_fn;

     results in a warning on line 3 but not line 2.  The optional MSG
     argument, which must be a string, is printed in the warning if
     present.

     The 'deprecated' attribute can also be used for variables and types
     (*note Variable Attributes::, *note Type Attributes::.)

'disinterrupt'
     On Epiphany and MeP targets, this attribute causes the compiler to
     emit instructions to disable interrupts for the duration of the
     given function.

'dllexport'
     On Microsoft Windows targets and Symbian OS targets the 'dllexport'
     attribute causes the compiler to provide a global pointer to a
     pointer in a DLL, so that it can be referenced with the 'dllimport'
     attribute.  On Microsoft Windows targets, the pointer name is
     formed by combining '_imp__' and the function or variable name.

     You can use '__declspec(dllexport)' as a synonym for '__attribute__
     ((dllexport))' for compatibility with other compilers.

     On systems that support the 'visibility' attribute, this attribute
     also implies "default" visibility.  It is an error to explicitly
     specify any other visibility.

     GCC's default behavior is to emit all inline functions with the
     'dllexport' attribute.  Since this can cause object file-size
     bloat, you can use '-fno-keep-inline-dllexport', which tells GCC to
     ignore the attribute for inlined functions unless the
     '-fkeep-inline-functions' flag is used instead.

     The attribute is ignored for undefined symbols.

     When applied to C++ classes, the attribute marks defined
     non-inlined member functions and static data members as exports.
     Static consts initialized in-class are not marked unless they are
     also defined out-of-class.

     For Microsoft Windows targets there are alternative methods for
     including the symbol in the DLL's export table such as using a
     '.def' file with an 'EXPORTS' section or, with GNU ld, using the
     '--export-all' linker flag.

'dllimport'
     On Microsoft Windows and Symbian OS targets, the 'dllimport'
     attribute causes the compiler to reference a function or variable
     via a global pointer to a pointer that is set up by the DLL
     exporting the symbol.  The attribute implies 'extern'.  On
     Microsoft Windows targets, the pointer name is formed by combining
     '_imp__' and the function or variable name.

     You can use '__declspec(dllimport)' as a synonym for '__attribute__
     ((dllimport))' for compatibility with other compilers.

     On systems that support the 'visibility' attribute, this attribute
     also implies "default" visibility.  It is an error to explicitly
     specify any other visibility.

     Currently, the attribute is ignored for inlined functions.  If the
     attribute is applied to a symbol _definition_, an error is
     reported.  If a symbol previously declared 'dllimport' is later
     defined, the attribute is ignored in subsequent references, and a
     warning is emitted.  The attribute is also overridden by a
     subsequent declaration as 'dllexport'.

     When applied to C++ classes, the attribute marks non-inlined member
     functions and static data members as imports.  However, the
     attribute is ignored for virtual methods to allow creation of
     vtables using thunks.

     On the SH Symbian OS target the 'dllimport' attribute also has
     another affect--it can cause the vtable and run-time type
     information for a class to be exported.  This happens when the
     class has a dllimported constructor or a non-inline, non-pure
     virtual function and, for either of those two conditions, the class
     also has an inline constructor or destructor and has a key function
     that is defined in the current translation unit.

     For Microsoft Windows targets the use of the 'dllimport' attribute
     on functions is not necessary, but provides a small performance
     benefit by eliminating a thunk in the DLL.  The use of the
     'dllimport' attribute on imported variables can be avoided by
     passing the '--enable-auto-import' switch to the GNU linker.  As
     with functions, using the attribute for a variable eliminates a
     thunk in the DLL.

     One drawback to using this attribute is that a pointer to a
     _variable_ marked as 'dllimport' cannot be used as a constant
     address.  However, a pointer to a _function_ with the 'dllimport'
     attribute can be used as a constant initializer; in this case, the
     address of a stub function in the import lib is referenced.  On
     Microsoft Windows targets, the attribute can be disabled for
     functions by setting the '-mnop-fun-dllimport' flag.

'eightbit_data'
     Use this attribute on the H8/300, H8/300H, and H8S to indicate that
     the specified variable should be placed into the eight-bit data
     section.  The compiler generates more efficient code for certain
     operations on data in the eight-bit data area.  Note the eight-bit
     data area is limited to 256 bytes of data.

     You must use GAS and GLD from GNU binutils version 2.7 or later for
     this attribute to work correctly.

'exception'
     Use this attribute on the NDS32 target to indicate that the
     specified function is an exception handler.  The compiler will
     generate corresponding sections for use in an exception handler.

'exception_handler'
     Use this attribute on the Blackfin to indicate that the specified
     function is an exception handler.  The compiler generates function
     entry and exit sequences suitable for use in an exception handler
     when this attribute is present.

'externally_visible'
     This attribute, attached to a global variable or function,
     nullifies the effect of the '-fwhole-program' command-line option,
     so the object remains visible outside the current compilation unit.

     If '-fwhole-program' is used together with '-flto' and 'gold' is
     used as the linker plugin, 'externally_visible' attributes are
     automatically added to functions (not variable yet due to a current
     'gold' issue) that are accessed outside of LTO objects according to
     resolution file produced by 'gold'.  For other linkers that cannot
     generate resolution file, explicit 'externally_visible' attributes
     are still necessary.

'far'
     On 68HC11 and 68HC12 the 'far' attribute causes the compiler to use
     a calling convention that takes care of switching memory banks when
     entering and leaving a function.  This calling convention is also
     the default when using the '-mlong-calls' option.

     On 68HC12 the compiler uses the 'call' and 'rtc' instructions to
     call and return from a function.

     On 68HC11 the compiler generates a sequence of instructions to
     invoke a board-specific routine to switch the memory bank and call
     the real function.  The board-specific routine simulates a 'call'.
     At the end of a function, it jumps to a board-specific routine
     instead of using 'rts'.  The board-specific return routine
     simulates the 'rtc'.

     On MeP targets this causes the compiler to use a calling convention
     that assumes the called function is too far away for the built-in
     addressing modes.

'fast_interrupt'
     Use this attribute on the M32C and RX ports to indicate that the
     specified function is a fast interrupt handler.  This is just like
     the 'interrupt' attribute, except that 'freit' is used to return
     instead of 'reit'.

'fastcall'
     On x86-32 targets, the 'fastcall' attribute causes the compiler to
     pass the first argument (if of integral type) in the register ECX
     and the second argument (if of integral type) in the register EDX.
     Subsequent and other typed arguments are passed on the stack.  The
     called function pops the arguments off the stack.  If the number of
     arguments is variable all arguments are pushed on the stack.

'thiscall'
     On x86-32 targets, the 'thiscall' attribute causes the compiler to
     pass the first argument (if of integral type) in the register ECX.
     Subsequent and other typed arguments are passed on the stack.  The
     called function pops the arguments off the stack.  If the number of
     arguments is variable all arguments are pushed on the stack.  The
     'thiscall' attribute is intended for C++ non-static member
     functions.  As a GCC extension, this calling convention can be used
     for C functions and for static member methods.

'format (ARCHETYPE, STRING-INDEX, FIRST-TO-CHECK)'
     The 'format' attribute specifies that a function takes 'printf',
     'scanf', 'strftime' or 'strfmon' style arguments that should be
     type-checked against a format string.  For example, the
     declaration:

          extern int
          my_printf (void *my_object, const char *my_format, ...)
                __attribute__ ((format (printf, 2, 3)));

     causes the compiler to check the arguments in calls to 'my_printf'
     for consistency with the 'printf' style format string argument
     'my_format'.

     The parameter ARCHETYPE determines how the format string is
     interpreted, and should be 'printf', 'scanf', 'strftime',
     'gnu_printf', 'gnu_scanf', 'gnu_strftime' or 'strfmon'.  (You can
     also use '__printf__', '__scanf__', '__strftime__' or
     '__strfmon__'.)  On MinGW targets, 'ms_printf', 'ms_scanf', and
     'ms_strftime' are also present.  ARCHETYPE values such as 'printf'
     refer to the formats accepted by the system's C runtime library,
     while values prefixed with 'gnu_' always refer to the formats
     accepted by the GNU C Library.  On Microsoft Windows targets,
     values prefixed with 'ms_' refer to the formats accepted by the
     'msvcrt.dll' library.  The parameter STRING-INDEX specifies which
     argument is the format string argument (starting from 1), while
     FIRST-TO-CHECK is the number of the first argument to check against
     the format string.  For functions where the arguments are not
     available to be checked (such as 'vprintf'), specify the third
     parameter as zero.  In this case the compiler only checks the
     format string for consistency.  For 'strftime' formats, the third
     parameter is required to be zero.  Since non-static C++ methods
     have an implicit 'this' argument, the arguments of such methods
     should be counted from two, not one, when giving values for
     STRING-INDEX and FIRST-TO-CHECK.

     In the example above, the format string ('my_format') is the second
     argument of the function 'my_print', and the arguments to check
     start with the third argument, so the correct parameters for the
     format attribute are 2 and 3.

     The 'format' attribute allows you to identify your own functions
     that take format strings as arguments, so that GCC can check the
     calls to these functions for errors.  The compiler always (unless
     '-ffreestanding' or '-fno-builtin' is used) checks formats for the
     standard library functions 'printf', 'fprintf', 'sprintf', 'scanf',
     'fscanf', 'sscanf', 'strftime', 'vprintf', 'vfprintf' and
     'vsprintf' whenever such warnings are requested (using '-Wformat'),
     so there is no need to modify the header file 'stdio.h'.  In C99
     mode, the functions 'snprintf', 'vsnprintf', 'vscanf', 'vfscanf'
     and 'vsscanf' are also checked.  Except in strictly conforming C
     standard modes, the X/Open function 'strfmon' is also checked as
     are 'printf_unlocked' and 'fprintf_unlocked'.  *Note Options
     Controlling C Dialect: C Dialect Options.

     For Objective-C dialects, 'NSString' (or '__NSString__') is
     recognized in the same context.  Declarations including these
     format attributes are parsed for correct syntax, however the result
     of checking of such format strings is not yet defined, and is not
     carried out by this version of the compiler.

     The target may also provide additional types of format checks.
     *Note Format Checks Specific to Particular Target Machines: Target
     Format Checks.

'format_arg (STRING-INDEX)'
     The 'format_arg' attribute specifies that a function takes a format
     string for a 'printf', 'scanf', 'strftime' or 'strfmon' style
     function and modifies it (for example, to translate it into another
     language), so the result can be passed to a 'printf', 'scanf',
     'strftime' or 'strfmon' style function (with the remaining
     arguments to the format function the same as they would have been
     for the unmodified string).  For example, the declaration:

          extern char *
          my_dgettext (char *my_domain, const char *my_format)
                __attribute__ ((format_arg (2)));

     causes the compiler to check the arguments in calls to a 'printf',
     'scanf', 'strftime' or 'strfmon' type function, whose format string
     argument is a call to the 'my_dgettext' function, for consistency
     with the format string argument 'my_format'.  If the 'format_arg'
     attribute had not been specified, all the compiler could tell in
     such calls to format functions would be that the format string
     argument is not constant; this would generate a warning when
     '-Wformat-nonliteral' is used, but the calls could not be checked
     without the attribute.

     The parameter STRING-INDEX specifies which argument is the format
     string argument (starting from one).  Since non-static C++ methods
     have an implicit 'this' argument, the arguments of such methods
     should be counted from two.

     The 'format_arg' attribute allows you to identify your own
     functions that modify format strings, so that GCC can check the
     calls to 'printf', 'scanf', 'strftime' or 'strfmon' type function
     whose operands are a call to one of your own function.  The
     compiler always treats 'gettext', 'dgettext', and 'dcgettext' in
     this manner except when strict ISO C support is requested by
     '-ansi' or an appropriate '-std' option, or '-ffreestanding' or
     '-fno-builtin' is used.  *Note Options Controlling C Dialect: C
     Dialect Options.

     For Objective-C dialects, the 'format-arg' attribute may refer to
     an 'NSString' reference for compatibility with the 'format'
     attribute above.

     The target may also allow additional types in 'format-arg'
     attributes.  *Note Format Checks Specific to Particular Target
     Machines: Target Format Checks.

'function_vector'
     Use this attribute on the H8/300, H8/300H, and H8S to indicate that
     the specified function should be called through the function
     vector.  Calling a function through the function vector reduces
     code size, however; the function vector has a limited size (maximum
     128 entries on the H8/300 and 64 entries on the H8/300H and H8S)
     and shares space with the interrupt vector.

     On SH2A targets, this attribute declares a function to be called
     using the TBR relative addressing mode.  The argument to this
     attribute is the entry number of the same function in a vector
     table containing all the TBR relative addressable functions.  For
     correct operation the TBR must be setup accordingly to point to the
     start of the vector table before any functions with this attribute
     are invoked.  Usually a good place to do the initialization is the
     startup routine.  The TBR relative vector table can have at max 256
     function entries.  The jumps to these functions are generated using
     a SH2A specific, non delayed branch instruction JSR/N @(disp8,TBR).
     You must use GAS and GLD from GNU binutils version 2.7 or later for
     this attribute to work correctly.

     Please refer the example of M16C target, to see the use of this
     attribute while declaring a function,

     In an application, for a function being called once, this attribute
     saves at least 8 bytes of code; and if other successive calls are
     being made to the same function, it saves 2 bytes of code per each
     of these calls.

     On M16C/M32C targets, the 'function_vector' attribute declares a
     special page subroutine call function.  Use of this attribute
     reduces the code size by 2 bytes for each call generated to the
     subroutine.  The argument to the attribute is the vector number
     entry from the special page vector table which contains the 16
     low-order bits of the subroutine's entry address.  Each vector
     table has special page number (18 to 255) that is used in 'jsrs'
     instructions.  Jump addresses of the routines are generated by
     adding 0x0F0000 (in case of M16C targets) or 0xFF0000 (in case of
     M32C targets), to the 2-byte addresses set in the vector table.
     Therefore you need to ensure that all the special page vector
     routines should get mapped within the address range 0x0F0000 to
     0x0FFFFF (for M16C) and 0xFF0000 to 0xFFFFFF (for M32C).

     In the following example 2 bytes are saved for each call to
     function 'foo'.

          void foo (void) __attribute__((function_vector(0x18)));
          void foo (void)
          {
          }

          void bar (void)
          {
              foo();
          }

     If functions are defined in one file and are called in another
     file, then be sure to write this declaration in both files.

     This attribute is ignored for R8C target.

'ifunc ("RESOLVER")'
     The 'ifunc' attribute is used to mark a function as an indirect
     function using the STT_GNU_IFUNC symbol type extension to the ELF
     standard.  This allows the resolution of the symbol value to be
     determined dynamically at load time, and an optimized version of
     the routine can be selected for the particular processor or other
     system characteristics determined then.  To use this attribute,
     first define the implementation functions available, and a resolver
     function that returns a pointer to the selected implementation
     function.  The implementation functions' declarations must match
     the API of the function being implemented, the resolver's
     declaration is be a function returning pointer to void function
     returning void:

          void *my_memcpy (void *dst, const void *src, size_t len)
          {
            ...
          }

          static void (*resolve_memcpy (void)) (void)
          {
            return my_memcpy; // we'll just always select this routine
          }

     The exported header file declaring the function the user calls
     would contain:

          extern void *memcpy (void *, const void *, size_t);

     allowing the user to call this as a regular function, unaware of
     the implementation.  Finally, the indirect function needs to be
     defined in the same translation unit as the resolver function:

          void *memcpy (void *, const void *, size_t)
               __attribute__ ((ifunc ("resolve_memcpy")));

     Indirect functions cannot be weak.  Binutils version 2.20.1 or
     higher and GNU C Library version 2.11.1 are required to use this
     feature.

'interrupt'
     Use this attribute on the ARC, ARM, AVR, CR16, Epiphany, M32C,
     M32R/D, m68k, MeP, MIPS, MSP430, RL78, RX, Visium and Xstormy16
     ports to indicate that the specified function is an interrupt
     handler.  The compiler generates function entry and exit sequences
     suitable for use in an interrupt handler when this attribute is
     present.  With Epiphany targets it may also generate a special
     section with code to initialize the interrupt vector table.

     Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S,
     MicroBlaze, and SH processors can be specified via the
     'interrupt_handler' attribute.

     Note, on the ARC, you must specify the kind of interrupt to be
     handled in a parameter to the interrupt attribute like this:

          void f () __attribute__ ((interrupt ("ilink1")));

     Permissible values for this parameter are: 'ilink1' and 'ilink2'.

     Note, on the AVR, the hardware globally disables interrupts when an
     interrupt is executed.  The first instruction of an interrupt
     handler declared with this attribute is a 'SEI' instruction to
     re-enable interrupts.  See also the 'signal' function attribute
     that does not insert a 'SEI' instruction.  If both 'signal' and
     'interrupt' are specified for the same function, 'signal' is
     silently ignored.

     Note, for the ARM, you can specify the kind of interrupt to be
     handled by adding an optional parameter to the interrupt attribute
     like this:

          void f () __attribute__ ((interrupt ("IRQ")));

     Permissible values for this parameter are: 'IRQ', 'FIQ', 'SWI',
     'ABORT' and 'UNDEF'.

     On ARMv7-M the interrupt type is ignored, and the attribute means
     the function may be called with a word-aligned stack pointer.

     Note, for the MSP430 you can provide an argument to the interrupt
     attribute which specifies a name or number.  If the argument is a
     number it indicates the slot in the interrupt vector table (0 - 31)
     to which this handler should be assigned.  If the argument is a
     name it is treated as a symbolic name for the vector slot.  These
     names should match up with appropriate entries in the linker
     script.  By default the names 'watchdog' for vector 26, 'nmi' for
     vector 30 and 'reset' for vector 31 are recognized.

     You can also use the following function attributes to modify how
     normal functions interact with interrupt functions:

     'critical'
          Critical functions disable interrupts upon entry and restore
          the previous interrupt state upon exit.  Critical functions
          cannot also have the 'naked' or 'reentrant' attributes.  They
          can have the 'interrupt' attribute.

     'reentrant'
          Reentrant functions disable interrupts upon entry and enable
          them upon exit.  Reentrant functions cannot also have the
          'naked' or 'critical' attributes.  They can have the
          'interrupt' attribute.

     'wakeup'
          This attribute only applies to interrupt functions.  It is
          silently ignored if applied to a non-interrupt function.  A
          wakeup interrupt function will rouse the processor from any
          low-power state that it might be in when the function exits.

     On Epiphany targets one or more optional parameters can be added
     like this:

          void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();

     Permissible values for these parameters are: 'reset',
     'software_exception', 'page_miss', 'timer0', 'timer1', 'message',
     'dma0', 'dma1', 'wand' and 'swi'.  Multiple parameters indicate
     that multiple entries in the interrupt vector table should be
     initialized for this function, i.e. for each parameter NAME, a jump
     to the function is emitted in the section ivt_entry_NAME.  The
     parameter(s) may be omitted entirely, in which case no interrupt
     vector table entry is provided.

     Note, on Epiphany targets, interrupts are enabled inside the
     function unless the 'disinterrupt' attribute is also specified.

     On Epiphany targets, you can also use the following attribute to
     modify the behavior of an interrupt handler:
     'forwarder_section'
          The interrupt handler may be in external memory which cannot
          be reached by a branch instruction, so generate a local memory
          trampoline to transfer control.  The single parameter
          identifies the section where the trampoline is placed.

     The following examples are all valid uses of these attributes on
     Epiphany targets:
          void __attribute__ ((interrupt)) universal_handler ();
          void __attribute__ ((interrupt ("dma1"))) dma1_handler ();
          void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();
          void __attribute__ ((interrupt ("timer0"), disinterrupt))
            fast_timer_handler ();
          void __attribute__ ((interrupt ("dma0, dma1"), forwarder_section ("tramp")))
            external_dma_handler ();

     On MIPS targets, you can use the following attributes to modify the
     behavior of an interrupt handler:
     'use_shadow_register_set'
          Assume that the handler uses a shadow register set, instead of
          the main general-purpose registers.

     'keep_interrupts_masked'
          Keep interrupts masked for the whole function.  Without this
          attribute, GCC tries to reenable interrupts for as much of the
          function as it can.

     'use_debug_exception_return'
          Return using the 'deret' instruction.  Interrupt handlers that
          don't have this attribute return using 'eret' instead.

     You can use any combination of these attributes, as shown below:
          void __attribute__ ((interrupt)) v0 ();
          void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();
          void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();
          void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked)) v4 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               use_debug_exception_return)) v5 ();
          void __attribute__ ((interrupt, keep_interrupts_masked,
                               use_debug_exception_return)) v6 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked,
                               use_debug_exception_return)) v7 ();

     On NDS32 target, this attribute is to indicate that the specified
     function is an interrupt handler.  The compiler will generate
     corresponding sections for use in an interrupt handler.  You can
     use the following attributes to modify the behavior:
     'nested'
          This interrupt service routine is interruptible.
     'not_nested'
          This interrupt service routine is not interruptible.
     'nested_ready'
          This interrupt service routine is interruptible after
          'PSW.GIE' (global interrupt enable) is set.  This allows
          interrupt service routine to finish some short critical code
          before enabling interrupts.
     'save_all'
          The system will help save all registers into stack before
          entering interrupt handler.
     'partial_save'
          The system will help save caller registers into stack before
          entering interrupt handler.

     On RL78, use 'brk_interrupt' instead of 'interrupt' for handlers
     intended to be used with the 'BRK' opcode (i.e. those that must end
     with 'RETB' instead of 'RETI').

     On RX targets, you may specify one or more vector numbers as
     arguments to the attribute, as well as naming an alternate table
     name.  Parameters are handled sequentially, so one handler can be
     assigned to multiple entries in multiple tables.  One may also pass
     the magic string '"$default"' which causes the function to be used
     for any unfilled slots in the current table.

     This example shows a simple assignment of a function to one vector
     in the default table (note that preprocessor macros may be used for
     chip-specific symbolic vector names):
          void __attribute__ ((interrupt (5))) txd1_handler ();

     This example assigns a function to two slots in the default table
     (using preprocessor macros defined elsewhere) and makes it the
     default for the 'dct' table:
          void __attribute__ ((interrupt (RXD1_VECT,RXD2_VECT,"dct","$default")))
          	txd1_handler ();

'interrupt_handler'
     Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S, and
     SH to indicate that the specified function is an interrupt handler.
     The compiler generates function entry and exit sequences suitable
     for use in an interrupt handler when this attribute is present.

'interrupt_thread'
     Use this attribute on fido, a subarchitecture of the m68k, to
     indicate that the specified function is an interrupt handler that
     is designed to run as a thread.  The compiler omits generate
     prologue/epilogue sequences and replaces the return instruction
     with a 'sleep' instruction.  This attribute is available only on
     fido.

'isr'
     Use this attribute on ARM to write Interrupt Service Routines.
     This is an alias to the 'interrupt' attribute above.

'kspisusp'
     When used together with 'interrupt_handler', 'exception_handler' or
     'nmi_handler', code is generated to load the stack pointer from the
     USP register in the function prologue.

'l1_text'
     This attribute specifies a function to be placed into L1
     Instruction SRAM.  The function is put into a specific section
     named '.l1.text'.  With '-mfdpic', function calls with a such
     function as the callee or caller uses inlined PLT.

'l2'
     On the Blackfin, this attribute specifies a function to be placed
     into L2 SRAM. The function is put into a specific section named
     '.l1.text'.  With '-mfdpic', callers of such functions use an
     inlined PLT.

'leaf'
     Calls to external functions with this attribute must return to the
     current compilation unit only by return or by exception handling.
     In particular, leaf functions are not allowed to call callback
     function passed to it from the current compilation unit or directly
     call functions exported by the unit or longjmp into the unit.  Leaf
     function might still call functions from other compilation units
     and thus they are not necessarily leaf in the sense that they
     contain no function calls at all.

     The attribute is intended for library functions to improve dataflow
     analysis.  The compiler takes the hint that any data not escaping
     the current compilation unit can not be used or modified by the
     leaf function.  For example, the 'sin' function is a leaf function,
     but 'qsort' is not.

     Note that leaf functions might invoke signals and signal handlers
     might be defined in the current compilation unit and use static
     variables.  The only compliant way to write such a signal handler
     is to declare such variables 'volatile'.

     The attribute has no effect on functions defined within the current
     compilation unit.  This is to allow easy merging of multiple
     compilation units into one, for example, by using the link-time
     optimization.  For this reason the attribute is not allowed on
     types to annotate indirect calls.

'long_call/medium_call/short_call'
     These attributes specify how a particular function is called on
     ARC, ARM and Epiphany - with 'medium_call' being specific to ARC.
     These attributes override the '-mlong-calls' (*note ARM Options::)
     command-line switch and '#pragma long_calls' settings.  For ARM,
     the 'long_call' attribute indicates that the function might be far
     away from the call site and require a different (more expensive)
     calling sequence.  The 'short_call' attribute always places the
     offset to the function from the call site into the 'BL' instruction
     directly.

'longcall/shortcall'
     On the Blackfin, RS/6000 and PowerPC, the 'longcall' attribute
     indicates that the function might be far away from the call site
     and require a different (more expensive) calling sequence.  The
     'shortcall' attribute indicates that the function is always close
     enough for the shorter calling sequence to be used.  These
     attributes override both the '-mlongcall' switch and, on the
     RS/6000 and PowerPC, the '#pragma longcall' setting.

     *Note RS/6000 and PowerPC Options::, for more information on
     whether long calls are necessary.

'long_call/near/far'
     These attributes specify how a particular function is called on
     MIPS.  The attributes override the '-mlong-calls' (*note MIPS
     Options::) command-line switch.  The 'long_call' and 'far'
     attributes are synonyms, and cause the compiler to always call the
     function by first loading its address into a register, and then
     using the contents of that register.  The 'near' attribute has the
     opposite effect; it specifies that non-PIC calls should be made
     using the more efficient 'jal' instruction.

'malloc'
     This tells the compiler that a function is 'malloc'-like, i.e.,
     that the pointer P returned by the function cannot alias any other
     pointer valid when the function returns, and moreover no pointers
     to valid objects occur in any storage addressed by P.

     Using this attribute can improve optimization.  Functions like
     'malloc' and 'calloc' have this property because they return a
     pointer to uninitialized or zeroed-out storage.  However, functions
     like 'realloc' do not have this property, as they can return a
     pointer to storage containing pointers.

'mips16/nomips16'

     On MIPS targets, you can use the 'mips16' and 'nomips16' function
     attributes to locally select or turn off MIPS16 code generation.  A
     function with the 'mips16' attribute is emitted as MIPS16 code,
     while MIPS16 code generation is disabled for functions with the
     'nomips16' attribute.  These attributes override the '-mips16' and
     '-mno-mips16' options on the command line (*note MIPS Options::).

     When compiling files containing mixed MIPS16 and non-MIPS16 code,
     the preprocessor symbol '__mips16' reflects the setting on the
     command line, not that within individual functions.  Mixed MIPS16
     and non-MIPS16 code may interact badly with some GCC extensions
     such as '__builtin_apply' (*note Constructing Calls::).

'micromips/nomicromips'

     On MIPS targets, you can use the 'micromips' and 'nomicromips'
     function attributes to locally select or turn off microMIPS code
     generation.  A function with the 'micromips' attribute is emitted
     as microMIPS code, while microMIPS code generation is disabled for
     functions with the 'nomicromips' attribute.  These attributes
     override the '-mmicromips' and '-mno-micromips' options on the
     command line (*note MIPS Options::).

     When compiling files containing mixed microMIPS and non-microMIPS
     code, the preprocessor symbol '__mips_micromips' reflects the
     setting on the command line, not that within individual functions.
     Mixed microMIPS and non-microMIPS code may interact badly with some
     GCC extensions such as '__builtin_apply' (*note Constructing
     Calls::).

'model (MODEL-NAME)'

     On the M32R/D, use this attribute to set the addressability of an
     object, and of the code generated for a function.  The identifier
     MODEL-NAME is one of 'small', 'medium', or 'large', representing
     each of the code models.

     Small model objects live in the lower 16MB of memory (so that their
     addresses can be loaded with the 'ld24' instruction), and are
     callable with the 'bl' instruction.

     Medium model objects may live anywhere in the 32-bit address space
     (the compiler generates 'seth/add3' instructions to load their
     addresses), and are callable with the 'bl' instruction.

     Large model objects may live anywhere in the 32-bit address space
     (the compiler generates 'seth/add3' instructions to load their
     addresses), and may not be reachable with the 'bl' instruction (the
     compiler generates the much slower 'seth/add3/jl' instruction
     sequence).

     On IA-64, use this attribute to set the addressability of an
     object.  At present, the only supported identifier for MODEL-NAME
     is 'small', indicating addressability via "small" (22-bit)
     addresses (so that their addresses can be loaded with the 'addl'
     instruction).  Caveat: such addressing is by definition not
     position independent and hence this attribute must not be used for
     objects defined by shared libraries.

'ms_abi/sysv_abi'

     On 32-bit and 64-bit x86 targets, you can use an ABI attribute to
     indicate which calling convention should be used for a function.
     The 'ms_abi' attribute tells the compiler to use the Microsoft ABI,
     while the 'sysv_abi' attribute tells the compiler to use the ABI
     used on GNU/Linux and other systems.  The default is to use the
     Microsoft ABI when targeting Windows.  On all other systems, the
     default is the x86/AMD ABI.

     Note, the 'ms_abi' attribute for Microsoft Windows 64-bit targets
     currently requires the '-maccumulate-outgoing-args' option.

'callee_pop_aggregate_return (NUMBER)'

     On x86-32 targets, you can use this attribute to control how
     aggregates are returned in memory.  If the caller is responsible
     for popping the hidden pointer together with the rest of the
     arguments, specify NUMBER equal to zero.  If callee is responsible
     for popping the hidden pointer, specify NUMBER equal to one.

     The default x86-32 ABI assumes that the callee pops the stack for
     hidden pointer.  However, on x86-32 Microsoft Windows targets, the
     compiler assumes that the caller pops the stack for hidden pointer.

'ms_hook_prologue'

     On 32-bit and 64-bit x86 targets, you can use this function
     attribute to make GCC generate the "hot-patching" function prologue
     used in Win32 API functions in Microsoft Windows XP Service Pack 2
     and newer.

'hotpatch (HALFWORDS-BEFORE-FUNCTION-LABEL,HALFWORDS-AFTER-FUNCTION-LABEL)'

     On S/390 System z targets, you can use this function attribute to
     make GCC generate a "hot-patching" function prologue.  If the
     '-mhotpatch=' command-line option is used at the same time, the
     'hotpatch' attribute takes precedence.  The first of the two
     arguments specifies the number of halfwords to be added before the
     function label.  A second argument can be used to specify the
     number of halfwords to be added after the function label.  For both
     arguments the maximum allowed value is 1000000.

     If both arguments are zero, hotpatching is disabled.

'naked'
     This attribute is available on the ARM, AVR, MCORE, MSP430, NDS32,
     RL78, RX and SPU ports.  It allows the compiler to construct the
     requisite function declaration, while allowing the body of the
     function to be assembly code.  The specified function will not have
     prologue/epilogue sequences generated by the compiler.  Only basic
     'asm' statements can safely be included in naked functions (*note
     Basic Asm::).  While using extended 'asm' or a mixture of basic
     'asm' and C code may appear to work, they cannot be depended upon
     to work reliably and are not supported.

'near'
     On 68HC11 and 68HC12 the 'near' attribute causes the compiler to
     use the normal calling convention based on 'jsr' and 'rts'.  This
     attribute can be used to cancel the effect of the '-mlong-calls'
     option.

     On MeP targets this attribute causes the compiler to assume the
     called function is close enough to use the normal calling
     convention, overriding the '-mtf' command-line option.

'nesting'
     Use this attribute together with 'interrupt_handler',
     'exception_handler' or 'nmi_handler' to indicate that the function
     entry code should enable nested interrupts or exceptions.

'nmi_handler'
     Use this attribute on the Blackfin to indicate that the specified
     function is an NMI handler.  The compiler generates function entry
     and exit sequences suitable for use in an NMI handler when this
     attribute is present.

'nocompression'
     On MIPS targets, you can use the 'nocompression' function attribute
     to locally turn off MIPS16 and microMIPS code generation.  This
     attribute overrides the '-mips16' and '-mmicromips' options on the
     command line (*note MIPS Options::).

'no_instrument_function'
     If '-finstrument-functions' is given, profiling function calls are
     generated at entry and exit of most user-compiled functions.
     Functions with this attribute are not so instrumented.

'no_split_stack'
     If '-fsplit-stack' is given, functions have a small prologue which
     decides whether to split the stack.  Functions with the
     'no_split_stack' attribute do not have that prologue, and thus may
     run with only a small amount of stack space available.

'stack_protect'
     This function attribute make a stack protection of the function if
     flags 'fstack-protector' or 'fstack-protector-strong' or
     'fstack-protector-explicit' are set.

'noinline'
     This function attribute prevents a function from being considered
     for inlining.  If the function does not have side-effects, there
     are optimizations other than inlining that cause function calls to
     be optimized away, although the function call is live.  To keep
     such calls from being optimized away, put
          asm ("");

     (*note Extended Asm::) in the called function, to serve as a
     special side-effect.

'noclone'
     This function attribute prevents a function from being considered
     for cloning--a mechanism that produces specialized copies of
     functions and which is (currently) performed by interprocedural
     constant propagation.

'no_icf'
     This function attribute prevents a functions from being merged with
     another semantically equivalent function.

'nonnull (ARG-INDEX, ...)'
     The 'nonnull' attribute specifies that some function parameters
     should be non-null pointers.  For instance, the declaration:

          extern void *
          my_memcpy (void *dest, const void *src, size_t len)
                  __attribute__((nonnull (1, 2)));

     causes the compiler to check that, in calls to 'my_memcpy',
     arguments DEST and SRC are non-null.  If the compiler determines
     that a null pointer is passed in an argument slot marked as
     non-null, and the '-Wnonnull' option is enabled, a warning is
     issued.  The compiler may also choose to make optimizations based
     on the knowledge that certain function arguments will never be
     null.

     If no argument index list is given to the 'nonnull' attribute, all
     pointer arguments are marked as non-null.  To illustrate, the
     following declaration is equivalent to the previous example:

          extern void *
          my_memcpy (void *dest, const void *src, size_t len)
                  __attribute__((nonnull));

'no_reorder'
     Do not reorder functions or variables marked 'no_reorder' against
     each other or top level assembler statements the executable.  The
     actual order in the program will depend on the linker command line.
     Static variables marked like this are also not removed.  This has a
     similar effect as the '-fno-toplevel-reorder' option, but only
     applies to the marked symbols.

'returns_nonnull'
     The 'returns_nonnull' attribute specifies that the function return
     value should be a non-null pointer.  For instance, the declaration:

          extern void *
          mymalloc (size_t len) __attribute__((returns_nonnull));

     lets the compiler optimize callers based on the knowledge that the
     return value will never be null.

'noreturn'
     A few standard library functions, such as 'abort' and 'exit',
     cannot return.  GCC knows this automatically.  Some programs define
     their own functions that never return.  You can declare them
     'noreturn' to tell the compiler this fact.  For example,

          void fatal () __attribute__ ((noreturn));

          void
          fatal (/* ... */)
          {
            /* ... */ /* Print error message. */ /* ... */
            exit (1);
          }

     The 'noreturn' keyword tells the compiler to assume that 'fatal'
     cannot return.  It can then optimize without regard to what would
     happen if 'fatal' ever did return.  This makes slightly better
     code.  More importantly, it helps avoid spurious warnings of
     uninitialized variables.

     The 'noreturn' keyword does not affect the exceptional path when
     that applies: a 'noreturn'-marked function may still return to the
     caller by throwing an exception or calling 'longjmp'.

     Do not assume that registers saved by the calling function are
     restored before calling the 'noreturn' function.

     It does not make sense for a 'noreturn' function to have a return
     type other than 'void'.

'nothrow'
     The 'nothrow' attribute is used to inform the compiler that a
     function cannot throw an exception.  For example, most functions in
     the standard C library can be guaranteed not to throw an exception
     with the notable exceptions of 'qsort' and 'bsearch' that take
     function pointer arguments.

'nosave_low_regs'
     Use this attribute on SH targets to indicate that an
     'interrupt_handler' function should not save and restore registers
     R0..R7.  This can be used on SH3* and SH4* targets that have a
     second R0..R7 register bank for non-reentrant interrupt handlers.

'optimize'
     The 'optimize' attribute is used to specify that a function is to
     be compiled with different optimization options than specified on
     the command line.  Arguments can either be numbers or strings.
     Numbers are assumed to be an optimization level.  Strings that
     begin with 'O' are assumed to be an optimization option, while
     other options are assumed to be used with a '-f' prefix.  You can
     also use the '#pragma GCC optimize' pragma to set the optimization
     options that affect more than one function.  *Note Function
     Specific Option Pragmas::, for details about the '#pragma GCC
     optimize' pragma.

     This can be used for instance to have frequently-executed functions
     compiled with more aggressive optimization options that produce
     faster and larger code, while other functions can be compiled with
     less aggressive options.

'OS_main/OS_task'
     On AVR, functions with the 'OS_main' or 'OS_task' attribute do not
     save/restore any call-saved register in their prologue/epilogue.

     The 'OS_main' attribute can be used when there _is guarantee_ that
     interrupts are disabled at the time when the function is entered.
     This saves resources when the stack pointer has to be changed to
     set up a frame for local variables.

     The 'OS_task' attribute can be used when there is _no guarantee_
     that interrupts are disabled at that time when the function is
     entered like for, e.g.  task functions in a multi-threading
     operating system.  In that case, changing the stack pointer
     register is guarded by save/clear/restore of the global interrupt
     enable flag.

     The differences to the 'naked' function attribute are:
        * 'naked' functions do not have a return instruction whereas
          'OS_main' and 'OS_task' functions have a 'RET' or 'RETI'
          return instruction.
        * 'naked' functions do not set up a frame for local variables or
          a frame pointer whereas 'OS_main' and 'OS_task' do this as
          needed.

'pcs'

     The 'pcs' attribute can be used to control the calling convention
     used for a function on ARM. The attribute takes an argument that
     specifies the calling convention to use.

     When compiling using the AAPCS ABI (or a variant of it) then valid
     values for the argument are '"aapcs"' and '"aapcs-vfp"'.  In order
     to use a variant other than '"aapcs"' then the compiler must be
     permitted to use the appropriate co-processor registers (i.e., the
     VFP registers must be available in order to use '"aapcs-vfp"').
     For example,

          /* Argument passed in r0, and result returned in r0+r1.  */
          double f2d (float) __attribute__((pcs("aapcs")));

     Variadic functions always use the '"aapcs"' calling convention and
     the compiler rejects attempts to specify an alternative.

'pure'
     Many functions have no effects except the return value and their
     return value depends only on the parameters and/or global
     variables.  Such a function can be subject to common subexpression
     elimination and loop optimization just as an arithmetic operator
     would be.  These functions should be declared with the attribute
     'pure'.  For example,

          int square (int) __attribute__ ((pure));

     says that the hypothetical function 'square' is safe to call fewer
     times than the program says.

     Some of common examples of pure functions are 'strlen' or 'memcmp'.
     Interesting non-pure functions are functions with infinite loops or
     those depending on volatile memory or other system resource, that
     may change between two consecutive calls (such as 'feof' in a
     multithreading environment).

'hot'
     The 'hot' attribute on a function is used to inform the compiler
     that the function is a hot spot of the compiled program.  The
     function is optimized more aggressively and on many targets it is
     placed into a special subsection of the text section so all hot
     functions appear close together, improving locality.

     When profile feedback is available, via '-fprofile-use', hot
     functions are automatically detected and this attribute is ignored.

'cold'
     The 'cold' attribute on functions is used to inform the compiler
     that the function is unlikely to be executed.  The function is
     optimized for size rather than speed and on many targets it is
     placed into a special subsection of the text section so all cold
     functions appear close together, improving code locality of
     non-cold parts of program.  The paths leading to calls of cold
     functions within code are marked as unlikely by the branch
     prediction mechanism.  It is thus useful to mark functions used to
     handle unlikely conditions, such as 'perror', as cold to improve
     optimization of hot functions that do call marked functions in rare
     occasions.

     When profile feedback is available, via '-fprofile-use', cold
     functions are automatically detected and this attribute is ignored.

'no_sanitize_address'
'no_address_safety_analysis'
     The 'no_sanitize_address' attribute on functions is used to inform
     the compiler that it should not instrument memory accesses in the
     function when compiling with the '-fsanitize=address' option.  The
     'no_address_safety_analysis' is a deprecated alias of the
     'no_sanitize_address' attribute, new code should use
     'no_sanitize_address'.

'no_sanitize_thread'
     The 'no_sanitize_thread' attribute on functions is used to inform
     the compiler that it should not instrument memory accesses in the
     function when compiling with the '-fsanitize=thread' option.

'no_sanitize_undefined'
     The 'no_sanitize_undefined' attribute on functions is used to
     inform the compiler that it should not check for undefined behavior
     in the function when compiling with the '-fsanitize=undefined'
     option.

'bnd_legacy'
     The 'bnd_legacy' attribute on functions is used to inform compiler
     that function should not be instrumented when compiled with
     '-fcheck-pointer-bounds' option.

'bnd_instrument'
     The 'bnd_instrument' attribute on functions is used to inform
     compiler that function should be instrumented when compiled with
     '-fchkp-instrument-marked-only' option.

'regparm (NUMBER)'
     On x86-32 targets, the 'regparm' attribute causes the compiler to
     pass arguments number one to NUMBER if they are of integral type in
     registers EAX, EDX, and ECX instead of on the stack.  Functions
     that take a variable number of arguments continue to be passed all
     of their arguments on the stack.

     Beware that on some ELF systems this attribute is unsuitable for
     global functions in shared libraries with lazy binding (which is
     the default).  Lazy binding sends the first call via resolving code
     in the loader, which might assume EAX, EDX and ECX can be
     clobbered, as per the standard calling conventions.  Solaris 8 is
     affected by this.  Systems with the GNU C Library version 2.1 or
     higher and FreeBSD are believed to be safe since the loaders there
     save EAX, EDX and ECX. (Lazy binding can be disabled with the
     linker or the loader if desired, to avoid the problem.)

'reset'
     Use this attribute on the NDS32 target to indicate that the
     specified function is a reset handler.  The compiler will generate
     corresponding sections for use in a reset handler.  You can use the
     following attributes to provide extra exception handling:
     'nmi'
          Provide a user-defined function to handle NMI exception.
     'warm'
          Provide a user-defined function to handle warm reset
          exception.

'sseregparm'
     On x86-32 targets with SSE support, the 'sseregparm' attribute
     causes the compiler to pass up to 3 floating-point arguments in SSE
     registers instead of on the stack.  Functions that take a variable
     number of arguments continue to pass all of their floating-point
     arguments on the stack.

'force_align_arg_pointer'
     On x86 targets, the 'force_align_arg_pointer' attribute may be
     applied to individual function definitions, generating an alternate
     prologue and epilogue that realigns the run-time stack if
     necessary.  This supports mixing legacy codes that run with a
     4-byte aligned stack with modern codes that keep a 16-byte stack
     for SSE compatibility.

'renesas'
     On SH targets this attribute specifies that the function or struct
     follows the Renesas ABI.

'resbank'
     On the SH2A target, this attribute enables the high-speed register
     saving and restoration using a register bank for
     'interrupt_handler' routines.  Saving to the bank is performed
     automatically after the CPU accepts an interrupt that uses a
     register bank.

     The nineteen 32-bit registers comprising general register R0 to
     R14, control register GBR, and system registers MACH, MACL, and PR
     and the vector table address offset are saved into a register bank.
     Register banks are stacked in first-in last-out (FILO) sequence.
     Restoration from the bank is executed by issuing a RESBANK
     instruction.

'returns_twice'
     The 'returns_twice' attribute tells the compiler that a function
     may return more than one time.  The compiler ensures that all
     registers are dead before calling such a function and emits a
     warning about the variables that may be clobbered after the second
     return from the function.  Examples of such functions are 'setjmp'
     and 'vfork'.  The 'longjmp'-like counterpart of such function, if
     any, might need to be marked with the 'noreturn' attribute.

'saveall'
     Use this attribute on the Blackfin, H8/300, H8/300H, and H8S to
     indicate that all registers except the stack pointer should be
     saved in the prologue regardless of whether they are used or not.

'save_volatiles'
     Use this attribute on the MicroBlaze to indicate that the function
     is an interrupt handler.  All volatile registers (in addition to
     non-volatile registers) are saved in the function prologue.  If the
     function is a leaf function, only volatiles used by the function
     are saved.  A normal function return is generated instead of a
     return from interrupt.

'break_handler'
     Use this attribute on the MicroBlaze ports to indicate that the
     specified function is an break handler.  The compiler generates
     function entry and exit sequences suitable for use in an break
     handler when this attribute is present.  The return from
     'break_handler' is done through the 'rtbd' instead of 'rtsd'.

          void f () __attribute__ ((break_handler));

'section ("SECTION-NAME")'
     Normally, the compiler places the code it generates in the 'text'
     section.  Sometimes, however, you need additional sections, or you
     need certain particular functions to appear in special sections.
     The 'section' attribute specifies that a function lives in a
     particular section.  For example, the declaration:

          extern void foobar (void) __attribute__ ((section ("bar")));

     puts the function 'foobar' in the 'bar' section.

     Some file formats do not support arbitrary sections so the
     'section' attribute is not available on all platforms.  If you need
     to map the entire contents of a module to a particular section,
     consider using the facilities of the linker instead.

'sentinel'
     This function attribute ensures that a parameter in a function call
     is an explicit 'NULL'.  The attribute is only valid on variadic
     functions.  By default, the sentinel is located at position zero,
     the last parameter of the function call.  If an optional integer
     position argument P is supplied to the attribute, the sentinel must
     be located at position P counting backwards from the end of the
     argument list.

          __attribute__ ((sentinel))
          is equivalent to
          __attribute__ ((sentinel(0)))

     The attribute is automatically set with a position of 0 for the
     built-in functions 'execl' and 'execlp'.  The built-in function
     'execle' has the attribute set with a position of 1.

     A valid 'NULL' in this context is defined as zero with any pointer
     type.  If your system defines the 'NULL' macro with an integer type
     then you need to add an explicit cast.  GCC replaces 'stddef.h'
     with a copy that redefines NULL appropriately.

     The warnings for missing or incorrect sentinels are enabled with
     '-Wformat'.

'short_call'
     See 'long_call/short_call'.

'shortcall'
     See 'longcall/shortcall'.

'signal'
     Use this attribute on the AVR to indicate that the specified
     function is an interrupt handler.  The compiler generates function
     entry and exit sequences suitable for use in an interrupt handler
     when this attribute is present.

     See also the 'interrupt' function attribute.

     The AVR hardware globally disables interrupts when an interrupt is
     executed.  Interrupt handler functions defined with the 'signal'
     attribute do not re-enable interrupts.  It is save to enable
     interrupts in a 'signal' handler.  This "save" only applies to the
     code generated by the compiler and not to the IRQ layout of the
     application which is responsibility of the application.

     If both 'signal' and 'interrupt' are specified for the same
     function, 'signal' is silently ignored.

'sp_switch'
     Use this attribute on the SH to indicate an 'interrupt_handler'
     function should switch to an alternate stack.  It expects a string
     argument that names a global variable holding the address of the
     alternate stack.

          void *alt_stack;
          void f () __attribute__ ((interrupt_handler,
                                    sp_switch ("alt_stack")));

'stdcall'
     On x86-32 targets, the 'stdcall' attribute causes the compiler to
     assume that the called function pops off the stack space used to
     pass arguments, unless it takes a variable number of arguments.

'syscall_linkage'
     This attribute is used to modify the IA-64 calling convention by
     marking all input registers as live at all function exits.  This
     makes it possible to restart a system call after an interrupt
     without having to save/restore the input registers.  This also
     prevents kernel data from leaking into application code.

'target'
     The 'target' attribute is used to specify that a function is to be
     compiled with different target options than specified on the
     command line.  This can be used for instance to have functions
     compiled with a different ISA (instruction set architecture) than
     the default.  You can also use the '#pragma GCC target' pragma to
     set more than one function to be compiled with specific target
     options.  *Note Function Specific Option Pragmas::, for details
     about the '#pragma GCC target' pragma.

     For instance on an x86, you could compile one function with
     'target("sse4.1,arch=core2")' and another with
     'target("sse4a,arch=amdfam10")'.  This is equivalent to compiling
     the first function with '-msse4.1' and '-march=core2' options, and
     the second function with '-msse4a' and '-march=amdfam10' options.
     It is up to the user to make sure that a function is only invoked
     on a machine that supports the particular ISA it is compiled for
     (for example by using 'cpuid' on x86 to determine what feature bits
     and architecture family are used).

          int core2_func (void) __attribute__ ((__target__ ("arch=core2")));
          int sse3_func (void) __attribute__ ((__target__ ("sse3")));

     You can either use multiple strings to specify multiple options, or
     separate the options with a comma (',').

     The 'target' attribute is presently implemented for x86, PowerPC,
     and Nios II targets only.  The options supported are specific to
     each target.

     On the x86, the following options are allowed:

     'abm'
     'no-abm'
          Enable/disable the generation of the advanced bit
          instructions.

     'aes'
     'no-aes'
          Enable/disable the generation of the AES instructions.

     'default'
          *Note Function Multiversioning::, where it is used to specify
          the default function version.

     'mmx'
     'no-mmx'
          Enable/disable the generation of the MMX instructions.

     'pclmul'
     'no-pclmul'
          Enable/disable the generation of the PCLMUL instructions.

     'popcnt'
     'no-popcnt'
          Enable/disable the generation of the POPCNT instruction.

     'sse'
     'no-sse'
          Enable/disable the generation of the SSE instructions.

     'sse2'
     'no-sse2'
          Enable/disable the generation of the SSE2 instructions.

     'sse3'
     'no-sse3'
          Enable/disable the generation of the SSE3 instructions.

     'sse4'
     'no-sse4'
          Enable/disable the generation of the SSE4 instructions (both
          SSE4.1 and SSE4.2).

     'sse4.1'
     'no-sse4.1'
          Enable/disable the generation of the sse4.1 instructions.

     'sse4.2'
     'no-sse4.2'
          Enable/disable the generation of the sse4.2 instructions.

     'sse4a'
     'no-sse4a'
          Enable/disable the generation of the SSE4A instructions.

     'fma4'
     'no-fma4'
          Enable/disable the generation of the FMA4 instructions.

     'xop'
     'no-xop'
          Enable/disable the generation of the XOP instructions.

     'lwp'
     'no-lwp'
          Enable/disable the generation of the LWP instructions.

     'ssse3'
     'no-ssse3'
          Enable/disable the generation of the SSSE3 instructions.

     'cld'
     'no-cld'
          Enable/disable the generation of the CLD before string moves.

     'fancy-math-387'
     'no-fancy-math-387'
          Enable/disable the generation of the 'sin', 'cos', and 'sqrt'
          instructions on the 387 floating-point unit.

     'fused-madd'
     'no-fused-madd'
          Enable/disable the generation of the fused multiply/add
          instructions.

     'ieee-fp'
     'no-ieee-fp'
          Enable/disable the generation of floating point that depends
          on IEEE arithmetic.

     'inline-all-stringops'
     'no-inline-all-stringops'
          Enable/disable inlining of string operations.

     'inline-stringops-dynamically'
     'no-inline-stringops-dynamically'
          Enable/disable the generation of the inline code to do small
          string operations and calling the library routines for large
          operations.

     'align-stringops'
     'no-align-stringops'
          Do/do not align destination of inlined string operations.

     'recip'
     'no-recip'
          Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and
          RSQRTPS instructions followed an additional Newton-Raphson
          step instead of doing a floating-point division.

     'arch=ARCH'
          Specify the architecture to generate code for in compiling the
          function.

     'tune=TUNE'
          Specify the architecture to tune for in compiling the
          function.

     'fpmath=FPMATH'
          Specify which floating-point unit to use.  The
          'target("fpmath=sse,387")' option must be specified as
          'target("fpmath=sse+387")' because the comma would separate
          different options.

     On the PowerPC, the following options are allowed:

     'altivec'
     'no-altivec'
          Generate code that uses (does not use) AltiVec instructions.
          In 32-bit code, you cannot enable AltiVec instructions unless
          '-mabi=altivec' is used on the command line.

     'cmpb'
     'no-cmpb'
          Generate code that uses (does not use) the compare bytes
          instruction implemented on the POWER6 processor and other
          processors that support the PowerPC V2.05 architecture.

     'dlmzb'
     'no-dlmzb'
          Generate code that uses (does not use) the string-search
          'dlmzb' instruction on the IBM 405, 440, 464 and 476
          processors.  This instruction is generated by default when
          targeting those processors.

     'fprnd'
     'no-fprnd'
          Generate code that uses (does not use) the FP round to integer
          instructions implemented on the POWER5+ processor and other
          processors that support the PowerPC V2.03 architecture.

     'hard-dfp'
     'no-hard-dfp'
          Generate code that uses (does not use) the decimal
          floating-point instructions implemented on some POWER
          processors.

     'isel'
     'no-isel'
          Generate code that uses (does not use) ISEL instruction.

     'mfcrf'
     'no-mfcrf'
          Generate code that uses (does not use) the move from condition
          register field instruction implemented on the POWER4 processor
          and other processors that support the PowerPC V2.01
          architecture.

     'mfpgpr'
     'no-mfpgpr'
          Generate code that uses (does not use) the FP move to/from
          general purpose register instructions implemented on the
          POWER6X processor and other processors that support the
          extended PowerPC V2.05 architecture.

     'mulhw'
     'no-mulhw'
          Generate code that uses (does not use) the half-word multiply
          and multiply-accumulate instructions on the IBM 405, 440, 464
          and 476 processors.  These instructions are generated by
          default when targeting those processors.

     'multiple'
     'no-multiple'
          Generate code that uses (does not use) the load multiple word
          instructions and the store multiple word instructions.

     'update'
     'no-update'
          Generate code that uses (does not use) the load or store
          instructions that update the base register to the address of
          the calculated memory location.

     'popcntb'
     'no-popcntb'
          Generate code that uses (does not use) the popcount and
          double-precision FP reciprocal estimate instruction
          implemented on the POWER5 processor and other processors that
          support the PowerPC V2.02 architecture.

     'popcntd'
     'no-popcntd'
          Generate code that uses (does not use) the popcount
          instruction implemented on the POWER7 processor and other
          processors that support the PowerPC V2.06 architecture.

     'powerpc-gfxopt'
     'no-powerpc-gfxopt'
          Generate code that uses (does not use) the optional PowerPC
          architecture instructions in the Graphics group, including
          floating-point select.

     'powerpc-gpopt'
     'no-powerpc-gpopt'
          Generate code that uses (does not use) the optional PowerPC
          architecture instructions in the General Purpose group,
          including floating-point square root.

     'recip-precision'
     'no-recip-precision'
          Assume (do not assume) that the reciprocal estimate
          instructions provide higher-precision estimates than is
          mandated by the powerpc ABI.

     'string'
     'no-string'
          Generate code that uses (does not use) the load string
          instructions and the store string word instructions to save
          multiple registers and do small block moves.

     'vsx'
     'no-vsx'
          Generate code that uses (does not use) vector/scalar (VSX)
          instructions, and also enable the use of built-in functions
          that allow more direct access to the VSX instruction set.  In
          32-bit code, you cannot enable VSX or AltiVec instructions
          unless '-mabi=altivec' is used on the command line.

     'friz'
     'no-friz'
          Generate (do not generate) the 'friz' instruction when the
          '-funsafe-math-optimizations' option is used to optimize
          rounding a floating-point value to 64-bit integer and back to
          floating point.  The 'friz' instruction does not return the
          same value if the floating-point number is too large to fit in
          an integer.

     'avoid-indexed-addresses'
     'no-avoid-indexed-addresses'
          Generate code that tries to avoid (not avoid) the use of
          indexed load or store instructions.

     'paired'
     'no-paired'
          Generate code that uses (does not use) the generation of
          PAIRED simd instructions.

     'longcall'
     'no-longcall'
          Generate code that assumes (does not assume) that all calls
          are far away so that a longer more expensive calling sequence
          is required.

     'cpu=CPU'
          Specify the architecture to generate code for when compiling
          the function.  If you select the 'target("cpu=power7")'
          attribute when generating 32-bit code, VSX and AltiVec
          instructions are not generated unless you use the
          '-mabi=altivec' option on the command line.

     'tune=TUNE'
          Specify the architecture to tune for when compiling the
          function.  If you do not specify the 'target("tune=TUNE")'
          attribute and you do specify the 'target("cpu=CPU")'
          attribute, compilation tunes for the CPU architecture, and not
          the default tuning specified on the command line.

     When compiling for Nios II, the following options are allowed:

     'custom-INSN=N'
     'no-custom-INSN'
          Each 'custom-INSN=N' attribute locally enables use of a custom
          instruction with encoding N when generating code that uses
          INSN.  Similarly, 'no-custom-INSN' locally inhibits use of the
          custom instruction INSN.  These target attributes correspond
          to the '-mcustom-INSN=N' and '-mno-custom-INSN' command-line
          options, and support the same set of INSN keywords.

     'custom-fpu-cfg=NAME'
          This attribute corresponds to the '-mcustom-fpu-cfg=NAME'
          command-line option, to select a predefined set of custom
          instructions named NAME.

     On the x86 and PowerPC back ends, the inliner does not inline a
     function that has different target options than the caller, unless
     the callee has a subset of the target options of the caller.  For
     example a function declared with 'target("sse3")' can inline a
     function with 'target("sse2")', since '-msse3' implies '-msse2'.

'tiny_data'
     Use this attribute on the H8/300H and H8S to indicate that the
     specified variable should be placed into the tiny data section.
     The compiler generates more efficient code for loads and stores on
     data in the tiny data section.  Note the tiny data area is limited
     to slightly under 32KB of data.

'trap_exit'
     Use this attribute on the SH for an 'interrupt_handler' to return
     using 'trapa' instead of 'rte'.  This attribute expects an integer
     argument specifying the trap number to be used.

'trapa_handler'
     On SH targets this function attribute is similar to
     'interrupt_handler' but it does not save and restore all registers.

'unused'
     This attribute, attached to a function, means that the function is
     meant to be possibly unused.  GCC does not produce a warning for
     this function.

'used'
     This attribute, attached to a function, means that code must be
     emitted for the function even if it appears that the function is
     not referenced.  This is useful, for example, when the function is
     referenced only in inline assembly.

     When applied to a member function of a C++ class template, the
     attribute also means that the function is instantiated if the class
     itself is instantiated.

'vector'
     This RX attribute is similar to the 'interrupt' attribute,
     including its parameters, but does not make the function an
     interrupt-handler type function (i.e.  it retains the normal C
     function calling ABI). See the 'interrupt' attribute for a
     description of its arguments.

'version_id'
     This IA-64 HP-UX attribute, attached to a global variable or
     function, renames a symbol to contain a version string, thus
     allowing for function level versioning.  HP-UX system header files
     may use function level versioning for some system calls.

          extern int foo () __attribute__((version_id ("20040821")));

     Calls to FOO are mapped to calls to FOO{20040821}.

'visibility ("VISIBILITY_TYPE")'
     This attribute affects the linkage of the declaration to which it
     is attached.  There are four supported VISIBILITY_TYPE values:
     default, hidden, protected or internal visibility.

          void __attribute__ ((visibility ("protected")))
          f () { /* Do something. */; }
          int i __attribute__ ((visibility ("hidden")));

     The possible values of VISIBILITY_TYPE correspond to the visibility
     settings in the ELF gABI.

     "default"
          Default visibility is the normal case for the object file
          format.  This value is available for the visibility attribute
          to override other options that may change the assumed
          visibility of entities.

          On ELF, default visibility means that the declaration is
          visible to other modules and, in shared libraries, means that
          the declared entity may be overridden.

          On Darwin, default visibility means that the declaration is
          visible to other modules.

          Default visibility corresponds to "external linkage" in the
          language.

     "hidden"
          Hidden visibility indicates that the entity declared has a new
          form of linkage, which we call "hidden linkage".  Two
          declarations of an object with hidden linkage refer to the
          same object if they are in the same shared object.

     "internal"
          Internal visibility is like hidden visibility, but with
          additional processor specific semantics.  Unless otherwise
          specified by the psABI, GCC defines internal visibility to
          mean that a function is _never_ called from another module.
          Compare this with hidden functions which, while they cannot be
          referenced directly by other modules, can be referenced
          indirectly via function pointers.  By indicating that a
          function cannot be called from outside the module, GCC may for
          instance omit the load of a PIC register since it is known
          that the calling function loaded the correct value.

     "protected"
          Protected visibility is like default visibility except that it
          indicates that references within the defining module bind to
          the definition in that module.  That is, the declared entity
          cannot be overridden by another module.

     All visibilities are supported on many, but not all, ELF targets
     (supported when the assembler supports the '.visibility'
     pseudo-op).  Default visibility is supported everywhere.  Hidden
     visibility is supported on Darwin targets.

     The visibility attribute should be applied only to declarations
     that would otherwise have external linkage.  The attribute should
     be applied consistently, so that the same entity should not be
     declared with different settings of the attribute.

     In C++, the visibility attribute applies to types as well as
     functions and objects, because in C++ types have linkage.  A class
     must not have greater visibility than its non-static data member
     types and bases, and class members default to the visibility of
     their class.  Also, a declaration without explicit visibility is
     limited to the visibility of its type.

     In C++, you can mark member functions and static member variables
     of a class with the visibility attribute.  This is useful if you
     know a particular method or static member variable should only be
     used from one shared object; then you can mark it hidden while the
     rest of the class has default visibility.  Care must be taken to
     avoid breaking the One Definition Rule; for example, it is usually
     not useful to mark an inline method as hidden without marking the
     whole class as hidden.

     A C++ namespace declaration can also have the visibility attribute.

          namespace nspace1 __attribute__ ((visibility ("protected")))
          { /* Do something. */; }

     This attribute applies only to the particular namespace body, not
     to other definitions of the same namespace; it is equivalent to
     using '#pragma GCC visibility' before and after the namespace
     definition (*note Visibility Pragmas::).

     In C++, if a template argument has limited visibility, this
     restriction is implicitly propagated to the template instantiation.
     Otherwise, template instantiations and specializations default to
     the visibility of their template.

     If both the template and enclosing class have explicit visibility,
     the visibility from the template is used.

'vliw'
     On MeP, the 'vliw' attribute tells the compiler to emit
     instructions in VLIW mode instead of core mode.  Note that this
     attribute is not allowed unless a VLIW coprocessor has been
     configured and enabled through command-line options.

'warn_unused_result'
     The 'warn_unused_result' attribute causes a warning to be emitted
     if a caller of the function with this attribute does not use its
     return value.  This is useful for functions where not checking the
     result is either a security problem or always a bug, such as
     'realloc'.

          int fn () __attribute__ ((warn_unused_result));
          int foo ()
          {
            if (fn () < 0) return -1;
            fn ();
            return 0;
          }

     results in warning on line 5.

'weak'
     The 'weak' attribute causes the declaration to be emitted as a weak
     symbol rather than a global.  This is primarily useful in defining
     library functions that can be overridden in user code, though it
     can also be used with non-function declarations.  Weak symbols are
     supported for ELF targets, and also for a.out targets when using
     the GNU assembler and linker.

'weakref'
'weakref ("TARGET")'
     The 'weakref' attribute marks a declaration as a weak reference.
     Without arguments, it should be accompanied by an 'alias' attribute
     naming the target symbol.  Optionally, the TARGET may be given as
     an argument to 'weakref' itself.  In either case, 'weakref'
     implicitly marks the declaration as 'weak'.  Without a TARGET,
     given as an argument to 'weakref' or to 'alias', 'weakref' is
     equivalent to 'weak'.

          static int x() __attribute__ ((weakref ("y")));
          /* is equivalent to... */
          static int x() __attribute__ ((weak, weakref, alias ("y")));
          /* and to... */
          static int x() __attribute__ ((weakref));
          static int x() __attribute__ ((alias ("y")));

     A weak reference is an alias that does not by itself require a
     definition to be given for the target symbol.  If the target symbol
     is only referenced through weak references, then it becomes a
     'weak' undefined symbol.  If it is directly referenced, however,
     then such strong references prevail, and a definition is required
     for the symbol, not necessarily in the same translation unit.

     The effect is equivalent to moving all references to the alias to a
     separate translation unit, renaming the alias to the aliased
     symbol, declaring it as weak, compiling the two separate
     translation units and performing a reloadable link on them.

     At present, a declaration to which 'weakref' is attached can only
     be 'static'.

 You can specify multiple attributes in a declaration by separating them
by commas within the double parentheses or by immediately following an
attribute declaration with another attribute declaration.

 Some people object to the '__attribute__' feature, suggesting that ISO
C's '#pragma' should be used instead.  At the time '__attribute__' was
designed, there were two reasons for not doing this.

  1. It is impossible to generate '#pragma' commands from a macro.

  2. There is no telling what the same '#pragma' might mean in another
     compiler.

 These two reasons applied to almost any application that might have
been proposed for '#pragma'.  It was basically a mistake to use
'#pragma' for _anything_.

 The ISO C99 standard includes '_Pragma', which now allows pragmas to be
generated from macros.  In addition, a '#pragma GCC' namespace is now in
use for GCC-specific pragmas.  However, it has been found convenient to
use '__attribute__' to achieve a natural attachment of attributes to
their corresponding declarations, whereas '#pragma GCC' is of use for
constructs that do not naturally form part of the grammar.  *Note
Pragmas Accepted by GCC: Pragmas.


File: llvm.info,  Node: Label Attributes,  Next: Attribute Syntax,  Prev: Function Attributes,  Up: C Extensions

6.32 Label Attributes
=====================

GCC allows attributes to be set on C labels.  *Note Attribute Syntax::,
for details of the exact syntax for using attributes.  Other attributes
are available for functions (*note Function Attributes::), variables
(*note Variable Attributes::) and for types (*note Type Attributes::).

 This example uses the 'cold' label attribute to indicate the
'ErrorHandling' branch is unlikely to be taken and that the
'ErrorHandling' label is unused:


        asm goto ("some asm" : : : : NoError);

     /* This branch (the fall-through from the asm) is less commonly used */
     ErrorHandling:
        __attribute__((cold, unused)); /* Semi-colon is required here */
        printf("error\n");
        return 0;

     NoError:
        printf("no error\n");
        return 1;

'unused'
     This feature is intended for program-generated code that may
     contain unused labels, but which is compiled with '-Wall'.  It is
     not normally appropriate to use in it human-written code, though it
     could be useful in cases where the code that jumps to the label is
     contained within an '#ifdef' conditional.

'hot'
     The 'hot' attribute on a label is used to inform the compiler that
     the path following the label is more likely than paths that are not
     so annotated.  This attribute is used in cases where
     '__builtin_expect' cannot be used, for instance with computed goto
     or 'asm goto'.

'cold'
     The 'cold' attribute on labels is used to inform the compiler that
     the path following the label is unlikely to be executed.  This
     attribute is used in cases where '__builtin_expect' cannot be used,
     for instance with computed goto or 'asm goto'.


File: llvm.info,  Node: Attribute Syntax,  Next: Function Prototypes,  Prev: Label Attributes,  Up: C Extensions

6.33 Attribute Syntax
=====================

This section describes the syntax with which '__attribute__' may be
used, and the constructs to which attribute specifiers bind, for the C
language.  Some details may vary for C++ and Objective-C.  Because of
infelicities in the grammar for attributes, some forms described here
may not be successfully parsed in all cases.

 There are some problems with the semantics of attributes in C++.  For
example, there are no manglings for attributes, although they may affect
code generation, so problems may arise when attributed types are used in
conjunction with templates or overloading.  Similarly, 'typeid' does not
distinguish between types with different attributes.  Support for
attributes in C++ may be restricted in future to attributes on
declarations only, but not on nested declarators.

 *Note Function Attributes::, for details of the semantics of attributes
applying to functions.  *Note Variable Attributes::, for details of the
semantics of attributes applying to variables.  *Note Type Attributes::,
for details of the semantics of attributes applying to structure, union
and enumerated types.  *Note Label Attributes::, for details of the
semantics of attributes applying to labels.

 An "attribute specifier" is of the form '__attribute__
((ATTRIBUTE-LIST))'.  An "attribute list" is a possibly empty
comma-separated sequence of "attributes", where each attribute is one of
the following:

   * Empty.  Empty attributes are ignored.

   * A word (which may be an identifier such as 'unused', or a reserved
     word such as 'const').

   * A word, followed by, in parentheses, parameters for the attribute.
     These parameters take one of the following forms:

        * An identifier.  For example, 'mode' attributes use this form.

        * An identifier followed by a comma and a non-empty
          comma-separated list of expressions.  For example, 'format'
          attributes use this form.

        * A possibly empty comma-separated list of expressions.  For
          example, 'format_arg' attributes use this form with the list
          being a single integer constant expression, and 'alias'
          attributes use this form with the list being a single string
          constant.

 An "attribute specifier list" is a sequence of one or more attribute
specifiers, not separated by any other tokens.

Label Attributes
................

In GNU C, an attribute specifier list may appear after the colon
following a label, other than a 'case' or 'default' label.  GNU C++ only
permits attributes on labels if the attribute specifier is immediately
followed by a semicolon (i.e., the label applies to an empty statement).
If the semicolon is missing, C++ label attributes are ambiguous, as it
is permissible for a declaration, which could begin with an attribute
list, to be labelled in C++.  Declarations cannot be labelled in C90 or
C99, so the ambiguity does not arise there.

Type Attributes
...............

An attribute specifier list may appear as part of a 'struct', 'union' or
'enum' specifier.  It may go either immediately after the 'struct',
'union' or 'enum' keyword, or after the closing brace.  The former
syntax is preferred.  Where attribute specifiers follow the closing
brace, they are considered to relate to the structure, union or
enumerated type defined, not to any enclosing declaration the type
specifier appears in, and the type defined is not complete until after
the attribute specifiers.

All other attributes
....................

Otherwise, an attribute specifier appears as part of a declaration,
counting declarations of unnamed parameters and type names, and relates
to that declaration (which may be nested in another declaration, for
example in the case of a parameter declaration), or to a particular
declarator within a declaration.  Where an attribute specifier is
applied to a parameter declared as a function or an array, it should
apply to the function or array rather than the pointer to which the
parameter is implicitly converted, but this is not yet correctly
implemented.

 Any list of specifiers and qualifiers at the start of a declaration may
contain attribute specifiers, whether or not such a list may in that
context contain storage class specifiers.  (Some attributes, however,
are essentially in the nature of storage class specifiers, and only make
sense where storage class specifiers may be used; for example,
'section'.)  There is one necessary limitation to this syntax: the first
old-style parameter declaration in a function definition cannot begin
with an attribute specifier, because such an attribute applies to the
function instead by syntax described below (which, however, is not yet
implemented in this case).  In some other cases, attribute specifiers
are permitted by this grammar but not yet supported by the compiler.
All attribute specifiers in this place relate to the declaration as a
whole.  In the obsolescent usage where a type of 'int' is implied by the
absence of type specifiers, such a list of specifiers and qualifiers may
be an attribute specifier list with no other specifiers or qualifiers.

 At present, the first parameter in a function prototype must have some
type specifier that is not an attribute specifier; this resolves an
ambiguity in the interpretation of 'void f(int (__attribute__((foo))
x))', but is subject to change.  At present, if the parentheses of a
function declarator contain only attributes then those attributes are
ignored, rather than yielding an error or warning or implying a single
parameter of type int, but this is subject to change.

 An attribute specifier list may appear immediately before a declarator
(other than the first) in a comma-separated list of declarators in a
declaration of more than one identifier using a single list of
specifiers and qualifiers.  Such attribute specifiers apply only to the
identifier before whose declarator they appear.  For example, in

     __attribute__((noreturn)) void d0 (void),
         __attribute__((format(printf, 1, 2))) d1 (const char *, ...),
          d2 (void)

the 'noreturn' attribute applies to all the functions declared; the
'format' attribute only applies to 'd1'.

 An attribute specifier list may appear immediately before the comma,
'=' or semicolon terminating the declaration of an identifier other than
a function definition.  Such attribute specifiers apply to the declared
object or function.  Where an assembler name for an object or function
is specified (*note Asm Labels::), the attribute must follow the 'asm'
specification.

 An attribute specifier list may, in future, be permitted to appear
after the declarator in a function definition (before any old-style
parameter declarations or the function body).

 Attribute specifiers may be mixed with type qualifiers appearing inside
the '[]' of a parameter array declarator, in the C99 construct by which
such qualifiers are applied to the pointer to which the array is
implicitly converted.  Such attribute specifiers apply to the pointer,
not to the array, but at present this is not implemented and they are
ignored.

 An attribute specifier list may appear at the start of a nested
declarator.  At present, there are some limitations in this usage: the
attributes correctly apply to the declarator, but for most individual
attributes the semantics this implies are not implemented.  When
attribute specifiers follow the '*' of a pointer declarator, they may be
mixed with any type qualifiers present.  The following describes the
formal semantics of this syntax.  It makes the most sense if you are
familiar with the formal specification of declarators in the ISO C
standard.

 Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration 'T D1',
where 'T' contains declaration specifiers that specify a type TYPE (such
as 'int') and 'D1' is a declarator that contains an identifier IDENT.
The type specified for IDENT for derived declarators whose type does not
include an attribute specifier is as in the ISO C standard.

 If 'D1' has the form '( ATTRIBUTE-SPECIFIER-LIST D )', and the
declaration 'T D' specifies the type "DERIVED-DECLARATOR-TYPE-LIST TYPE"
for IDENT, then 'T D1' specifies the type "DERIVED-DECLARATOR-TYPE-LIST
ATTRIBUTE-SPECIFIER-LIST TYPE" for IDENT.

 If 'D1' has the form '* TYPE-QUALIFIER-AND-ATTRIBUTE-SPECIFIER-LIST D',
and the declaration 'T D' specifies the type
"DERIVED-DECLARATOR-TYPE-LIST TYPE" for IDENT, then 'T D1' specifies the
type "DERIVED-DECLARATOR-TYPE-LIST
TYPE-QUALIFIER-AND-ATTRIBUTE-SPECIFIER-LIST pointer to TYPE" for IDENT.

 For example,

     void (__attribute__((noreturn)) ****f) (void);

specifies the type "pointer to pointer to pointer to pointer to
non-returning function returning 'void'".  As another example,

     char *__attribute__((aligned(8))) *f;

specifies the type "pointer to 8-byte-aligned pointer to 'char'".  Note
again that this does not work with most attributes; for example, the
usage of 'aligned' and 'noreturn' attributes given above is not yet
supported.

 For compatibility with existing code written for compiler versions that
did not implement attributes on nested declarators, some laxity is
allowed in the placing of attributes.  If an attribute that only applies
to types is applied to a declaration, it is treated as applying to the
type of that declaration.  If an attribute that only applies to
declarations is applied to the type of a declaration, it is treated as
applying to that declaration; and, for compatibility with code placing
the attributes immediately before the identifier declared, such an
attribute applied to a function return type is treated as applying to
the function type, and such an attribute applied to an array element
type is treated as applying to the array type.  If an attribute that
only applies to function types is applied to a pointer-to-function type,
it is treated as applying to the pointer target type; if such an
attribute is applied to a function return type that is not a
pointer-to-function type, it is treated as applying to the function
type.


File: llvm.info,  Node: Function Prototypes,  Next: C++ Comments,  Prev: Attribute Syntax,  Up: C Extensions

6.34 Prototypes and Old-Style Function Definitions
==================================================

GNU C extends ISO C to allow a function prototype to override a later
old-style non-prototype definition.  Consider the following example:

     /* Use prototypes unless the compiler is old-fashioned.  */
     #ifdef __STDC__
     #define P(x) x
     #else
     #define P(x) ()
     #endif

     /* Prototype function declaration.  */
     int isroot P((uid_t));

     /* Old-style function definition.  */
     int
     isroot (x)   /* ??? lossage here ??? */
          uid_t x;
     {
       return x == 0;
     }

 Suppose the type 'uid_t' happens to be 'short'.  ISO C does not allow
this example, because subword arguments in old-style non-prototype
definitions are promoted.  Therefore in this example the function
definition's argument is really an 'int', which does not match the
prototype argument type of 'short'.

 This restriction of ISO C makes it hard to write code that is portable
to traditional C compilers, because the programmer does not know whether
the 'uid_t' type is 'short', 'int', or 'long'.  Therefore, in cases like
these GNU C allows a prototype to override a later old-style definition.
More precisely, in GNU C, a function prototype argument type overrides
the argument type specified by a later old-style definition if the
former type is the same as the latter type before promotion.  Thus in
GNU C the above example is equivalent to the following:

     int isroot (uid_t);

     int
     isroot (uid_t x)
     {
       return x == 0;
     }

GNU C++ does not support old-style function definitions, so this
extension is irrelevant.


File: llvm.info,  Node: C++ Comments,  Next: Dollar Signs,  Prev: Function Prototypes,  Up: C Extensions

6.35 C++ Style Comments
=======================

In GNU C, you may use C++ style comments, which start with '//' and
continue until the end of the line.  Many other C implementations allow
such comments, and they are included in the 1999 C standard.  However,
C++ style comments are not recognized if you specify an '-std' option
specifying a version of ISO C before C99, or '-ansi' (equivalent to
'-std=c90').


File: llvm.info,  Node: Dollar Signs,  Next: Character Escapes,  Prev: C++ Comments,  Up: C Extensions

6.36 Dollar Signs in Identifier Names
=====================================

In GNU C, you may normally use dollar signs in identifier names.  This
is because many traditional C implementations allow such identifiers.
However, dollar signs in identifiers are not supported on a few target
machines, typically because the target assembler does not allow them.


File: llvm.info,  Node: Character Escapes,  Next: Variable Attributes,  Prev: Dollar Signs,  Up: C Extensions

6.37 The Character <ESC> in Constants
=====================================

You can use the sequence '\e' in a string or character constant to stand
for the ASCII character <ESC>.


File: llvm.info,  Node: Variable Attributes,  Next: Type Attributes,  Prev: Character Escapes,  Up: C Extensions

6.38 Specifying Attributes of Variables
=======================================

The keyword '__attribute__' allows you to specify special attributes of
variables or structure fields.  This keyword is followed by an attribute
specification inside double parentheses.  Some attributes are currently
defined generically for variables.  Other attributes are defined for
variables on particular target systems.  Other attributes are available
for functions (*note Function Attributes::), labels (*note Label
Attributes::) and for types (*note Type Attributes::).  Other front ends
might define more attributes (*note Extensions to the C++ Language: C++
Extensions.).

 You may also specify attributes with '__' preceding and following each
keyword.  This allows you to use them in header files without being
concerned about a possible macro of the same name.  For example, you may
use '__aligned__' instead of 'aligned'.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

'aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment for the variable or
     structure field, measured in bytes.  For example, the declaration:

          int x __attribute__ ((aligned (16))) = 0;

     causes the compiler to allocate the global variable 'x' on a
     16-byte boundary.  On a 68040, this could be used in conjunction
     with an 'asm' expression to access the 'move16' instruction which
     requires 16-byte aligned operands.

     You can also specify the alignment of structure fields.  For
     example, to create a double-word aligned 'int' pair, you could
     write:

          struct foo { int x[2] __attribute__ ((aligned (8))); };

     This is an alternative to creating a union with a 'double' member,
     which forces the union to be double-word aligned.

     As in the preceding examples, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     variable or structure field.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a variable or
     field to the default alignment for the target architecture you are
     compiling for.  The default alignment is sufficient for all scalar
     types, but may not be enough for all vector types on a target that
     supports vector operations.  The default alignment is fixed for a
     particular target ABI.

     GCC also provides a target specific macro '__BIGGEST_ALIGNMENT__',
     which is the largest alignment ever used for any data type on the
     target machine you are compiling for.  For example, you could
     write:

          short array[3] __attribute__ ((aligned (__BIGGEST_ALIGNMENT__)));

     The compiler automatically sets the alignment for the declared
     variable or field to '__BIGGEST_ALIGNMENT__'.  Doing this can often
     make copy operations more efficient, because the compiler can use
     whatever instructions copy the biggest chunks of memory when
     performing copies to or from the variables or fields that you have
     aligned this way.  Note that the value of '__BIGGEST_ALIGNMENT__'
     may change depending on command-line options.

     When used on a struct, or struct member, the 'aligned' attribute
     can only increase the alignment; in order to decrease it, the
     'packed' attribute must be specified as well.  When used as part of
     a typedef, the 'aligned' attribute can both increase and decrease
     alignment, and specifying the 'packed' attribute generates a
     warning.

     Note that the effectiveness of 'aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8-byte alignment,
     then specifying 'aligned(16)' in an '__attribute__' still only
     provides you with 8-byte alignment.  See your linker documentation
     for further information.

     The 'aligned' attribute can also be used for functions (*note
     Function Attributes::.)

'cleanup (CLEANUP_FUNCTION)'
     The 'cleanup' attribute runs a function when the variable goes out
     of scope.  This attribute can only be applied to auto function
     scope variables; it may not be applied to parameters or variables
     with static storage duration.  The function must take one
     parameter, a pointer to a type compatible with the variable.  The
     return value of the function (if any) is ignored.

     If '-fexceptions' is enabled, then CLEANUP_FUNCTION is run during
     the stack unwinding that happens during the processing of the
     exception.  Note that the 'cleanup' attribute does not allow the
     exception to be caught, only to perform an action.  It is undefined
     what happens if CLEANUP_FUNCTION does not return normally.

'common'
'nocommon'
     The 'common' attribute requests GCC to place a variable in "common"
     storage.  The 'nocommon' attribute requests the opposite--to
     allocate space for it directly.

     These attributes override the default chosen by the '-fno-common'
     and '-fcommon' flags respectively.

'deprecated'
'deprecated (MSG)'
     The 'deprecated' attribute results in a warning if the variable is
     used anywhere in the source file.  This is useful when identifying
     variables that are expected to be removed in a future version of a
     program.  The warning also includes the location of the declaration
     of the deprecated variable, to enable users to easily find further
     information about why the variable is deprecated, or what they
     should do instead.  Note that the warning only occurs for uses:

          extern int old_var __attribute__ ((deprecated));
          extern int old_var;
          int new_fn () { return old_var; }

     results in a warning on line 3 but not line 2.  The optional MSG
     argument, which must be a string, is printed in the warning if
     present.

     The 'deprecated' attribute can also be used for functions and types
     (*note Function Attributes::, *note Type Attributes::.)

'mode (MODE)'
     This attribute specifies the data type for the
     declaration--whichever type corresponds to the mode MODE.  This in
     effect lets you request an integer or floating-point type according
     to its width.

     You may also specify a mode of 'byte' or '__byte__' to indicate the
     mode corresponding to a one-byte integer, 'word' or '__word__' for
     the mode of a one-word integer, and 'pointer' or '__pointer__' for
     the mode used to represent pointers.

'packed'
     The 'packed' attribute specifies that a variable or structure field
     should have the smallest possible alignment--one byte for a
     variable, and one bit for a field, unless you specify a larger
     value with the 'aligned' attribute.

     Here is a structure in which the field 'x' is packed, so that it
     immediately follows 'a':

          struct foo
          {
            char a;
            int x[2] __attribute__ ((packed));
          };

     _Note:_ The 4.1, 4.2 and 4.3 series of GCC ignore the 'packed'
     attribute on bit-fields of type 'char'.  This has been fixed in GCC
     4.4 but the change can lead to differences in the structure layout.
     See the documentation of '-Wpacked-bitfield-compat' for more
     information.

'section ("SECTION-NAME")'
     Normally, the compiler places the objects it generates in sections
     like 'data' and 'bss'.  Sometimes, however, you need additional
     sections, or you need certain particular variables to appear in
     special sections, for example to map to special hardware.  The
     'section' attribute specifies that a variable (or function) lives
     in a particular section.  For example, this small program uses
     several specific section names:

          struct duart a __attribute__ ((section ("DUART_A"))) = { 0 };
          struct duart b __attribute__ ((section ("DUART_B"))) = { 0 };
          char stack[10000] __attribute__ ((section ("STACK"))) = { 0 };
          int init_data __attribute__ ((section ("INITDATA")));

          main()
          {
            /* Initialize stack pointer */
            init_sp (stack + sizeof (stack));

            /* Initialize initialized data */
            memcpy (&init_data, &data, &edata - &data);

            /* Turn on the serial ports */
            init_duart (&a);
            init_duart (&b);
          }

     Use the 'section' attribute with _global_ variables and not _local_
     variables, as shown in the example.

     You may use the 'section' attribute with initialized or
     uninitialized global variables but the linker requires each object
     be defined once, with the exception that uninitialized variables
     tentatively go in the 'common' (or 'bss') section and can be
     multiply "defined".  Using the 'section' attribute changes what
     section the variable goes into and may cause the linker to issue an
     error if an uninitialized variable has multiple definitions.  You
     can force a variable to be initialized with the '-fno-common' flag
     or the 'nocommon' attribute.

     Some file formats do not support arbitrary sections so the
     'section' attribute is not available on all platforms.  If you need
     to map the entire contents of a module to a particular section,
     consider using the facilities of the linker instead.

'shared'
     On Microsoft Windows, in addition to putting variable definitions
     in a named section, the section can also be shared among all
     running copies of an executable or DLL.  For example, this small
     program defines shared data by putting it in a named section
     'shared' and marking the section shareable:

          int foo __attribute__((section ("shared"), shared)) = 0;

          int
          main()
          {
            /* Read and write foo.  All running
               copies see the same value.  */
            return 0;
          }

     You may only use the 'shared' attribute along with 'section'
     attribute with a fully-initialized global definition because of the
     way linkers work.  See 'section' attribute for more information.

     The 'shared' attribute is only available on Microsoft Windows.

'tls_model ("TLS_MODEL")'
     The 'tls_model' attribute sets thread-local storage model (*note
     Thread-Local::) of a particular '__thread' variable, overriding
     '-ftls-model=' command-line switch on a per-variable basis.  The
     TLS_MODEL argument should be one of 'global-dynamic',
     'local-dynamic', 'initial-exec' or 'local-exec'.

     Not all targets support this attribute.

'unused'
     This attribute, attached to a variable, means that the variable is
     meant to be possibly unused.  GCC does not produce a warning for
     this variable.

'used'
     This attribute, attached to a variable with the static storage,
     means that the variable must be emitted even if it appears that the
     variable is not referenced.

     When applied to a static data member of a C++ class template, the
     attribute also means that the member is instantiated if the class
     itself is instantiated.

'vector_size (BYTES)'
     This attribute specifies the vector size for the variable, measured
     in bytes.  For example, the declaration:

          int foo __attribute__ ((vector_size (16)));

     causes the compiler to set the mode for 'foo', to be 16 bytes,
     divided into 'int' sized units.  Assuming a 32-bit int (a vector of
     4 units of 4 bytes), the corresponding mode of 'foo' is V4SI.

     This attribute is only applicable to integral and float scalars,
     although arrays, pointers, and function return values are allowed
     in conjunction with this construct.

     Aggregates with this attribute are invalid, even if they are of the
     same size as a corresponding scalar.  For example, the declaration:

          struct S { int a; };
          struct S  __attribute__ ((vector_size (16))) foo;

     is invalid even if the size of the structure is the same as the
     size of the 'int'.

'selectany'
     The 'selectany' attribute causes an initialized global variable to
     have link-once semantics.  When multiple definitions of the
     variable are encountered by the linker, the first is selected and
     the remainder are discarded.  Following usage by the Microsoft
     compiler, the linker is told _not_ to warn about size or content
     differences of the multiple definitions.

     Although the primary usage of this attribute is for POD types, the
     attribute can also be applied to global C++ objects that are
     initialized by a constructor.  In this case, the static
     initialization and destruction code for the object is emitted in
     each translation defining the object, but the calls to the
     constructor and destructor are protected by a link-once guard
     variable.

     The 'selectany' attribute is only available on Microsoft Windows
     targets.  You can use '__declspec (selectany)' as a synonym for
     '__attribute__ ((selectany))' for compatibility with other
     compilers.

'weak'
     The 'weak' attribute is described in *note Function Attributes::.

'dllimport'
     The 'dllimport' attribute is described in *note Function
     Attributes::.

'dllexport'
     The 'dllexport' attribute is described in *note Function
     Attributes::.

6.38.1 AVR Variable Attributes
------------------------------

'progmem'
     The 'progmem' attribute is used on the AVR to place read-only data
     in the non-volatile program memory (flash).  The 'progmem'
     attribute accomplishes this by putting respective variables into a
     section whose name starts with '.progmem'.

     This attribute works similar to the 'section' attribute but adds
     additional checking.  Notice that just like the 'section'
     attribute, 'progmem' affects the location of the data but not how
     this data is accessed.

     In order to read data located with the 'progmem' attribute (inline)
     assembler must be used.
          /* Use custom macros from AVR-LibC (http://nongnu.org/avr-libc/user-manual/) */
          #include <avr/pgmspace.h>

          /* Locate var in flash memory */
          const int var[2] PROGMEM = { 1, 2 };

          int read_var (int i)
          {
              /* Access var[] by accessor macro from avr/pgmspace.h */
              return (int) pgm_read_word (& var[i]);
          }

     AVR is a Harvard architecture processor and data and read-only data
     normally resides in the data memory (RAM).

     See also the *note AVR Named Address Spaces:: section for an
     alternate way to locate and access data in flash memory.

'io'
'io (ADDR)'
     Variables with the 'io' attribute are used to address memory-mapped
     peripherals in the io address range.  If an address is specified,
     the variable is assigned that address, and the value is interpreted
     as an address in the data address space.  Example:

          volatile int porta __attribute__((io (0x22)));

     The address specified in the address in the data address range.

     Otherwise, the variable it is not assigned an address, but the
     compiler will still use in/out instructions where applicable,
     assuming some other module assigns an address in the io address
     range.  Example:

          extern volatile int porta __attribute__((io));

'io_low'
'io_low (ADDR)'
     This is like the 'io' attribute, but additionally it informs the
     compiler that the object lies in the lower half of the I/O area,
     allowing the use of 'cbi', 'sbi', 'sbic' and 'sbis' instructions.

'address'
'address (ADDR)'
     Variables with the 'address' attribute are used to address
     memory-mapped peripherals that may lie outside the io address
     range.

          volatile int porta __attribute__((address (0x600)));

6.38.2 Blackfin Variable Attributes
-----------------------------------

Three attributes are currently defined for the Blackfin.

'l1_data'
'l1_data_A'
'l1_data_B'
     Use these attributes on the Blackfin to place the variable into L1
     Data SRAM. Variables with 'l1_data' attribute are put into the
     specific section named '.l1.data'.  Those with 'l1_data_A'
     attribute are put into the specific section named '.l1.data.A'.
     Those with 'l1_data_B' attribute are put into the specific section
     named '.l1.data.B'.

'l2'
     Use this attribute on the Blackfin to place the variable into L2
     SRAM. Variables with 'l2' attribute are put into the specific
     section named '.l2.data'.

6.38.3 M32R/D Variable Attributes
---------------------------------

One attribute is currently defined for the M32R/D.

'model (MODEL-NAME)'
     Use this attribute on the M32R/D to set the addressability of an
     object.  The identifier MODEL-NAME is one of 'small', 'medium', or
     'large', representing each of the code models.

     Small model objects live in the lower 16MB of memory (so that their
     addresses can be loaded with the 'ld24' instruction).

     Medium and large model objects may live anywhere in the 32-bit
     address space (the compiler generates 'seth/add3' instructions to
     load their addresses).

6.38.4 MeP Variable Attributes
------------------------------

The MeP target has a number of addressing modes and busses.  The 'near'
space spans the standard memory space's first 16 megabytes (24 bits).
The 'far' space spans the entire 32-bit memory space.  The 'based' space
is a 128-byte region in the memory space that is addressed relative to
the '$tp' register.  The 'tiny' space is a 65536-byte region relative to
the '$gp' register.  In addition to these memory regions, the MeP target
has a separate 16-bit control bus which is specified with 'cb'
attributes.

'based'
     Any variable with the 'based' attribute is assigned to the '.based'
     section, and is accessed with relative to the '$tp' register.

'tiny'
     Likewise, the 'tiny' attribute assigned variables to the '.tiny'
     section, relative to the '$gp' register.

'near'
     Variables with the 'near' attribute are assumed to have addresses
     that fit in a 24-bit addressing mode.  This is the default for
     large variables ('-mtiny=4' is the default) but this attribute can
     override '-mtiny=' for small variables, or override '-ml'.

'far'
     Variables with the 'far' attribute are addressed using a full
     32-bit address.  Since this covers the entire memory space, this
     allows modules to make no assumptions about where variables might
     be stored.

'io'
'io (ADDR)'
     Variables with the 'io' attribute are used to address memory-mapped
     peripherals.  If an address is specified, the variable is assigned
     that address, else it is not assigned an address (it is assumed
     some other module assigns an address).  Example:

          int timer_count __attribute__((io(0x123)));

'cb'
'cb (ADDR)'
     Variables with the 'cb' attribute are used to access the control
     bus, using special instructions.  'addr' indicates the control bus
     address.  Example:

          int cpu_clock __attribute__((cb(0x123)));

6.38.5 PowerPC Variable Attributes
----------------------------------

Three attributes currently are defined for PowerPC configurations:
'altivec', 'ms_struct' and 'gcc_struct'.

 For full documentation of the struct attributes please see the
documentation in *note x86 Variable Attributes::.

 For documentation of 'altivec' attribute please see the documentation
in *note PowerPC Type Attributes::.

6.38.6 SPU Variable Attributes
------------------------------

The SPU supports the 'spu_vector' attribute for variables.  For
documentation of this attribute please see the documentation in *note
SPU Type Attributes::.

6.38.7 x86 Variable Attributes
------------------------------

Two attributes are currently defined for x86 configurations: 'ms_struct'
and 'gcc_struct'.

'ms_struct'
'gcc_struct'

     If 'packed' is used on a structure, or if bit-fields are used, it
     may be that the Microsoft ABI lays out the structure differently
     than the way GCC normally does.  Particularly when moving packed
     data between functions compiled with GCC and the native Microsoft
     compiler (either via function call or as data in a file), it may be
     necessary to access either format.

     Currently '-m[no-]ms-bitfields' is provided for the Microsoft
     Windows x86 compilers to match the native Microsoft compiler.

     The Microsoft structure layout algorithm is fairly simple with the
     exception of the bit-field packing.  The padding and alignment of
     members of structures and whether a bit-field can straddle a
     storage-unit boundary are determine by these rules:

       1. Structure members are stored sequentially in the order in
          which they are declared: the first member has the lowest
          memory address and the last member the highest.

       2. Every data object has an alignment requirement.  The alignment
          requirement for all data except structures, unions, and arrays
          is either the size of the object or the current packing size
          (specified with either the 'aligned' attribute or the 'pack'
          pragma), whichever is less.  For structures, unions, and
          arrays, the alignment requirement is the largest alignment
          requirement of its members.  Every object is allocated an
          offset so that:

               offset % alignment_requirement == 0

       3. Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte
          allocation unit if the integral types are the same size and if
          the next bit-field fits into the current allocation unit
          without crossing the boundary imposed by the common alignment
          requirements of the bit-fields.

     MSVC interprets zero-length bit-fields in the following ways:

       1. If a zero-length bit-field is inserted between two bit-fields
          that are normally coalesced, the bit-fields are not coalesced.

          For example:

               struct
                {
                  unsigned long bf_1 : 12;
                  unsigned long : 0;
                  unsigned long bf_2 : 12;
                } t1;

          The size of 't1' is 8 bytes with the zero-length bit-field.
          If the zero-length bit-field were removed, 't1''s size would
          be 4 bytes.

       2. If a zero-length bit-field is inserted after a bit-field,
          'foo', and the alignment of the zero-length bit-field is
          greater than the member that follows it, 'bar', 'bar' is
          aligned as the type of the zero-length bit-field.

          For example:

               struct
                {
                  char foo : 4;
                  short : 0;
                  char bar;
                } t2;

               struct
                {
                  char foo : 4;
                  short : 0;
                  double bar;
                } t3;

          For 't2', 'bar' is placed at offset 2, rather than offset 1.
          Accordingly, the size of 't2' is 4.  For 't3', the zero-length
          bit-field does not affect the alignment of 'bar' or, as a
          result, the size of the structure.

          Taking this into account, it is important to note the
          following:

            1. If a zero-length bit-field follows a normal bit-field,
               the type of the zero-length bit-field may affect the
               alignment of the structure as whole.  For example, 't2'
               has a size of 4 bytes, since the zero-length bit-field
               follows a normal bit-field, and is of type short.

            2. Even if a zero-length bit-field is not followed by a
               normal bit-field, it may still affect the alignment of
               the structure:

                    struct
                     {
                       char foo : 6;
                       long : 0;
                     } t4;

               Here, 't4' takes up 4 bytes.

       3. Zero-length bit-fields following non-bit-field members are
          ignored:

               struct
                {
                  char foo;
                  long : 0;
                  char bar;
                } t5;

          Here, 't5' takes up 2 bytes.

6.38.8 Xstormy16 Variable Attributes
------------------------------------

One attribute is currently defined for xstormy16 configurations:
'below100'.

'below100'

     If a variable has the 'below100' attribute ('BELOW100' is allowed
     also), GCC places the variable in the first 0x100 bytes of memory
     and use special opcodes to access it.  Such variables are placed in
     either the '.bss_below100' section or the '.data_below100' section.


File: llvm.info,  Node: Type Attributes,  Next: Alignment,  Prev: Variable Attributes,  Up: C Extensions

6.39 Specifying Attributes of Types
===================================

The keyword '__attribute__' allows you to specify special attributes of
'struct' and 'union' types when you define such types.  This keyword is
followed by an attribute specification inside double parentheses.  Eight
attributes are currently defined for types: 'aligned', 'packed',
'transparent_union', 'unused', 'deprecated', 'visibility', 'may_alias'
and 'bnd_variable_size'.  Other attributes are defined for functions
(*note Function Attributes::), labels (*note Label Attributes::) and for
variables (*note Variable Attributes::).

 You may also specify any one of these attributes with '__' preceding
and following its keyword.  This allows you to use these attributes in
header files without being concerned about a possible macro of the same
name.  For example, you may use '__aligned__' instead of 'aligned'.

 You may specify type attributes in an enum, struct or union type
declaration or definition, or for other types in a 'typedef'
declaration.

 For an enum, struct or union type, you may specify attributes either
between the enum, struct or union tag and the name of the type, or just
past the closing curly brace of the _definition_.  The former syntax is
preferred.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

'aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment (in bytes) for
     variables of the specified type.  For example, the declarations:

          struct S { short f[3]; } __attribute__ ((aligned (8)));
          typedef int more_aligned_int __attribute__ ((aligned (8)));

     force the compiler to ensure (as far as it can) that each variable
     whose type is 'struct S' or 'more_aligned_int' is allocated and
     aligned _at least_ on a 8-byte boundary.  On a SPARC, having all
     variables of type 'struct S' aligned to 8-byte boundaries allows
     the compiler to use the 'ldd' and 'std' (doubleword load and store)
     instructions when copying one variable of type 'struct S' to
     another, thus improving run-time efficiency.

     Note that the alignment of any given 'struct' or 'union' type is
     required by the ISO C standard to be at least a perfect multiple of
     the lowest common multiple of the alignments of all of the members
     of the 'struct' or 'union' in question.  This means that you _can_
     effectively adjust the alignment of a 'struct' or 'union' type by
     attaching an 'aligned' attribute to any one of the members of such
     a type, but the notation illustrated in the example above is a more
     obvious, intuitive, and readable way to request the compiler to
     adjust the alignment of an entire 'struct' or 'union' type.

     As in the preceding example, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     'struct' or 'union' type.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a type to the
     maximum useful alignment for the target machine you are compiling
     for.  For example, you could write:

          struct S { short f[3]; } __attribute__ ((aligned));

     Whenever you leave out the alignment factor in an 'aligned'
     attribute specification, the compiler automatically sets the
     alignment for the type to the largest alignment that is ever used
     for any data type on the target machine you are compiling for.
     Doing this can often make copy operations more efficient, because
     the compiler can use whatever instructions copy the biggest chunks
     of memory when performing copies to or from the variables that have
     types that you have aligned this way.

     In the example above, if the size of each 'short' is 2 bytes, then
     the size of the entire 'struct S' type is 6 bytes.  The smallest
     power of two that is greater than or equal to that is 8, so the
     compiler sets the alignment for the entire 'struct S' type to 8
     bytes.

     Note that although you can ask the compiler to select a
     time-efficient alignment for a given type and then declare only
     individual stand-alone objects of that type, the compiler's ability
     to select a time-efficient alignment is primarily useful only when
     you plan to create arrays of variables having the relevant
     (efficiently aligned) type.  If you declare or use arrays of
     variables of an efficiently-aligned type, then it is likely that
     your program also does pointer arithmetic (or subscripting, which
     amounts to the same thing) on pointers to the relevant type, and
     the code that the compiler generates for these pointer arithmetic
     operations is often more efficient for efficiently-aligned types
     than for other types.

     The 'aligned' attribute can only increase the alignment; but you
     can decrease it by specifying 'packed' as well.  See below.

     Note that the effectiveness of 'aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8-byte alignment,
     then specifying 'aligned(16)' in an '__attribute__' still only
     provides you with 8-byte alignment.  See your linker documentation
     for further information.

'packed'
     This attribute, attached to 'struct' or 'union' type definition,
     specifies that each member (other than zero-width bit-fields) of
     the structure or union is placed to minimize the memory required.
     When attached to an 'enum' definition, it indicates that the
     smallest integral type should be used.

     Specifying this attribute for 'struct' and 'union' types is
     equivalent to specifying the 'packed' attribute on each of the
     structure or union members.  Specifying the '-fshort-enums' flag on
     the line is equivalent to specifying the 'packed' attribute on all
     'enum' definitions.

     In the following example 'struct my_packed_struct''s members are
     packed closely together, but the internal layout of its 's' member
     is not packed--to do that, 'struct my_unpacked_struct' needs to be
     packed too.

          struct my_unpacked_struct
           {
              char c;
              int i;
           };

          struct __attribute__ ((__packed__)) my_packed_struct
            {
               char c;
               int  i;
               struct my_unpacked_struct s;
            };

     You may only specify this attribute on the definition of an 'enum',
     'struct' or 'union', not on a 'typedef' that does not also define
     the enumerated type, structure or union.

'transparent_union'

     This attribute, attached to a 'union' type definition, indicates
     that any function parameter having that union type causes calls to
     that function to be treated in a special way.

     First, the argument corresponding to a transparent union type can
     be of any type in the union; no cast is required.  Also, if the
     union contains a pointer type, the corresponding argument can be a
     null pointer constant or a void pointer expression; and if the
     union contains a void pointer type, the corresponding argument can
     be any pointer expression.  If the union member type is a pointer,
     qualifiers like 'const' on the referenced type must be respected,
     just as with normal pointer conversions.

     Second, the argument is passed to the function using the calling
     conventions of the first member of the transparent union, not the
     calling conventions of the union itself.  All members of the union
     must have the same machine representation; this is necessary for
     this argument passing to work properly.

     Transparent unions are designed for library functions that have
     multiple interfaces for compatibility reasons.  For example,
     suppose the 'wait' function must accept either a value of type 'int
     *' to comply with POSIX, or a value of type 'union wait *' to
     comply with the 4.1BSD interface.  If 'wait''s parameter were 'void
     *', 'wait' would accept both kinds of arguments, but it would also
     accept any other pointer type and this would make argument type
     checking less useful.  Instead, '<sys/wait.h>' might define the
     interface as follows:

          typedef union __attribute__ ((__transparent_union__))
            {
              int *__ip;
              union wait *__up;
            } wait_status_ptr_t;

          pid_t wait (wait_status_ptr_t);

     This interface allows either 'int *' or 'union wait *' arguments to
     be passed, using the 'int *' calling convention.  The program can
     call 'wait' with arguments of either type:

          int w1 () { int w; return wait (&w); }
          int w2 () { union wait w; return wait (&w); }

     With this interface, 'wait''s implementation might look like this:

          pid_t wait (wait_status_ptr_t p)
          {
            return waitpid (-1, p.__ip, 0);
          }

'unused'
     When attached to a type (including a 'union' or a 'struct'), this
     attribute means that variables of that type are meant to appear
     possibly unused.  GCC does not produce a warning for any variables
     of that type, even if the variable appears to do nothing.  This is
     often the case with lock or thread classes, which are usually
     defined and then not referenced, but contain constructors and
     destructors that have nontrivial bookkeeping functions.

'deprecated'
'deprecated (MSG)'
     The 'deprecated' attribute results in a warning if the type is used
     anywhere in the source file.  This is useful when identifying types
     that are expected to be removed in a future version of a program.
     If possible, the warning also includes the location of the
     declaration of the deprecated type, to enable users to easily find
     further information about why the type is deprecated, or what they
     should do instead.  Note that the warnings only occur for uses and
     then only if the type is being applied to an identifier that itself
     is not being declared as deprecated.

          typedef int T1 __attribute__ ((deprecated));
          T1 x;
          typedef T1 T2;
          T2 y;
          typedef T1 T3 __attribute__ ((deprecated));
          T3 z __attribute__ ((deprecated));

     results in a warning on line 2 and 3 but not lines 4, 5, or 6.  No
     warning is issued for line 4 because T2 is not explicitly
     deprecated.  Line 5 has no warning because T3 is explicitly
     deprecated.  Similarly for line 6.  The optional MSG argument,
     which must be a string, is printed in the warning if present.

     The 'deprecated' attribute can also be used for functions and
     variables (*note Function Attributes::, *note Variable
     Attributes::.)

'may_alias'
     Accesses through pointers to types with this attribute are not
     subject to type-based alias analysis, but are instead assumed to be
     able to alias any other type of objects.  In the context of section
     6.5 paragraph 7 of the C99 standard, an lvalue expression
     dereferencing such a pointer is treated like having a character
     type.  See '-fstrict-aliasing' for more information on aliasing
     issues.  This extension exists to support some vector APIs, in
     which pointers to one vector type are permitted to alias pointers
     to a different vector type.

     Note that an object of a type with this attribute does not have any
     special semantics.

     Example of use:

          typedef short __attribute__((__may_alias__)) short_a;

          int
          main (void)
          {
            int a = 0x12345678;
            short_a *b = (short_a *) &a;

            b[1] = 0;

            if (a == 0x12345678)
              abort();

            exit(0);
          }

     If you replaced 'short_a' with 'short' in the variable declaration,
     the above program would abort when compiled with
     '-fstrict-aliasing', which is on by default at '-O2' or above.

'visibility'
     In C++, attribute visibility (*note Function Attributes::) can also
     be applied to class, struct, union and enum types.  Unlike other
     type attributes, the attribute must appear between the initial
     keyword and the name of the type; it cannot appear after the body
     of the type.

     Note that the type visibility is applied to vague linkage entities
     associated with the class (vtable, typeinfo node, etc.).  In
     particular, if a class is thrown as an exception in one shared
     object and caught in another, the class must have default
     visibility.  Otherwise the two shared objects are unable to use the
     same typeinfo node and exception handling will break.

'designated_init'
     This attribute may only be applied to structure types.  It
     indicates that any initialization of an object of this type must
     use designated initializers rather than positional initializers.
     The intent of this attribute is to allow the programmer to indicate
     that a structure's layout may change, and that therefore relying on
     positional initialization will result in future breakage.

     GCC emits warnings based on this attribute by default; use
     '-Wno-designated-init' to suppress them.

'bnd_variable_size'
     When applied to a structure field, this attribute tells Pointer
     Bounds Checker that the size of this field should not be computed
     using static type information.  It may be used to mark variable
     sized static array fields placed at the end of a structure.

          struct S
          {
            int size;
            char data[1];
          }
          S *p = (S *)malloc (sizeof(S) + 100);
          p->data[10] = 0; //Bounds violation

     By using an attribute for a field we may avoid bound violation we
     most probably do not want to see:

          struct S
          {
            int size;
            char data[1] __attribute__((bnd_variable_size));
          }
          S *p = (S *)malloc (sizeof(S) + 100);
          p->data[10] = 0; //OK

 To specify multiple attributes, separate them by commas within the
double parentheses: for example, '__attribute__ ((aligned (16),
packed))'.

6.39.1 ARM Type Attributes
--------------------------

On those ARM targets that support 'dllimport' (such as Symbian OS), you
can use the 'notshared' attribute to indicate that the virtual table and
other similar data for a class should not be exported from a DLL.  For
example:

     class __declspec(notshared) C {
     public:
       __declspec(dllimport) C();
       virtual void f();
     }

     __declspec(dllexport)
     C::C() {}

In this code, 'C::C' is exported from the current DLL, but the virtual
table for 'C' is not exported.  (You can use '__attribute__' instead of
'__declspec' if you prefer, but most Symbian OS code uses '__declspec'.)

6.39.2 MeP Type Attributes
--------------------------

Many of the MeP variable attributes may be applied to types as well.
Specifically, the 'based', 'tiny', 'near', and 'far' attributes may be
applied to either.  The 'io' and 'cb' attributes may not be applied to
types.

6.39.3 PowerPC Type Attributes
------------------------------

Three attributes currently are defined for PowerPC configurations:
'altivec', 'ms_struct' and 'gcc_struct'.

 For full documentation of the 'ms_struct' and 'gcc_struct' attributes
please see the documentation in *note x86 Type Attributes::.

 The 'altivec' attribute allows one to declare AltiVec vector data types
supported by the AltiVec Programming Interface Manual.  The attribute
requires an argument to specify one of three vector types: 'vector__',
'pixel__' (always followed by unsigned short), and 'bool__' (always
followed by unsigned).

     __attribute__((altivec(vector__)))
     __attribute__((altivec(pixel__))) unsigned short
     __attribute__((altivec(bool__))) unsigned

 These attributes mainly are intended to support the '__vector',
'__pixel', and '__bool' AltiVec keywords.

6.39.4 SPU Type Attributes
--------------------------

The SPU supports the 'spu_vector' attribute for types.  This attribute
allows one to declare vector data types supported by the
Sony/Toshiba/IBM SPU Language Extensions Specification.  It is intended
to support the '__vector' keyword.

6.39.5 x86 Type Attributes
--------------------------

Two attributes are currently defined for x86 configurations: 'ms_struct'
and 'gcc_struct'.

'ms_struct'
'gcc_struct'

     If 'packed' is used on a structure, or if bit-fields are used it
     may be that the Microsoft ABI packs them differently than GCC
     normally packs them.  Particularly when moving packed data between
     functions compiled with GCC and the native Microsoft compiler
     (either via function call or as data in a file), it may be
     necessary to access either format.

     Currently '-m[no-]ms-bitfields' is provided for the Microsoft
     Windows x86 compilers to match the native Microsoft compiler.


File: llvm.info,  Node: Alignment,  Next: Inline,  Prev: Type Attributes,  Up: C Extensions

6.40 Inquiring on Alignment of Types or Variables
=================================================

The keyword '__alignof__' allows you to inquire about how an object is
aligned, or the minimum alignment usually required by a type.  Its
syntax is just like 'sizeof'.

 For example, if the target machine requires a 'double' value to be
aligned on an 8-byte boundary, then '__alignof__ (double)' is 8.  This
is true on many RISC machines.  On more traditional machine designs,
'__alignof__ (double)' is 4 or even 2.

 Some machines never actually require alignment; they allow reference to
any data type even at an odd address.  For these machines, '__alignof__'
reports the smallest alignment that GCC gives the data type, usually as
mandated by the target ABI.

 If the operand of '__alignof__' is an lvalue rather than a type, its
value is the required alignment for its type, taking into account any
minimum alignment specified with GCC's '__attribute__' extension (*note
Variable Attributes::).  For example, after this declaration:

     struct foo { int x; char y; } foo1;

the value of '__alignof__ (foo1.y)' is 1, even though its actual
alignment is probably 2 or 4, the same as '__alignof__ (int)'.

 It is an error to ask for the alignment of an incomplete type.


File: llvm.info,  Node: Inline,  Next: Volatiles,  Prev: Alignment,  Up: C Extensions

6.41 An Inline Function is As Fast As a Macro
=============================================

By declaring a function inline, you can direct GCC to make calls to that
function faster.  One way GCC can achieve this is to integrate that
function's code into the code for its callers.  This makes execution
faster by eliminating the function-call overhead; in addition, if any of
the actual argument values are constant, their known values may permit
simplifications at compile time so that not all of the inline function's
code needs to be included.  The effect on code size is less predictable;
object code may be larger or smaller with function inlining, depending
on the particular case.  You can also direct GCC to try to integrate all
"simple enough" functions into their callers with the option
'-finline-functions'.

 GCC implements three different semantics of declaring a function
inline.  One is available with '-std=gnu89' or '-fgnu89-inline' or when
'gnu_inline' attribute is present on all inline declarations, another
when '-std=c99', '-std=c11', '-std=gnu99' or '-std=gnu11' (without
'-fgnu89-inline'), and the third is used when compiling C++.

 To declare a function inline, use the 'inline' keyword in its
declaration, like this:

     static inline int
     inc (int *a)
     {
       return (*a)++;
     }

 If you are writing a header file to be included in ISO C90 programs,
write '__inline__' instead of 'inline'.  *Note Alternate Keywords::.

 The three types of inlining behave similarly in two important cases:
when the 'inline' keyword is used on a 'static' function, like the
example above, and when a function is first declared without using the
'inline' keyword and then is defined with 'inline', like this:

     extern int inc (int *a);
     inline int
     inc (int *a)
     {
       return (*a)++;
     }

 In both of these common cases, the program behaves the same as if you
had not used the 'inline' keyword, except for its speed.

 When a function is both inline and 'static', if all calls to the
function are integrated into the caller, and the function's address is
never used, then the function's own assembler code is never referenced.
In this case, GCC does not actually output assembler code for the
function, unless you specify the option '-fkeep-inline-functions'.  Some
calls cannot be integrated for various reasons (in particular, calls
that precede the function's definition cannot be integrated, and neither
can recursive calls within the definition).  If there is a nonintegrated
call, then the function is compiled to assembler code as usual.  The
function must also be compiled as usual if the program refers to its
address, because that can't be inlined.

 Note that certain usages in a function definition can make it
unsuitable for inline substitution.  Among these usages are: variadic
functions, use of 'alloca', use of variable-length data types (*note
Variable Length::), use of computed goto (*note Labels as Values::), use
of nonlocal goto, and nested functions (*note Nested Functions::).
Using '-Winline' warns when a function marked 'inline' could not be
substituted, and gives the reason for the failure.

 As required by ISO C++, GCC considers member functions defined within
the body of a class to be marked inline even if they are not explicitly
declared with the 'inline' keyword.  You can override this with
'-fno-default-inline'; *note Options Controlling C++ Dialect: C++
Dialect Options.

 GCC does not inline any functions when not optimizing unless you
specify the 'always_inline' attribute for the function, like this:

     /* Prototype.  */
     inline void foo (const char) __attribute__((always_inline));

 The remainder of this section is specific to GNU C90 inlining.

 When an inline function is not 'static', then the compiler must assume
that there may be calls from other source files; since a global symbol
can be defined only once in any program, the function must not be
defined in the other source files, so the calls therein cannot be
integrated.  Therefore, a non-'static' inline function is always
compiled on its own in the usual fashion.

 If you specify both 'inline' and 'extern' in the function definition,
then the definition is used only for inlining.  In no case is the
function compiled on its own, not even if you refer to its address
explicitly.  Such an address becomes an external reference, as if you
had only declared the function, and had not defined it.

 This combination of 'inline' and 'extern' has almost the effect of a
macro.  The way to use it is to put a function definition in a header
file with these keywords, and put another copy of the definition
(lacking 'inline' and 'extern') in a library file.  The definition in
the header file causes most calls to the function to be inlined.  If any
uses of the function remain, they refer to the single copy in the
library.


File: llvm.info,  Node: Volatiles,  Next: Using Assembly Language with C,  Prev: Inline,  Up: C Extensions

6.42 When is a Volatile Object Accessed?
========================================

C has the concept of volatile objects.  These are normally accessed by
pointers and used for accessing hardware or inter-thread communication.
The standard encourages compilers to refrain from optimizations
concerning accesses to volatile objects, but leaves it implementation
defined as to what constitutes a volatile access.  The minimum
requirement is that at a sequence point all previous accesses to
volatile objects have stabilized and no subsequent accesses have
occurred.  Thus an implementation is free to reorder and combine
volatile accesses that occur between sequence points, but cannot do so
for accesses across a sequence point.  The use of volatile does not
allow you to violate the restriction on updating objects multiple times
between two sequence points.

 Accesses to non-volatile objects are not ordered with respect to
volatile accesses.  You cannot use a volatile object as a memory barrier
to order a sequence of writes to non-volatile memory.  For instance:

     int *ptr = SOMETHING;
     volatile int vobj;
     *ptr = SOMETHING;
     vobj = 1;

Unless *PTR and VOBJ can be aliased, it is not guaranteed that the write
to *PTR occurs by the time the update of VOBJ happens.  If you need this
guarantee, you must use a stronger memory barrier such as:

     int *ptr = SOMETHING;
     volatile int vobj;
     *ptr = SOMETHING;
     asm volatile ("" : : : "memory");
     vobj = 1;

 A scalar volatile object is read when it is accessed in a void context:

     volatile int *src = SOMEVALUE;
     *src;

 Such expressions are rvalues, and GCC implements this as a read of the
volatile object being pointed to.

 Assignments are also expressions and have an rvalue.  However when
assigning to a scalar volatile, the volatile object is not reread,
regardless of whether the assignment expression's rvalue is used or not.
If the assignment's rvalue is used, the value is that assigned to the
volatile object.  For instance, there is no read of VOBJ in all the
following cases:

     int obj;
     volatile int vobj;
     vobj = SOMETHING;
     obj = vobj = SOMETHING;
     obj ? vobj = ONETHING : vobj = ANOTHERTHING;
     obj = (SOMETHING, vobj = ANOTHERTHING);

 If you need to read the volatile object after an assignment has
occurred, you must use a separate expression with an intervening
sequence point.

 As bit-fields are not individually addressable, volatile bit-fields may
be implicitly read when written to, or when adjacent bit-fields are
accessed.  Bit-field operations may be optimized such that adjacent
bit-fields are only partially accessed, if they straddle a storage unit
boundary.  For these reasons it is unwise to use volatile bit-fields to
access hardware.


File: llvm.info,  Node: Using Assembly Language with C,  Next: Alternate Keywords,  Prev: Volatiles,  Up: C Extensions

6.43 How to Use Inline Assembly Language in C Code
==================================================

The 'asm' keyword allows you to embed assembler instructions within C
code.  GCC provides two forms of inline 'asm' statements.  A "basic
'asm'" statement is one with no operands (*note Basic Asm::), while an
"extended 'asm'" statement (*note Extended Asm::) includes one or more
operands.  The extended form is preferred for mixing C and assembly
language within a function, but to include assembly language at top
level you must use basic 'asm'.

 You can also use the 'asm' keyword to override the assembler name for a
C symbol, or to place a C variable in a specific register.

* Menu:

* Basic Asm::          Inline assembler without operands.
* Extended Asm::       Inline assembler with operands.
* Constraints::        Constraints for 'asm' operands
* Asm Labels::         Specifying the assembler name to use for a C symbol.
* Explicit Reg Vars::  Defining variables residing in specified registers.
* Size of an asm::     How GCC calculates the size of an 'asm' block.


File: llvm.info,  Node: Basic Asm,  Next: Extended Asm,  Up: Using Assembly Language with C

6.43.1 Basic Asm -- Assembler Instructions Without Operands
-----------------------------------------------------------

A basic 'asm' statement has the following syntax:

     asm [ volatile ] ( ASSEMBLERINSTRUCTIONS )

 The 'asm' keyword is a GNU extension.  When writing code that can be
compiled with '-ansi' and the various '-std' options, use '__asm__'
instead of 'asm' (*note Alternate Keywords::).

Qualifiers
..........

'volatile'
     The optional 'volatile' qualifier has no effect.  All basic 'asm'
     blocks are implicitly volatile.

Parameters
..........

ASSEMBLERINSTRUCTIONS
     This is a literal string that specifies the assembler code.  The
     string can contain any instructions recognized by the assembler,
     including directives.  GCC does not parse the assembler
     instructions themselves and does not know what they mean or even
     whether they are valid assembler input.

     You may place multiple assembler instructions together in a single
     'asm' string, separated by the characters normally used in assembly
     code for the system.  A combination that works in most places is a
     newline to break the line, plus a tab character (written as
     '\n\t').  Some assemblers allow semicolons as a line separator.
     However, note that some assembler dialects use semicolons to start
     a comment.

Remarks
.......

Using extended 'asm' typically produces smaller, safer, and more
efficient code, and in most cases it is a better solution than basic
'asm'.  However, there are two situations where only basic 'asm' can be
used:

   * Extended 'asm' statements have to be inside a C function, so to
     write inline assembly language at file scope ("top-level"), outside
     of C functions, you must use basic 'asm'.  You can use this
     technique to emit assembler directives, define assembly language
     macros that can be invoked elsewhere in the file, or write entire
     functions in assembly language.

   * Functions declared with the 'naked' attribute also require basic
     'asm' (*note Function Attributes::).

 Safely accessing C data and calling functions from basic 'asm' is more
complex than it may appear.  To access C data, it is better to use
extended 'asm'.

 Do not expect a sequence of 'asm' statements to remain perfectly
consecutive after compilation.  If certain instructions need to remain
consecutive in the output, put them in a single multi-instruction 'asm'
statement.  Note that GCC's optimizers can move 'asm' statements
relative to other code, including across jumps.

 'asm' statements may not perform jumps into other 'asm' statements.
GCC does not know about these jumps, and therefore cannot take account
of them when deciding how to optimize.  Jumps from 'asm' to C labels are
only supported in extended 'asm'.

 Under certain circumstances, GCC may duplicate (or remove duplicates
of) your assembly code when optimizing.  This can lead to unexpected
duplicate symbol errors during compilation if your assembly code defines
symbols or labels.

 Since GCC does not parse the ASSEMBLERINSTRUCTIONS, it has no
visibility of any symbols it references.  This may result in GCC
discarding those symbols as unreferenced.

 The compiler copies the assembler instructions in a basic 'asm'
verbatim to the assembly language output file, without processing
dialects or any of the '%' operators that are available with extended
'asm'.  This results in minor differences between basic 'asm' strings
and extended 'asm' templates.  For example, to refer to registers you
might use '%eax' in basic 'asm' and '%%eax' in extended 'asm'.

 On targets such as x86 that support multiple assembler dialects, all
basic 'asm' blocks use the assembler dialect specified by the '-masm'
command-line option (*note x86 Options::).  Basic 'asm' provides no
mechanism to provide different assembler strings for different dialects.

 Here is an example of basic 'asm' for i386:

     /* Note that this code will not compile with -masm=intel */
     #define DebugBreak() asm("int $3")


File: llvm.info,  Node: Extended Asm,  Next: Constraints,  Prev: Basic Asm,  Up: Using Assembly Language with C

6.43.2 Extended Asm - Assembler Instructions with C Expression Operands
-----------------------------------------------------------------------

With extended 'asm' you can read and write C variables from assembler
and perform jumps from assembler code to C labels.  Extended 'asm'
syntax uses colons (':') to delimit the operand parameters after the
assembler template:

     asm [volatile] ( ASSEMBLERTEMPLATE
                      : OUTPUTOPERANDS
                      [ : INPUTOPERANDS
                      [ : CLOBBERS ] ])

     asm [volatile] goto ( ASSEMBLERTEMPLATE
                           :
                           : INPUTOPERANDS
                           : CLOBBERS
                           : GOTOLABELS)

 The 'asm' keyword is a GNU extension.  When writing code that can be
compiled with '-ansi' and the various '-std' options, use '__asm__'
instead of 'asm' (*note Alternate Keywords::).

Qualifiers
..........

'volatile'
     The typical use of extended 'asm' statements is to manipulate input
     values to produce output values.  However, your 'asm' statements
     may also produce side effects.  If so, you may need to use the
     'volatile' qualifier to disable certain optimizations.  *Note
     Volatile::.

'goto'
     This qualifier informs the compiler that the 'asm' statement may
     perform a jump to one of the labels listed in the GOTOLABELS.
     *Note GotoLabels::.

Parameters
..........

ASSEMBLERTEMPLATE
     This is a literal string that is the template for the assembler
     code.  It is a combination of fixed text and tokens that refer to
     the input, output, and goto parameters.  *Note AssemblerTemplate::.

OUTPUTOPERANDS
     A comma-separated list of the C variables modified by the
     instructions in the ASSEMBLERTEMPLATE.  An empty list is permitted.
     *Note OutputOperands::.

INPUTOPERANDS
     A comma-separated list of C expressions read by the instructions in
     the ASSEMBLERTEMPLATE.  An empty list is permitted.  *Note
     InputOperands::.

CLOBBERS
     A comma-separated list of registers or other values changed by the
     ASSEMBLERTEMPLATE, beyond those listed as outputs.  An empty list
     is permitted.  *Note Clobbers::.

GOTOLABELS
     When you are using the 'goto' form of 'asm', this section contains
     the list of all C labels to which the code in the ASSEMBLERTEMPLATE
     may jump.  *Note GotoLabels::.

     'asm' statements may not perform jumps into other 'asm' statements,
     only to the listed GOTOLABELS.  GCC's optimizers do not know about
     other jumps; therefore they cannot take account of them when
     deciding how to optimize.

 The total number of input + output + goto operands is limited to 30.

Remarks
.......

The 'asm' statement allows you to include assembly instructions directly
within C code.  This may help you to maximize performance in
time-sensitive code or to access assembly instructions that are not
readily available to C programs.

 Note that extended 'asm' statements must be inside a function.  Only
basic 'asm' may be outside functions (*note Basic Asm::).  Functions
declared with the 'naked' attribute also require basic 'asm' (*note
Function Attributes::).

 While the uses of 'asm' are many and varied, it may help to think of an
'asm' statement as a series of low-level instructions that convert input
parameters to output parameters.  So a simple (if not particularly
useful) example for i386 using 'asm' might look like this:

     int src = 1;
     int dst;

     asm ("mov %1, %0\n\t"
         "add $1, %0"
         : "=r" (dst)
         : "r" (src));

     printf("%d\n", dst);

 This code copies 'src' to 'dst' and add 1 to 'dst'.

6.43.2.1 Volatile
.................

GCC's optimizers sometimes discard 'asm' statements if they determine
there is no need for the output variables.  Also, the optimizers may
move code out of loops if they believe that the code will always return
the same result (i.e.  none of its input values change between calls).
Using the 'volatile' qualifier disables these optimizations.  'asm'
statements that have no output operands, including 'asm goto'
statements, are implicitly volatile.

 This i386 code demonstrates a case that does not use (or require) the
'volatile' qualifier.  If it is performing assertion checking, this code
uses 'asm' to perform the validation.  Otherwise, 'dwRes' is
unreferenced by any code.  As a result, the optimizers can discard the
'asm' statement, which in turn removes the need for the entire 'DoCheck'
routine.  By omitting the 'volatile' qualifier when it isn't needed you
allow the optimizers to produce the most efficient code possible.

     void DoCheck(uint32_t dwSomeValue)
     {
        uint32_t dwRes;

        // Assumes dwSomeValue is not zero.
        asm ("bsfl %1,%0"
          : "=r" (dwRes)
          : "r" (dwSomeValue)
          : "cc");

        assert(dwRes > 3);
     }

 The next example shows a case where the optimizers can recognize that
the input ('dwSomeValue') never changes during the execution of the
function and can therefore move the 'asm' outside the loop to produce
more efficient code.  Again, using 'volatile' disables this type of
optimization.

     void do_print(uint32_t dwSomeValue)
     {
        uint32_t dwRes;

        for (uint32_t x=0; x < 5; x++)
        {
           // Assumes dwSomeValue is not zero.
           asm ("bsfl %1,%0"
             : "=r" (dwRes)
             : "r" (dwSomeValue)
             : "cc");

           printf("%u: %u %u\n", x, dwSomeValue, dwRes);
        }
     }

 The following example demonstrates a case where you need to use the
'volatile' qualifier.  It uses the x86 'rdtsc' instruction, which reads
the computer's time-stamp counter.  Without the 'volatile' qualifier,
the optimizers might assume that the 'asm' block will always return the
same value and therefore optimize away the second call.

     uint64_t msr;

     asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
             "shl $32, %%rdx\n\t"  // Shift the upper bits left.
             "or %%rdx, %0"        // 'Or' in the lower bits.
             : "=a" (msr)
             :
             : "rdx");

     printf("msr: %llx\n", msr);

     // Do other work...

     // Reprint the timestamp
     asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
             "shl $32, %%rdx\n\t"  // Shift the upper bits left.
             "or %%rdx, %0"        // 'Or' in the lower bits.
             : "=a" (msr)
             :
             : "rdx");

     printf("msr: %llx\n", msr);

 GCC's optimizers do not treat this code like the non-volatile code in
the earlier examples.  They do not move it out of loops or omit it on
the assumption that the result from a previous call is still valid.

 Note that the compiler can move even volatile 'asm' instructions
relative to other code, including across jump instructions.  For
example, on many targets there is a system register that controls the
rounding mode of floating-point operations.  Setting it with a volatile
'asm', as in the following PowerPC example, does not work reliably.

     asm volatile("mtfsf 255, %0" : : "f" (fpenv));
     sum = x + y;

 The compiler may move the addition back before the volatile 'asm'.  To
make it work as expected, add an artificial dependency to the 'asm' by
referencing a variable in the subsequent code, for example:

     asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
     sum = x + y;

 Under certain circumstances, GCC may duplicate (or remove duplicates
of) your assembly code when optimizing.  This can lead to unexpected
duplicate symbol errors during compilation if your asm code defines
symbols or labels.  Using '%=' (*note AssemblerTemplate::) may help
resolve this problem.

6.43.2.2 Assembler Template
...........................

An assembler template is a literal string containing assembler
instructions.  The compiler replaces tokens in the template that refer
to inputs, outputs, and goto labels, and then outputs the resulting
string to the assembler.  The string can contain any instructions
recognized by the assembler, including directives.  GCC does not parse
the assembler instructions themselves and does not know what they mean
or even whether they are valid assembler input.  However, it does count
the statements (*note Size of an asm::).

 You may place multiple assembler instructions together in a single
'asm' string, separated by the characters normally used in assembly code
for the system.  A combination that works in most places is a newline to
break the line, plus a tab character to move to the instruction field
(written as '\n\t').  Some assemblers allow semicolons as a line
separator.  However, note that some assembler dialects use semicolons to
start a comment.

 Do not expect a sequence of 'asm' statements to remain perfectly
consecutive after compilation, even when you are using the 'volatile'
qualifier.  If certain instructions need to remain consecutive in the
output, put them in a single multi-instruction asm statement.

 Accessing data from C programs without using input/output operands
(such as by using global symbols directly from the assembler template)
may not work as expected.  Similarly, calling functions directly from an
assembler template requires a detailed understanding of the target
assembler and ABI.

 Since GCC does not parse the assembler template, it has no visibility
of any symbols it references.  This may result in GCC discarding those
symbols as unreferenced unless they are also listed as input, output, or
goto operands.

Special format strings
......................

In addition to the tokens described by the input, output, and goto
operands, these tokens have special meanings in the assembler template:

'%%'
     Outputs a single '%' into the assembler code.

'%='
     Outputs a number that is unique to each instance of the 'asm'
     statement in the entire compilation.  This option is useful when
     creating local labels and referring to them multiple times in a
     single template that generates multiple assembler instructions.

'%{'
'%|'
'%}'
     Outputs '{', '|', and '}' characters (respectively) into the
     assembler code.  When unescaped, these characters have special
     meaning to indicate multiple assembler dialects, as described
     below.

Multiple assembler dialects in 'asm' templates
..............................................

On targets such as x86, GCC supports multiple assembler dialects.  The
'-masm' option controls which dialect GCC uses as its default for inline
assembler.  The target-specific documentation for the '-masm' option
contains the list of supported dialects, as well as the default dialect
if the option is not specified.  This information may be important to
understand, since assembler code that works correctly when compiled
using one dialect will likely fail if compiled using another.  *Note x86
Options::.

 If your code needs to support multiple assembler dialects (for example,
if you are writing public headers that need to support a variety of
compilation options), use constructs of this form:

     { dialect0 | dialect1 | dialect2... }

 This construct outputs 'dialect0' when using dialect #0 to compile the
code, 'dialect1' for dialect #1, etc.  If there are fewer alternatives
within the braces than the number of dialects the compiler supports, the
construct outputs nothing.

 For example, if an x86 compiler supports two dialects ('att', 'intel'),
an assembler template such as this:

     "bt{l %[Offset],%[Base] | %[Base],%[Offset]}; jc %l2"

is equivalent to one of

     "btl %[Offset],%[Base] ; jc %l2"   /* att dialect */
     "bt %[Base],%[Offset]; jc %l2"     /* intel dialect */

 Using that same compiler, this code:

     "xchg{l}\t{%%}ebx, %1"

corresponds to either

     "xchgl\t%%ebx, %1"                 /* att dialect */
     "xchg\tebx, %1"                    /* intel dialect */

 There is no support for nesting dialect alternatives.

6.43.2.3 Output Operands
........................

An 'asm' statement has zero or more output operands indicating the names
of C variables modified by the assembler code.

 In this i386 example, 'old' (referred to in the template string as
'%0') and '*Base' (as '%1') are outputs and 'Offset' ('%2') is an input:

     bool old;

     __asm__ ("btsl %2,%1\n\t" // Turn on zero-based bit #Offset in Base.
              "sbb %0,%0"      // Use the CF to calculate old.
        : "=r" (old), "+rm" (*Base)
        : "Ir" (Offset)
        : "cc");

     return old;

 Operands are separated by commas.  Each operand has this format:

     [ [ASMSYMBOLICNAME] ] CONSTRAINT (CVARIABLENAME)

ASMSYMBOLICNAME
     Specifies a symbolic name for the operand.  Reference the name in
     the assembler template by enclosing it in square brackets (i.e.
     '%[Value]').  The scope of the name is the 'asm' statement that
     contains the definition.  Any valid C variable name is acceptable,
     including names already defined in the surrounding code.  No two
     operands within the same 'asm' statement can use the same symbolic
     name.

     When not using an ASMSYMBOLICNAME, use the (zero-based) position of
     the operand in the list of operands in the assembler template.  For
     example if there are three output operands, use '%0' in the
     template to refer to the first, '%1' for the second, and '%2' for
     the third.

CONSTRAINT
     A string constant specifying constraints on the placement of the
     operand; *Note Constraints::, for details.

     Output constraints must begin with either '=' (a variable
     overwriting an existing value) or '+' (when reading and writing).
     When using '=', do not assume the location contains the existing
     value on entry to the 'asm', except when the operand is tied to an
     input; *note Input Operands: InputOperands.

     After the prefix, there must be one or more additional constraints
     (*note Constraints::) that describe where the value resides.
     Common constraints include 'r' for register and 'm' for memory.
     When you list more than one possible location (for example,
     '"=rm"'), the compiler chooses the most efficient one based on the
     current context.  If you list as many alternates as the 'asm'
     statement allows, you permit the optimizers to produce the best
     possible code.  If you must use a specific register, but your
     Machine Constraints do not provide sufficient control to select the
     specific register you want, local register variables may provide a
     solution (*note Local Reg Vars::).

CVARIABLENAME
     Specifies a C lvalue expression to hold the output, typically a
     variable name.  The enclosing parentheses are a required part of
     the syntax.

 When the compiler selects the registers to use to represent the output
operands, it does not use any of the clobbered registers (*note
Clobbers::).

 Output operand expressions must be lvalues.  The compiler cannot check
whether the operands have data types that are reasonable for the
instruction being executed.  For output expressions that are not
directly addressable (for example a bit-field), the constraint must
allow a register.  In that case, GCC uses the register as the output of
the 'asm', and then stores that register into the output.

 Operands using the '+' constraint modifier count as two operands (that
is, both as input and output) towards the total maximum of 30 operands
per 'asm' statement.

 Use the '&' constraint modifier (*note Modifiers::) on all output
operands that must not overlap an input.  Otherwise, GCC may allocate
the output operand in the same register as an unrelated input operand,
on the assumption that the assembler code consumes its inputs before
producing outputs.  This assumption may be false if the assembler code
actually consists of more than one instruction.

 The same problem can occur if one output parameter (A) allows a
register constraint and another output parameter (B) allows a memory
constraint.  The code generated by GCC to access the memory address in B
can contain registers which _might_ be shared by A, and GCC considers
those registers to be inputs to the asm.  As above, GCC assumes that
such input registers are consumed before any outputs are written.  This
assumption may result in incorrect behavior if the asm writes to A
before using B.  Combining the '&' modifier with the register constraint
on A ensures that modifying A does not affect the address referenced by
B.  Otherwise, the location of B is undefined if A is modified before
using B.

 'asm' supports operand modifiers on operands (for example '%k2' instead
of simply '%2').  Typically these qualifiers are hardware dependent.
The list of supported modifiers for x86 is found at *note x86 Operand
modifiers: x86Operandmodifiers.

 If the C code that follows the 'asm' makes no use of any of the output
operands, use 'volatile' for the 'asm' statement to prevent the
optimizers from discarding the 'asm' statement as unneeded (see *note
Volatile::).

 This code makes no use of the optional ASMSYMBOLICNAME.  Therefore it
references the first output operand as '%0' (were there a second, it
would be '%1', etc).  The number of the first input operand is one
greater than that of the last output operand.  In this i386 example,
that makes 'Mask' referenced as '%1':

     uint32_t Mask = 1234;
     uint32_t Index;

       asm ("bsfl %1, %0"
          : "=r" (Index)
          : "r" (Mask)
          : "cc");

 That code overwrites the variable 'Index' ('='), placing the value in a
register ('r').  Using the generic 'r' constraint instead of a
constraint for a specific register allows the compiler to pick the
register to use, which can result in more efficient code.  This may not
be possible if an assembler instruction requires a specific register.

 The following i386 example uses the ASMSYMBOLICNAME syntax.  It
produces the same result as the code above, but some may consider it
more readable or more maintainable since reordering index numbers is not
necessary when adding or removing operands.  The names 'aIndex' and
'aMask' are only used in this example to emphasize which names get used
where.  It is acceptable to reuse the names 'Index' and 'Mask'.

     uint32_t Mask = 1234;
     uint32_t Index;

       asm ("bsfl %[aMask], %[aIndex]"
          : [aIndex] "=r" (Index)
          : [aMask] "r" (Mask)
          : "cc");

 Here are some more examples of output operands.

     uint32_t c = 1;
     uint32_t d;
     uint32_t *e = &c;

     asm ("mov %[e], %[d]"
        : [d] "=rm" (d)
        : [e] "rm" (*e));

 Here, 'd' may either be in a register or in memory.  Since the compiler
might already have the current value of the 'uint32_t' location pointed
to by 'e' in a register, you can enable it to choose the best location
for 'd' by specifying both constraints.

6.43.2.4 Input Operands
.......................

Input operands make values from C variables and expressions available to
the assembly code.

 Operands are separated by commas.  Each operand has this format:

     [ [ASMSYMBOLICNAME] ] CONSTRAINT (CEXPRESSION)

ASMSYMBOLICNAME
     Specifies a symbolic name for the operand.  Reference the name in
     the assembler template by enclosing it in square brackets (i.e.
     '%[Value]').  The scope of the name is the 'asm' statement that
     contains the definition.  Any valid C variable name is acceptable,
     including names already defined in the surrounding code.  No two
     operands within the same 'asm' statement can use the same symbolic
     name.

     When not using an ASMSYMBOLICNAME, use the (zero-based) position of
     the operand in the list of operands in the assembler template.  For
     example if there are two output operands and three inputs, use '%2'
     in the template to refer to the first input operand, '%3' for the
     second, and '%4' for the third.

CONSTRAINT
     A string constant specifying constraints on the placement of the
     operand; *Note Constraints::, for details.

     Input constraint strings may not begin with either '=' or '+'.
     When you list more than one possible location (for example,
     '"irm"'), the compiler chooses the most efficient one based on the
     current context.  If you must use a specific register, but your
     Machine Constraints do not provide sufficient control to select the
     specific register you want, local register variables may provide a
     solution (*note Local Reg Vars::).

     Input constraints can also be digits (for example, '"0"').  This
     indicates that the specified input must be in the same place as the
     output constraint at the (zero-based) index in the output
     constraint list.  When using ASMSYMBOLICNAME syntax for the output
     operands, you may use these names (enclosed in brackets '[]')
     instead of digits.

CEXPRESSION
     This is the C variable or expression being passed to the 'asm'
     statement as input.  The enclosing parentheses are a required part
     of the syntax.

 When the compiler selects the registers to use to represent the input
operands, it does not use any of the clobbered registers (*note
Clobbers::).

 If there are no output operands but there are input operands, place two
consecutive colons where the output operands would go:

     __asm__ ("some instructions"
        : /* No outputs. */
        : "r" (Offset / 8));

 *Warning:* Do _not_ modify the contents of input-only operands (except
for inputs tied to outputs).  The compiler assumes that on exit from the
'asm' statement these operands contain the same values as they had
before executing the statement.  It is _not_ possible to use clobbers to
inform the compiler that the values in these inputs are changing.  One
common work-around is to tie the changing input variable to an output
variable that never gets used.  Note, however, that if the code that
follows the 'asm' statement makes no use of any of the output operands,
the GCC optimizers may discard the 'asm' statement as unneeded (see
*note Volatile::).

 'asm' supports operand modifiers on operands (for example '%k2' instead
of simply '%2').  Typically these qualifiers are hardware dependent.
The list of supported modifiers for x86 is found at *note x86 Operand
modifiers: x86Operandmodifiers.

 In this example using the fictitious 'combine' instruction, the
constraint '"0"' for input operand 1 says that it must occupy the same
location as output operand 0.  Only input operands may use numbers in
constraints, and they must each refer to an output operand.  Only a
number (or the symbolic assembler name) in the constraint can guarantee
that one operand is in the same place as another.  The mere fact that
'foo' is the value of both operands is not enough to guarantee that they
are in the same place in the generated assembler code.

     asm ("combine %2, %0"
        : "=r" (foo)
        : "0" (foo), "g" (bar));

 Here is an example using symbolic names.

     asm ("cmoveq %1, %2, %[result]"
        : [result] "=r"(result)
        : "r" (test), "r" (new), "[result]" (old));

6.43.2.5 Clobbers
.................

While the compiler is aware of changes to entries listed in the output
operands, the inline 'asm' code may modify more than just the outputs.
For example, calculations may require additional registers, or the
processor may overwrite a register as a side effect of a particular
assembler instruction.  In order to inform the compiler of these
changes, list them in the clobber list.  Clobber list items are either
register names or the special clobbers (listed below).  Each clobber
list item is a string constant enclosed in double quotes and separated
by commas.

 Clobber descriptions may not in any way overlap with an input or output
operand.  For example, you may not have an operand describing a register
class with one member when listing that register in the clobber list.
Variables declared to live in specific registers (*note Explicit Reg
Vars::) and used as 'asm' input or output operands must have no part
mentioned in the clobber description.  In particular, there is no way to
specify that input operands get modified without also specifying them as
output operands.

 When the compiler selects which registers to use to represent input and
output operands, it does not use any of the clobbered registers.  As a
result, clobbered registers are available for any use in the assembler
code.

 Here is a realistic example for the VAX showing the use of clobbered
registers:

     asm volatile ("movc3 %0, %1, %2"
                        : /* No outputs. */
                        : "g" (from), "g" (to), "g" (count)
                        : "r0", "r1", "r2", "r3", "r4", "r5");

 Also, there are two special clobber arguments:

'"cc"'
     The '"cc"' clobber indicates that the assembler code modifies the
     flags register.  On some machines, GCC represents the condition
     codes as a specific hardware register; '"cc"' serves to name this
     register.  On other machines, condition code handling is different,
     and specifying '"cc"' has no effect.  But it is valid no matter
     what the target.

'"memory"'
     The '"memory"' clobber tells the compiler that the assembly code
     performs memory reads or writes to items other than those listed in
     the input and output operands (for example, accessing the memory
     pointed to by one of the input parameters).  To ensure memory
     contains correct values, GCC may need to flush specific register
     values to memory before executing the 'asm'.  Further, the compiler
     does not assume that any values read from memory before an 'asm'
     remain unchanged after that 'asm'; it reloads them as needed.
     Using the '"memory"' clobber effectively forms a read/write memory
     barrier for the compiler.

     Note that this clobber does not prevent the _processor_ from doing
     speculative reads past the 'asm' statement.  To prevent that, you
     need processor-specific fence instructions.

     Flushing registers to memory has performance implications and may
     be an issue for time-sensitive code.  You can use a trick to avoid
     this if the size of the memory being accessed is known at compile
     time.  For example, if accessing ten bytes of a string, use a
     memory input like:

     '{"m"( ({ struct { char x[10]; } *p = (void *)ptr ; *p; }) )}'.

6.43.2.6 Goto Labels
....................

'asm goto' allows assembly code to jump to one or more C labels.  The
GOTOLABELS section in an 'asm goto' statement contains a comma-separated
list of all C labels to which the assembler code may jump.  GCC assumes
that 'asm' execution falls through to the next statement (if this is not
the case, consider using the '__builtin_unreachable' intrinsic after the
'asm' statement).  Optimization of 'asm goto' may be improved by using
the 'hot' and 'cold' label attributes (*note Label Attributes::).

 An 'asm goto' statement cannot have outputs.  This is due to an
internal restriction of the compiler: control transfer instructions
cannot have outputs.  If the assembler code does modify anything, use
the '"memory"' clobber to force the optimizers to flush all register
values to memory and reload them if necessary after the 'asm' statement.

 Also note that an 'asm goto' statement is always implicitly considered
volatile.

 To reference a label in the assembler template, prefix it with '%l'
(lowercase 'L') followed by its (zero-based) position in GOTOLABELS plus
the number of input operands.  For example, if the 'asm' has three
inputs and references two labels, refer to the first label as '%l3' and
the second as '%l4').

 Alternately, you can reference labels using the actual C label name
enclosed in brackets.  For example, to reference a label named 'carry',
you can use '%l[carry]'.  The label must still be listed in the
GOTOLABELS section when using this approach.

 Here is an example of 'asm goto' for i386:

     asm goto (
         "btl %1, %0\n\t"
         "jc %l2"
         : /* No outputs. */
         : "r" (p1), "r" (p2)
         : "cc"
         : carry);

     return 0;

     carry:
     return 1;

 The following example shows an 'asm goto' that uses a memory clobber.

     int frob(int x)
     {
       int y;
       asm goto ("frob %%r5, %1; jc %l[error]; mov (%2), %%r5"
                 : /* No outputs. */
                 : "r"(x), "r"(&y)
                 : "r5", "memory"
                 : error);
       return y;
     error:
       return -1;
     }

6.43.2.7 x86 Operand Modifiers
..............................

References to input, output, and goto operands in the assembler template
of extended 'asm' statements can use modifiers to affect the way the
operands are formatted in the code output to the assembler.  For
example, the following code uses the 'h' and 'b' modifiers for x86:

     uint16_t  num;
     asm volatile ("xchg %h0, %b0" : "+a" (num) );

These modifiers generate this assembler code:

     xchg %ah, %al

 The rest of this discussion uses the following code for illustrative
purposes.

     int main()
     {
        int iInt = 1;

     top:

        asm volatile goto ("some assembler instructions here"
        : /* No outputs. */
        : "q" (iInt), "X" (sizeof(unsigned char) + 1)
        : /* No clobbers. */
        : top);
     }

 With no modifiers, this is what the output from the operands would be
for the 'att' and 'intel' dialects of assembler:

Operand   masm=att   masm=intel
---------------------------------------
'%0'      '%eax'     'eax'
'%1'      '$2'       '2'
'%2'      '$.L2'     'OFFSET
                     FLAT:.L2'

 The table below shows the list of supported modifiers and their
effects.

Modifier   Description                                  Operand   'masm=att' 'masm=intel'
------------------------------------------------------------------------------------------
'z'        Print the opcode suffix for the size of      '%z0'     'l'
           the current integer operand (one of
           'b'/'w'/'l'/'q').
'b'        Print the QImode name of the register.       '%b0'     '%al'      'al'
'h'        Print the QImode name for a "high"           '%h0'     '%ah'      'ah'
           register.
'w'        Print the HImode name of the register.       '%w0'     '%ax'      'ax'
'k'        Print the SImode name of the register.       '%k0'     '%eax'     'eax'
'q'        Print the DImode name of the register.       '%q0'     '%rax'     'rax'
'l'        Print the label name with no punctuation.    '%l2'     '.L2'      '.L2'
'c'        Require a constant operand and print the     '%c1'     '2'        '2'
           constant expression with no punctuation.

6.43.2.8 x86 Floating-Point 'asm' Operands
..........................................

On x86 targets, there are several rules on the usage of stack-like
registers in the operands of an 'asm'.  These rules apply only to the
operands that are stack-like registers:

  1. Given a set of input registers that die in an 'asm', it is
     necessary to know which are implicitly popped by the 'asm', and
     which must be explicitly popped by GCC.

     An input register that is implicitly popped by the 'asm' must be
     explicitly clobbered, unless it is constrained to match an output
     operand.

  2. For any input register that is implicitly popped by an 'asm', it is
     necessary to know how to adjust the stack to compensate for the
     pop.  If any non-popped input is closer to the top of the reg-stack
     than the implicitly popped register, it would not be possible to
     know what the stack looked like--it's not clear how the rest of the
     stack "slides up".

     All implicitly popped input registers must be closer to the top of
     the reg-stack than any input that is not implicitly popped.

     It is possible that if an input dies in an 'asm', the compiler
     might use the input register for an output reload.  Consider this
     example:

          asm ("foo" : "=t" (a) : "f" (b));

     This code says that input 'b' is not popped by the 'asm', and that
     the 'asm' pushes a result onto the reg-stack, i.e., the stack is
     one deeper after the 'asm' than it was before.  But, it is possible
     that reload may think that it can use the same register for both
     the input and the output.

     To prevent this from happening, if any input operand uses the 'f'
     constraint, all output register constraints must use the '&'
     early-clobber modifier.

     The example above is correctly written as:

          asm ("foo" : "=&t" (a) : "f" (b));

  3. Some operands need to be in particular places on the stack.  All
     output operands fall in this category--GCC has no other way to know
     which registers the outputs appear in unless you indicate this in
     the constraints.

     Output operands must specifically indicate which register an output
     appears in after an 'asm'.  '=f' is not allowed: the operand
     constraints must select a class with a single register.

  4. Output operands may not be "inserted" between existing stack
     registers.  Since no 387 opcode uses a read/write operand, all
     output operands are dead before the 'asm', and are pushed by the
     'asm'.  It makes no sense to push anywhere but the top of the
     reg-stack.

     Output operands must start at the top of the reg-stack: output
     operands may not "skip" a register.

  5. Some 'asm' statements may need extra stack space for internal
     calculations.  This can be guaranteed by clobbering stack registers
     unrelated to the inputs and outputs.

 This 'asm' takes one input, which is internally popped, and produces
two outputs.

     asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));

This 'asm' takes two inputs, which are popped by the 'fyl2xp1' opcode,
and replaces them with one output.  The 'st(1)' clobber is necessary for
the compiler to know that 'fyl2xp1' pops both inputs.

     asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");


File: llvm.info,  Node: Constraints,  Next: Asm Labels,  Prev: Extended Asm,  Up: Using Assembly Language with C

6.43.3 Constraints for 'asm' Operands
-------------------------------------

Here are specific details on what constraint letters you can use with
'asm' operands.  Constraints can say whether an operand may be in a
register, and which kinds of register; whether the operand can be a
memory reference, and which kinds of address; whether the operand may be
an immediate constant, and which possible values it may have.
Constraints can also require two operands to match.  Side-effects aren't
allowed in operands of inline 'asm', unless '<' or '>' constraints are
used, because there is no guarantee that the side-effects will happen
exactly once in an instruction that can update the addressing register.

* Menu:

* Simple Constraints::  Basic use of constraints.
* Multi-Alternative::   When an insn has two alternative constraint-patterns.
* Modifiers::           More precise control over effects of constraints.
* Machine Constraints:: Special constraints for some particular machines.


File: llvm.info,  Node: Simple Constraints,  Next: Multi-Alternative,  Up: Constraints

6.43.3.1 Simple Constraints
...........................

The simplest kind of constraint is a string full of letters, each of
which describes one kind of operand that is permitted.  Here are the
letters that are allowed:

whitespace
     Whitespace characters are ignored and can be inserted at any
     position except the first.  This enables each alternative for
     different operands to be visually aligned in the machine
     description even if they have different number of constraints and
     modifiers.

'm'
     A memory operand is allowed, with any kind of address that the
     machine supports in general.  Note that the letter used for the
     general memory constraint can be re-defined by a back end using the
     'TARGET_MEM_CONSTRAINT' macro.

'o'
     A memory operand is allowed, but only if the address is
     "offsettable".  This means that adding a small integer (actually,
     the width in bytes of the operand, as determined by its machine
     mode) may be added to the address and the result is also a valid
     memory address.

     For example, an address which is constant is offsettable; so is an
     address that is the sum of a register and a constant (as long as a
     slightly larger constant is also within the range of
     address-offsets supported by the machine); but an autoincrement or
     autodecrement address is not offsettable.  More complicated
     indirect/indexed addresses may or may not be offsettable depending
     on the other addressing modes that the machine supports.

     Note that in an output operand which can be matched by another
     operand, the constraint letter 'o' is valid only when accompanied
     by both '<' (if the target machine has predecrement addressing) and
     '>' (if the target machine has preincrement addressing).

'V'
     A memory operand that is not offsettable.  In other words, anything
     that would fit the 'm' constraint but not the 'o' constraint.

'<'
     A memory operand with autodecrement addressing (either predecrement
     or postdecrement) is allowed.  In inline 'asm' this constraint is
     only allowed if the operand is used exactly once in an instruction
     that can handle the side-effects.  Not using an operand with '<' in
     constraint string in the inline 'asm' pattern at all or using it in
     multiple instructions isn't valid, because the side-effects
     wouldn't be performed or would be performed more than once.
     Furthermore, on some targets the operand with '<' in constraint
     string must be accompanied by special instruction suffixes like
     '%U0' instruction suffix on PowerPC or '%P0' on IA-64.

'>'
     A memory operand with autoincrement addressing (either preincrement
     or postincrement) is allowed.  In inline 'asm' the same
     restrictions as for '<' apply.

'r'
     A register operand is allowed provided that it is in a general
     register.

'i'
     An immediate integer operand (one with constant value) is allowed.
     This includes symbolic constants whose values will be known only at
     assembly time or later.

'n'
     An immediate integer operand with a known numeric value is allowed.
     Many systems cannot support assembly-time constants for operands
     less than a word wide.  Constraints for these operands should use
     'n' rather than 'i'.

'I', 'J', 'K', ... 'P'
     Other letters in the range 'I' through 'P' may be defined in a
     machine-dependent fashion to permit immediate integer operands with
     explicit integer values in specified ranges.  For example, on the
     68000, 'I' is defined to stand for the range of values 1 to 8.
     This is the range permitted as a shift count in the shift
     instructions.

'E'
     An immediate floating operand (expression code 'const_double') is
     allowed, but only if the target floating point format is the same
     as that of the host machine (on which the compiler is running).

'F'
     An immediate floating operand (expression code 'const_double' or
     'const_vector') is allowed.

'G', 'H'
     'G' and 'H' may be defined in a machine-dependent fashion to permit
     immediate floating operands in particular ranges of values.

's'
     An immediate integer operand whose value is not an explicit integer
     is allowed.

     This might appear strange; if an insn allows a constant operand
     with a value not known at compile time, it certainly must allow any
     known value.  So why use 's' instead of 'i'?  Sometimes it allows
     better code to be generated.

     For example, on the 68000 in a fullword instruction it is possible
     to use an immediate operand; but if the immediate value is between
     -128 and 127, better code results from loading the value into a
     register and using the register.  This is because the load into the
     register can be done with a 'moveq' instruction.  We arrange for
     this to happen by defining the letter 'K' to mean "any integer
     outside the range -128 to 127", and then specifying 'Ks' in the
     operand constraints.

'g'
     Any register, memory or immediate integer operand is allowed,
     except for registers that are not general registers.

'X'
     Any operand whatsoever is allowed.

'0', '1', '2', ... '9'
     An operand that matches the specified operand number is allowed.
     If a digit is used together with letters within the same
     alternative, the digit should come last.

     This number is allowed to be more than a single digit.  If multiple
     digits are encountered consecutively, they are interpreted as a
     single decimal integer.  There is scant chance for ambiguity, since
     to-date it has never been desirable that '10' be interpreted as
     matching either operand 1 _or_ operand 0.  Should this be desired,
     one can use multiple alternatives instead.

     This is called a "matching constraint" and what it really means is
     that the assembler has only a single operand that fills two roles
     which 'asm' distinguishes.  For example, an add instruction uses
     two input operands and an output operand, but on most CISC machines
     an add instruction really has only two operands, one of them an
     input-output operand:

          addl #35,r12

     Matching constraints are used in these circumstances.  More
     precisely, the two operands that match must include one input-only
     operand and one output-only operand.  Moreover, the digit must be a
     smaller number than the number of the operand that uses it in the
     constraint.

'p'
     An operand that is a valid memory address is allowed.  This is for
     "load address" and "push address" instructions.

     'p' in the constraint must be accompanied by 'address_operand' as
     the predicate in the 'match_operand'.  This predicate interprets
     the mode specified in the 'match_operand' as the mode of the memory
     reference for which the address would be valid.

OTHER-LETTERS
     Other letters can be defined in machine-dependent fashion to stand
     for particular classes of registers or other arbitrary operand
     types.  'd', 'a' and 'f' are defined on the 68000/68020 to stand
     for data, address and floating point registers.


File: llvm.info,  Node: Multi-Alternative,  Next: Modifiers,  Prev: Simple Constraints,  Up: Constraints

6.43.3.2 Multiple Alternative Constraints
.........................................

Sometimes a single instruction has multiple alternative sets of possible
operands.  For example, on the 68000, a logical-or instruction can
combine register or an immediate value into memory, or it can combine
any kind of operand into a register; but it cannot combine one memory
location into another.

 These constraints are represented as multiple alternatives.  An
alternative can be described by a series of letters for each operand.
The overall constraint for an operand is made from the letters for this
operand from the first alternative, a comma, the letters for this
operand from the second alternative, a comma, and so on until the last
alternative.

 If all the operands fit any one alternative, the instruction is valid.
Otherwise, for each alternative, the compiler counts how many
instructions must be added to copy the operands so that that alternative
applies.  The alternative requiring the least copying is chosen.  If two
alternatives need the same amount of copying, the one that comes first
is chosen.  These choices can be altered with the '?' and '!'
characters:

'?'
     Disparage slightly the alternative that the '?' appears in, as a
     choice when no alternative applies exactly.  The compiler regards
     this alternative as one unit more costly for each '?' that appears
     in it.

'!'
     Disparage severely the alternative that the '!' appears in.  This
     alternative can still be used if it fits without reloading, but if
     reloading is needed, some other alternative will be used.

'^'
     This constraint is analogous to '?' but it disparages slightly the
     alternative only if the operand with the '^' needs a reload.

'$'
     This constraint is analogous to '!' but it disparages severely the
     alternative only if the operand with the '$' needs a reload.


File: llvm.info,  Node: Modifiers,  Next: Machine Constraints,  Prev: Multi-Alternative,  Up: Constraints

6.43.3.3 Constraint Modifier Characters
.......................................

Here are constraint modifier characters.

'='
     Means that this operand is written to by this instruction: the
     previous value is discarded and replaced by new data.

'+'
     Means that this operand is both read and written by the
     instruction.

     When the compiler fixes up the operands to satisfy the constraints,
     it needs to know which operands are read by the instruction and
     which are written by it.  '=' identifies an operand which is only
     written; '+' identifies an operand that is both read and written;
     all other operands are assumed to only be read.

     If you specify '=' or '+' in a constraint, you put it in the first
     character of the constraint string.

'&'
     Means (in a particular alternative) that this operand is an
     "earlyclobber" operand, which is written before the instruction is
     finished using the input operands.  Therefore, this operand may not
     lie in a register that is read by the instruction or as part of any
     memory address.

     '&' applies only to the alternative in which it is written.  In
     constraints with multiple alternatives, sometimes one alternative
     requires '&' while others do not.  See, for example, the 'movdf'
     insn of the 68000.

     A operand which is read by the instruction can be tied to an
     earlyclobber operand if its only use as an input occurs before the
     early result is written.  Adding alternatives of this form often
     allows GCC to produce better code when only some of the read
     operands can be affected by the earlyclobber.  See, for example,
     the 'mulsi3' insn of the ARM.

     Furthermore, if the "earlyclobber" operand is also a read/write
     operand, then that operand is written only after it's used.

     '&' does not obviate the need to write '=' or '+'.  As
     "earlyclobber" operands are always written, a read-only
     "earlyclobber" operand is ill-formed and will be rejected by the
     compiler.

'%'
     Declares the instruction to be commutative for this operand and the
     following operand.  This means that the compiler may interchange
     the two operands if that is the cheapest way to make all operands
     fit the constraints.  '%' applies to all alternatives and must
     appear as the first character in the constraint.  Only read-only
     operands can use '%'.

     GCC can only handle one commutative pair in an asm; if you use
     more, the compiler may fail.  Note that you need not use the
     modifier if the two alternatives are strictly identical; this would
     only waste time in the reload pass.  The modifier is not
     operational after register allocation, so the result of
     'define_peephole2' and 'define_split's performed after reload
     cannot rely on '%' to make the intended insn match.

'#'
     Says that all following characters, up to the next comma, are to be
     ignored as a constraint.  They are significant only for choosing
     register preferences.

'*'
     Says that the following character should be ignored when choosing
     register preferences.  '*' has no effect on the meaning of the
     constraint as a constraint, and no effect on reloading.  For LRA
     '*' additionally disparages slightly the alternative if the
     following character matches the operand.


File: llvm.info,  Node: Machine Constraints,  Prev: Modifiers,  Up: Constraints

6.43.3.4 Constraints for Particular Machines
............................................

Whenever possible, you should use the general-purpose constraint letters
in 'asm' arguments, since they will convey meaning more readily to
people reading your code.  Failing that, use the constraint letters that
usually have very similar meanings across architectures.  The most
commonly used constraints are 'm' and 'r' (for memory and
general-purpose registers respectively; *note Simple Constraints::), and
'I', usually the letter indicating the most common immediate-constant
format.

 Each architecture defines additional constraints.  These constraints
are used by the compiler itself for instruction generation, as well as
for 'asm' statements; therefore, some of the constraints are not
particularly useful for 'asm'.  Here is a summary of some of the
machine-dependent constraints available on some particular machines; it
includes both constraints that are useful for 'asm' and constraints that
aren't.  The compiler source file mentioned in the table heading for
each architecture is the definitive reference for the meanings of that
architecture's constraints.

_AArch64 family--'config/aarch64/constraints.md'_
     'k'
          The stack pointer register ('SP')

     'w'
          Floating point or SIMD vector register

     'I'
          Integer constant that is valid as an immediate operand in an
          'ADD' instruction

     'J'
          Integer constant that is valid as an immediate operand in a
          'SUB' instruction (once negated)

     'K'
          Integer constant that can be used with a 32-bit logical
          instruction

     'L'
          Integer constant that can be used with a 64-bit logical
          instruction

     'M'
          Integer constant that is valid as an immediate operand in a
          32-bit 'MOV' pseudo instruction.  The 'MOV' may be assembled
          to one of several different machine instructions depending on
          the value

     'N'
          Integer constant that is valid as an immediate operand in a
          64-bit 'MOV' pseudo instruction

     'S'
          An absolute symbolic address or a label reference

     'Y'
          Floating point constant zero

     'Z'
          Integer constant zero

     'Ush'
          The high part (bits 12 and upwards) of the pc-relative address
          of a symbol within 4GB of the instruction

     'Q'
          A memory address which uses a single base register with no
          offset

     'Ump'
          A memory address suitable for a load/store pair instruction in
          SI, DI, SF and DF modes

_ARC --'config/arc/constraints.md'_
     'q'
          Registers usable in ARCompact 16-bit instructions: 'r0'-'r3',
          'r12'-'r15'.  This constraint can only match when the '-mq'
          option is in effect.

     'e'
          Registers usable as base-regs of memory addresses in ARCompact
          16-bit memory instructions: 'r0'-'r3', 'r12'-'r15', 'sp'.
          This constraint can only match when the '-mq' option is in
          effect.
     'D'
          ARC FPX (dpfp) 64-bit registers.  'D0', 'D1'.

     'I'
          A signed 12-bit integer constant.

     'Cal'
          constant for arithmetic/logical operations.  This might be any
          constant that can be put into a long immediate by the assmbler
          or linker without involving a PIC relocation.

     'K'
          A 3-bit unsigned integer constant.

     'L'
          A 6-bit unsigned integer constant.

     'CnL'
          One's complement of a 6-bit unsigned integer constant.

     'CmL'
          Two's complement of a 6-bit unsigned integer constant.

     'M'
          A 5-bit unsigned integer constant.

     'O'
          A 7-bit unsigned integer constant.

     'P'
          A 8-bit unsigned integer constant.

     'H'
          Any const_double value.

_ARM family--'config/arm/constraints.md'_

     'h'
          In Thumb state, the core registers 'r8'-'r15'.

     'k'
          The stack pointer register.

     'l'
          In Thumb State the core registers 'r0'-'r7'.  In ARM state
          this is an alias for the 'r' constraint.

     't'
          VFP floating-point registers 's0'-'s31'.  Used for 32 bit
          values.

     'w'
          VFP floating-point registers 'd0'-'d31' and the appropriate
          subset 'd0'-'d15' based on command line options.  Used for 64
          bit values only.  Not valid for Thumb1.

     'y'
          The iWMMX co-processor registers.

     'z'
          The iWMMX GR registers.

     'G'
          The floating-point constant 0.0

     'I'
          Integer that is valid as an immediate operand in a data
          processing instruction.  That is, an integer in the range 0 to
          255 rotated by a multiple of 2

     'J'
          Integer in the range -4095 to 4095

     'K'
          Integer that satisfies constraint 'I' when inverted (ones
          complement)

     'L'
          Integer that satisfies constraint 'I' when negated (twos
          complement)

     'M'
          Integer in the range 0 to 32

     'Q'
          A memory reference where the exact address is in a single
          register (''m'' is preferable for 'asm' statements)

     'R'
          An item in the constant pool

     'S'
          A symbol in the text segment of the current file

     'Uv'
          A memory reference suitable for VFP load/store insns
          (reg+constant offset)

     'Uy'
          A memory reference suitable for iWMMXt load/store
          instructions.

     'Uq'
          A memory reference suitable for the ARMv4 ldrsb instruction.

_AVR family--'config/avr/constraints.md'_
     'l'
          Registers from r0 to r15

     'a'
          Registers from r16 to r23

     'd'
          Registers from r16 to r31

     'w'
          Registers from r24 to r31.  These registers can be used in
          'adiw' command

     'e'
          Pointer register (r26-r31)

     'b'
          Base pointer register (r28-r31)

     'q'
          Stack pointer register (SPH:SPL)

     't'
          Temporary register r0

     'x'
          Register pair X (r27:r26)

     'y'
          Register pair Y (r29:r28)

     'z'
          Register pair Z (r31:r30)

     'I'
          Constant greater than -1, less than 64

     'J'
          Constant greater than -64, less than 1

     'K'
          Constant integer 2

     'L'
          Constant integer 0

     'M'
          Constant that fits in 8 bits

     'N'
          Constant integer -1

     'O'
          Constant integer 8, 16, or 24

     'P'
          Constant integer 1

     'G'
          A floating point constant 0.0

     'Q'
          A memory address based on Y or Z pointer with displacement.

_Blackfin family--'config/bfin/constraints.md'_
     'a'
          P register

     'd'
          D register

     'z'
          A call clobbered P register.

     'qN'
          A single register.  If N is in the range 0 to 7, the
          corresponding D register.  If it is 'A', then the register P0.

     'D'
          Even-numbered D register

     'W'
          Odd-numbered D register

     'e'
          Accumulator register.

     'A'
          Even-numbered accumulator register.

     'B'
          Odd-numbered accumulator register.

     'b'
          I register

     'v'
          B register

     'f'
          M register

     'c'
          Registers used for circular buffering, i.e.  I, B, or L
          registers.

     'C'
          The CC register.

     't'
          LT0 or LT1.

     'k'
          LC0 or LC1.

     'u'
          LB0 or LB1.

     'x'
          Any D, P, B, M, I or L register.

     'y'
          Additional registers typically used only in prologues and
          epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and
          USP.

     'w'
          Any register except accumulators or CC.

     'Ksh'
          Signed 16 bit integer (in the range -32768 to 32767)

     'Kuh'
          Unsigned 16 bit integer (in the range 0 to 65535)

     'Ks7'
          Signed 7 bit integer (in the range -64 to 63)

     'Ku7'
          Unsigned 7 bit integer (in the range 0 to 127)

     'Ku5'
          Unsigned 5 bit integer (in the range 0 to 31)

     'Ks4'
          Signed 4 bit integer (in the range -8 to 7)

     'Ks3'
          Signed 3 bit integer (in the range -3 to 4)

     'Ku3'
          Unsigned 3 bit integer (in the range 0 to 7)

     'PN'
          Constant N, where N is a single-digit constant in the range 0
          to 4.

     'PA'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use with either accumulator.

     'PB'
          An integer equal to one of the MACFLAG_XXX constants that is
          suitable for use only with accumulator A1.

     'M1'
          Constant 255.

     'M2'
          Constant 65535.

     'J'
          An integer constant with exactly a single bit set.

     'L'
          An integer constant with all bits set except exactly one.

     'H'

     'Q'
          Any SYMBOL_REF.

_CR16 Architecture--'config/cr16/cr16.h'_

     'b'
          Registers from r0 to r14 (registers without stack pointer)

     't'
          Register from r0 to r11 (all 16-bit registers)

     'p'
          Register from r12 to r15 (all 32-bit registers)

     'I'
          Signed constant that fits in 4 bits

     'J'
          Signed constant that fits in 5 bits

     'K'
          Signed constant that fits in 6 bits

     'L'
          Unsigned constant that fits in 4 bits

     'M'
          Signed constant that fits in 32 bits

     'N'
          Check for 64 bits wide constants for add/sub instructions

     'G'
          Floating point constant that is legal for store immediate

_Epiphany--'config/epiphany/constraints.md'_
     'U16'
          An unsigned 16-bit constant.

     'K'
          An unsigned 5-bit constant.

     'L'
          A signed 11-bit constant.

     'Cm1'
          A signed 11-bit constant added to -1.  Can only match when the
          '-m1reg-REG' option is active.

     'Cl1'
          Left-shift of -1, i.e., a bit mask with a block of leading
          ones, the rest being a block of trailing zeroes.  Can only
          match when the '-m1reg-REG' option is active.

     'Cr1'
          Right-shift of -1, i.e., a bit mask with a trailing block of
          ones, the rest being zeroes.  Or to put it another way, one
          less than a power of two.  Can only match when the
          '-m1reg-REG' option is active.

     'Cal'
          Constant for arithmetic/logical operations.  This is like 'i',
          except that for position independent code, no symbols /
          expressions needing relocations are allowed.

     'Csy'
          Symbolic constant for call/jump instruction.

     'Rcs'
          The register class usable in short insns.  This is a register
          class constraint, and can thus drive register allocation.
          This constraint won't match unless '-mprefer-short-insn-regs'
          is in effect.

     'Rsc'
          The the register class of registers that can be used to hold a
          sibcall call address.  I.e., a caller-saved register.

     'Rct'
          Core control register class.

     'Rgs'
          The register group usable in short insns.  This constraint
          does not use a register class, so that it only passively
          matches suitable registers, and doesn't drive register
          allocation.

     'Rra'
          Matches the return address if it can be replaced with the link
          register.

     'Rcc'
          Matches the integer condition code register.

     'Sra'
          Matches the return address if it is in a stack slot.

     'Cfm'
          Matches control register values to switch fp mode, which are
          encapsulated in 'UNSPEC_FP_MODE'.

_FRV--'config/frv/frv.h'_
     'a'
          Register in the class 'ACC_REGS' ('acc0' to 'acc7').

     'b'
          Register in the class 'EVEN_ACC_REGS' ('acc0' to 'acc7').

     'c'
          Register in the class 'CC_REGS' ('fcc0' to 'fcc3' and 'icc0'
          to 'icc3').

     'd'
          Register in the class 'GPR_REGS' ('gr0' to 'gr63').

     'e'
          Register in the class 'EVEN_REGS' ('gr0' to 'gr63').  Odd
          registers are excluded not in the class but through the use of
          a machine mode larger than 4 bytes.

     'f'
          Register in the class 'FPR_REGS' ('fr0' to 'fr63').

     'h'
          Register in the class 'FEVEN_REGS' ('fr0' to 'fr63').  Odd
          registers are excluded not in the class but through the use of
          a machine mode larger than 4 bytes.

     'l'
          Register in the class 'LR_REG' (the 'lr' register).

     'q'
          Register in the class 'QUAD_REGS' ('gr2' to 'gr63').  Register
          numbers not divisible by 4 are excluded not in the class but
          through the use of a machine mode larger than 8 bytes.

     't'
          Register in the class 'ICC_REGS' ('icc0' to 'icc3').

     'u'
          Register in the class 'FCC_REGS' ('fcc0' to 'fcc3').

     'v'
          Register in the class 'ICR_REGS' ('cc4' to 'cc7').

     'w'
          Register in the class 'FCR_REGS' ('cc0' to 'cc3').

     'x'
          Register in the class 'QUAD_FPR_REGS' ('fr0' to 'fr63').
          Register numbers not divisible by 4 are excluded not in the
          class but through the use of a machine mode larger than 8
          bytes.

     'z'
          Register in the class 'SPR_REGS' ('lcr' and 'lr').

     'A'
          Register in the class 'QUAD_ACC_REGS' ('acc0' to 'acc7').

     'B'
          Register in the class 'ACCG_REGS' ('accg0' to 'accg7').

     'C'
          Register in the class 'CR_REGS' ('cc0' to 'cc7').

     'G'
          Floating point constant zero

     'I'
          6-bit signed integer constant

     'J'
          10-bit signed integer constant

     'L'
          16-bit signed integer constant

     'M'
          16-bit unsigned integer constant

     'N'
          12-bit signed integer constant that is negative--i.e. in the
          range of -2048 to -1

     'O'
          Constant zero

     'P'
          12-bit signed integer constant that is greater than zero--i.e.
          in the range of 1 to 2047.

_Hewlett-Packard PA-RISC--'config/pa/pa.h'_
     'a'
          General register 1

     'f'
          Floating point register

     'q'
          Shift amount register

     'x'
          Floating point register (deprecated)

     'y'
          Upper floating point register (32-bit), floating point
          register (64-bit)

     'Z'
          Any register

     'I'
          Signed 11-bit integer constant

     'J'
          Signed 14-bit integer constant

     'K'
          Integer constant that can be deposited with a 'zdepi'
          instruction

     'L'
          Signed 5-bit integer constant

     'M'
          Integer constant 0

     'N'
          Integer constant that can be loaded with a 'ldil' instruction

     'O'
          Integer constant whose value plus one is a power of 2

     'P'
          Integer constant that can be used for 'and' operations in
          'depi' and 'extru' instructions

     'S'
          Integer constant 31

     'U'
          Integer constant 63

     'G'
          Floating-point constant 0.0

     'A'
          A 'lo_sum' data-linkage-table memory operand

     'Q'
          A memory operand that can be used as the destination operand
          of an integer store instruction

     'R'
          A scaled or unscaled indexed memory operand

     'T'
          A memory operand for floating-point loads and stores

     'W'
          A register indirect memory operand

_Intel IA-64--'config/ia64/ia64.h'_
     'a'
          General register 'r0' to 'r3' for 'addl' instruction

     'b'
          Branch register

     'c'
          Predicate register ('c' as in "conditional")

     'd'
          Application register residing in M-unit

     'e'
          Application register residing in I-unit

     'f'
          Floating-point register

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement and postdecrement which require
          printing with '%Pn' on IA-64.

     'G'
          Floating-point constant 0.0 or 1.0

     'I'
          14-bit signed integer constant

     'J'
          22-bit signed integer constant

     'K'
          8-bit signed integer constant for logical instructions

     'L'
          8-bit adjusted signed integer constant for compare pseudo-ops

     'M'
          6-bit unsigned integer constant for shift counts

     'N'
          9-bit signed integer constant for load and store
          postincrements

     'O'
          The constant zero

     'P'
          0 or -1 for 'dep' instruction

     'Q'
          Non-volatile memory for floating-point loads and stores

     'R'
          Integer constant in the range 1 to 4 for 'shladd' instruction

     'S'
          Memory operand except postincrement and postdecrement.  This
          is now roughly the same as 'm' when not used together with '<'
          or '>'.

_M32C--'config/m32c/m32c.c'_
     'Rsp'
     'Rfb'
     'Rsb'
          '$sp', '$fb', '$sb'.

     'Rcr'
          Any control register, when they're 16 bits wide (nothing if
          control registers are 24 bits wide)

     'Rcl'
          Any control register, when they're 24 bits wide.

     'R0w'
     'R1w'
     'R2w'
     'R3w'
          $r0, $r1, $r2, $r3.

     'R02'
          $r0 or $r2, or $r2r0 for 32 bit values.

     'R13'
          $r1 or $r3, or $r3r1 for 32 bit values.

     'Rdi'
          A register that can hold a 64 bit value.

     'Rhl'
          $r0 or $r1 (registers with addressable high/low bytes)

     'R23'
          $r2 or $r3

     'Raa'
          Address registers

     'Raw'
          Address registers when they're 16 bits wide.

     'Ral'
          Address registers when they're 24 bits wide.

     'Rqi'
          Registers that can hold QI values.

     'Rad'
          Registers that can be used with displacements ($a0, $a1, $sb).

     'Rsi'
          Registers that can hold 32 bit values.

     'Rhi'
          Registers that can hold 16 bit values.

     'Rhc'
          Registers chat can hold 16 bit values, including all control
          registers.

     'Rra'
          $r0 through R1, plus $a0 and $a1.

     'Rfl'
          The flags register.

     'Rmm'
          The memory-based pseudo-registers $mem0 through $mem15.

     'Rpi'
          Registers that can hold pointers (16 bit registers for r8c,
          m16c; 24 bit registers for m32cm, m32c).

     'Rpa'
          Matches multiple registers in a PARALLEL to form a larger
          register.  Used to match function return values.

     'Is3'
          -8 ... 7

     'IS1'
          -128 ... 127

     'IS2'
          -32768 ... 32767

     'IU2'
          0 ... 65535

     'In4'
          -8 ... -1 or 1 ... 8

     'In5'
          -16 ... -1 or 1 ... 16

     'In6'
          -32 ... -1 or 1 ... 32

     'IM2'
          -65536 ... -1

     'Ilb'
          An 8 bit value with exactly one bit set.

     'Ilw'
          A 16 bit value with exactly one bit set.

     'Sd'
          The common src/dest memory addressing modes.

     'Sa'
          Memory addressed using $a0 or $a1.

     'Si'
          Memory addressed with immediate addresses.

     'Ss'
          Memory addressed using the stack pointer ($sp).

     'Sf'
          Memory addressed using the frame base register ($fb).

     'Ss'
          Memory addressed using the small base register ($sb).

     'S1'
          $r1h

_MeP--'config/mep/constraints.md'_

     'a'
          The $sp register.

     'b'
          The $tp register.

     'c'
          Any control register.

     'd'
          Either the $hi or the $lo register.

     'em'
          Coprocessor registers that can be directly loaded ($c0-$c15).

     'ex'
          Coprocessor registers that can be moved to each other.

     'er'
          Coprocessor registers that can be moved to core registers.

     'h'
          The $hi register.

     'j'
          The $rpc register.

     'l'
          The $lo register.

     't'
          Registers which can be used in $tp-relative addressing.

     'v'
          The $gp register.

     'x'
          The coprocessor registers.

     'y'
          The coprocessor control registers.

     'z'
          The $0 register.

     'A'
          User-defined register set A.

     'B'
          User-defined register set B.

     'C'
          User-defined register set C.

     'D'
          User-defined register set D.

     'I'
          Offsets for $gp-rel addressing.

     'J'
          Constants that can be used directly with boolean insns.

     'K'
          Constants that can be moved directly to registers.

     'L'
          Small constants that can be added to registers.

     'M'
          Long shift counts.

     'N'
          Small constants that can be compared to registers.

     'O'
          Constants that can be loaded into the top half of registers.

     'S'
          Signed 8-bit immediates.

     'T'
          Symbols encoded for $tp-rel or $gp-rel addressing.

     'U'
          Non-constant addresses for loading/saving coprocessor
          registers.

     'W'
          The top half of a symbol's value.

     'Y'
          A register indirect address without offset.

     'Z'
          Symbolic references to the control bus.

_MicroBlaze--'config/microblaze/constraints.md'_
     'd'
          A general register ('r0' to 'r31').

     'z'
          A status register ('rmsr', '$fcc1' to '$fcc7').

_MIPS--'config/mips/constraints.md'_
     'd'
          An address register.  This is equivalent to 'r' unless
          generating MIPS16 code.

     'f'
          A floating-point register (if available).

     'h'
          Formerly the 'hi' register.  This constraint is no longer
          supported.

     'l'
          The 'lo' register.  Use this register to store values that are
          no bigger than a word.

     'x'
          The concatenated 'hi' and 'lo' registers.  Use this register
          to store doubleword values.

     'c'
          A register suitable for use in an indirect jump.  This will
          always be '$25' for '-mabicalls'.

     'v'
          Register '$3'.  Do not use this constraint in new code; it is
          retained only for compatibility with glibc.

     'y'
          Equivalent to 'r'; retained for backwards compatibility.

     'z'
          A floating-point condition code register.

     'I'
          A signed 16-bit constant (for arithmetic instructions).

     'J'
          Integer zero.

     'K'
          An unsigned 16-bit constant (for logic instructions).

     'L'
          A signed 32-bit constant in which the lower 16 bits are zero.
          Such constants can be loaded using 'lui'.

     'M'
          A constant that cannot be loaded using 'lui', 'addiu' or
          'ori'.

     'N'
          A constant in the range -65535 to -1 (inclusive).

     'O'
          A signed 15-bit constant.

     'P'
          A constant in the range 1 to 65535 (inclusive).

     'G'
          Floating-point zero.

     'R'
          An address that can be used in a non-macro load or store.

     'ZC'
          A memory operand whose address is formed by a base register
          and offset that is suitable for use in instructions with the
          same addressing mode as 'll' and 'sc'.

     'ZD'
          An address suitable for a 'prefetch' instruction, or for any
          other instruction with the same addressing mode as 'prefetch'.

_Motorola 680x0--'config/m68k/constraints.md'_
     'a'
          Address register

     'd'
          Data register

     'f'
          68881 floating-point register, if available

     'I'
          Integer in the range 1 to 8

     'J'
          16-bit signed number

     'K'
          Signed number whose magnitude is greater than 0x80

     'L'
          Integer in the range -8 to -1

     'M'
          Signed number whose magnitude is greater than 0x100

     'N'
          Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate

     'O'
          16 (for rotate using swap)

     'P'
          Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate

     'R'
          Numbers that mov3q can handle

     'G'
          Floating point constant that is not a 68881 constant

     'S'
          Operands that satisfy 'm' when -mpcrel is in effect

     'T'
          Operands that satisfy 's' when -mpcrel is not in effect

     'Q'
          Address register indirect addressing mode

     'U'
          Register offset addressing

     'W'
          const_call_operand

     'Cs'
          symbol_ref or const

     'Ci'
          const_int

     'C0'
          const_int 0

     'Cj'
          Range of signed numbers that don't fit in 16 bits

     'Cmvq'
          Integers valid for mvq

     'Capsw'
          Integers valid for a moveq followed by a swap

     'Cmvz'
          Integers valid for mvz

     'Cmvs'
          Integers valid for mvs

     'Ap'
          push_operand

     'Ac'
          Non-register operands allowed in clr

_Moxie--'config/moxie/constraints.md'_
     'A'
          An absolute address

     'B'
          An offset address

     'W'
          A register indirect memory operand

     'I'
          A constant in the range of 0 to 255.

     'N'
          A constant in the range of 0 to -255.

_MSP430-'config/msp430/constraints.md'_

     'R12'
          Register R12.

     'R13'
          Register R13.

     'K'
          Integer constant 1.

     'L'
          Integer constant -1^20..1^19.

     'M'
          Integer constant 1-4.

     'Ya'
          Memory references which do not require an extended MOVX
          instruction.

     'Yl'
          Memory reference, labels only.

     'Ys'
          Memory reference, stack only.

_NDS32--'config/nds32/constraints.md'_
     'w'
          LOW register class $r0 to $r7 constraint for V3/V3M ISA.
     'l'
          LOW register class $r0 to $r7.
     'd'
          MIDDLE register class $r0 to $r11, $r16 to $r19.
     'h'
          HIGH register class $r12 to $r14, $r20 to $r31.
     't'
          Temporary assist register $ta (i.e. $r15).
     'k'
          Stack register $sp.
     'Iu03'
          Unsigned immediate 3-bit value.
     'In03'
          Negative immediate 3-bit value in the range of -7-0.
     'Iu04'
          Unsigned immediate 4-bit value.
     'Is05'
          Signed immediate 5-bit value.
     'Iu05'
          Unsigned immediate 5-bit value.
     'In05'
          Negative immediate 5-bit value in the range of -31-0.
     'Ip05'
          Unsigned immediate 5-bit value for movpi45 instruction with
          range 16-47.
     'Iu06'
          Unsigned immediate 6-bit value constraint for addri36.sp
          instruction.
     'Iu08'
          Unsigned immediate 8-bit value.
     'Iu09'
          Unsigned immediate 9-bit value.
     'Is10'
          Signed immediate 10-bit value.
     'Is11'
          Signed immediate 11-bit value.
     'Is15'
          Signed immediate 15-bit value.
     'Iu15'
          Unsigned immediate 15-bit value.
     'Ic15'
          A constant which is not in the range of imm15u but ok for bclr
          instruction.
     'Ie15'
          A constant which is not in the range of imm15u but ok for bset
          instruction.
     'It15'
          A constant which is not in the range of imm15u but ok for btgl
          instruction.
     'Ii15'
          A constant whose compliment value is in the range of imm15u
          and ok for bitci instruction.
     'Is16'
          Signed immediate 16-bit value.
     'Is17'
          Signed immediate 17-bit value.
     'Is19'
          Signed immediate 19-bit value.
     'Is20'
          Signed immediate 20-bit value.
     'Ihig'
          The immediate value that can be simply set high 20-bit.
     'Izeb'
          The immediate value 0xff.
     'Izeh'
          The immediate value 0xffff.
     'Ixls'
          The immediate value 0x01.
     'Ix11'
          The immediate value 0x7ff.
     'Ibms'
          The immediate value with power of 2.
     'Ifex'
          The immediate value with power of 2 minus 1.
     'U33'
          Memory constraint for 333 format.
     'U45'
          Memory constraint for 45 format.
     'U37'
          Memory constraint for 37 format.

_Nios II family--'config/nios2/constraints.md'_

     'I'
          Integer that is valid as an immediate operand in an
          instruction taking a signed 16-bit number.  Range -32768 to
          32767.

     'J'
          Integer that is valid as an immediate operand in an
          instruction taking an unsigned 16-bit number.  Range 0 to
          65535.

     'K'
          Integer that is valid as an immediate operand in an
          instruction taking only the upper 16-bits of a 32-bit number.
          Range 32-bit numbers with the lower 16-bits being 0.

     'L'
          Integer that is valid as an immediate operand for a shift
          instruction.  Range 0 to 31.

     'M'
          Integer that is valid as an immediate operand for only the
          value 0.  Can be used in conjunction with the format modifier
          'z' to use 'r0' instead of '0' in the assembly output.

     'N'
          Integer that is valid as an immediate operand for a custom
          instruction opcode.  Range 0 to 255.

     'S'
          Matches immediates which are addresses in the small data
          section and therefore can be added to 'gp' as a 16-bit
          immediate to re-create their 32-bit value.

_PDP-11--'config/pdp11/constraints.md'_
     'a'
          Floating point registers AC0 through AC3.  These can be loaded
          from/to memory with a single instruction.

     'd'
          Odd numbered general registers (R1, R3, R5).  These are used
          for 16-bit multiply operations.

     'f'
          Any of the floating point registers (AC0 through AC5).

     'G'
          Floating point constant 0.

     'I'
          An integer constant that fits in 16 bits.

     'J'
          An integer constant whose low order 16 bits are zero.

     'K'
          An integer constant that does not meet the constraints for
          codes 'I' or 'J'.

     'L'
          The integer constant 1.

     'M'
          The integer constant -1.

     'N'
          The integer constant 0.

     'O'
          Integer constants -4 through -1 and 1 through 4; shifts by
          these amounts are handled as multiple single-bit shifts rather
          than a single variable-length shift.

     'Q'
          A memory reference which requires an additional word (address
          or offset) after the opcode.

     'R'
          A memory reference that is encoded within the opcode.

_PowerPC and IBM RS6000--'config/rs6000/constraints.md'_
     'b'
          Address base register

     'd'
          Floating point register (containing 64-bit value)

     'f'
          Floating point register (containing 32-bit value)

     'v'
          Altivec vector register

     'wa'
          Any VSX register if the -mvsx option was used or NO_REGS.

     'wd'
          VSX vector register to hold vector double data or NO_REGS.

     'wf'
          VSX vector register to hold vector float data or NO_REGS.

     'wg'
          If '-mmfpgpr' was used, a floating point register or NO_REGS.

     'wh'
          Floating point register if direct moves are available, or
          NO_REGS.

     'wi'
          FP or VSX register to hold 64-bit integers for VSX insns or
          NO_REGS.

     'wj'
          FP or VSX register to hold 64-bit integers for direct moves or
          NO_REGS.

     'wk'
          FP or VSX register to hold 64-bit doubles for direct moves or
          NO_REGS.

     'wl'
          Floating point register if the LFIWAX instruction is enabled
          or NO_REGS.

     'wm'
          VSX register if direct move instructions are enabled, or
          NO_REGS.

     'wn'
          No register (NO_REGS).

     'wr'
          General purpose register if 64-bit instructions are enabled or
          NO_REGS.

     'ws'
          VSX vector register to hold scalar double values or NO_REGS.

     'wt'
          VSX vector register to hold 128 bit integer or NO_REGS.

     'wu'
          Altivec register to use for float/32-bit int loads/stores or
          NO_REGS.

     'wv'
          Altivec register to use for double loads/stores or NO_REGS.

     'ww'
          FP or VSX register to perform float operations under '-mvsx'
          or NO_REGS.

     'wx'
          Floating point register if the STFIWX instruction is enabled
          or NO_REGS.

     'wy'
          FP or VSX register to perform ISA 2.07 float ops or NO_REGS.

     'wz'
          Floating point register if the LFIWZX instruction is enabled
          or NO_REGS.

     'wD'
          Int constant that is the element number of the 64-bit scalar
          in a vector.

     'wQ'
          A memory address that will work with the 'lq' and 'stq'
          instructions.

     'h'
          'MQ', 'CTR', or 'LINK' register

     'q'
          'MQ' register

     'c'
          'CTR' register

     'l'
          'LINK' register

     'x'
          'CR' register (condition register) number 0

     'y'
          'CR' register (condition register)

     'z'
          'XER[CA]' carry bit (part of the XER register)

     'I'
          Signed 16-bit constant

     'J'
          Unsigned 16-bit constant shifted left 16 bits (use 'L' instead
          for 'SImode' constants)

     'K'
          Unsigned 16-bit constant

     'L'
          Signed 16-bit constant shifted left 16 bits

     'M'
          Constant larger than 31

     'N'
          Exact power of 2

     'O'
          Zero

     'P'
          Constant whose negation is a signed 16-bit constant

     'G'
          Floating point constant that can be loaded into a register
          with one instruction per word

     'H'
          Integer/Floating point constant that can be loaded into a
          register using three instructions

     'm'
          Memory operand.  Normally, 'm' does not allow addresses that
          update the base register.  If '<' or '>' constraint is also
          used, they are allowed and therefore on PowerPC targets in
          that case it is only safe to use 'm<>' in an 'asm' statement
          if that 'asm' statement accesses the operand exactly once.
          The 'asm' statement must also use '%U<OPNO>' as a placeholder
          for the "update" flag in the corresponding load or store
          instruction.  For example:

               asm ("st%U0 %1,%0" : "=m<>" (mem) : "r" (val));

          is correct but:

               asm ("st %1,%0" : "=m<>" (mem) : "r" (val));

          is not.

     'es'
          A "stable" memory operand; that is, one which does not include
          any automodification of the base register.  This used to be
          useful when 'm' allowed automodification of the base register,
          but as those are now only allowed when '<' or '>' is used,
          'es' is basically the same as 'm' without '<' and '>'.

     'Q'
          Memory operand that is an offset from a register (it is
          usually better to use 'm' or 'es' in 'asm' statements)

     'Z'
          Memory operand that is an indexed or indirect from a register
          (it is usually better to use 'm' or 'es' in 'asm' statements)

     'R'
          AIX TOC entry

     'a'
          Address operand that is an indexed or indirect from a register
          ('p' is preferable for 'asm' statements)

     'S'
          Constant suitable as a 64-bit mask operand

     'T'
          Constant suitable as a 32-bit mask operand

     'U'
          System V Release 4 small data area reference

     't'
          AND masks that can be performed by two rldic{l, r}
          instructions

     'W'
          Vector constant that does not require memory

     'j'
          Vector constant that is all zeros.

_RL78--'config/rl78/constraints.md'_

     'Int3'
          An integer constant in the range 1 ... 7.
     'Int8'
          An integer constant in the range 0 ... 255.
     'J'
          An integer constant in the range -255 ... 0
     'K'
          The integer constant 1.
     'L'
          The integer constant -1.
     'M'
          The integer constant 0.
     'N'
          The integer constant 2.
     'O'
          The integer constant -2.
     'P'
          An integer constant in the range 1 ... 15.
     'Qbi'
          The built-in compare types-eq, ne, gtu, ltu, geu, and leu.
     'Qsc'
          The synthetic compare types-gt, lt, ge, and le.
     'Wab'
          A memory reference with an absolute address.
     'Wbc'
          A memory reference using 'BC' as a base register, with an
          optional offset.
     'Wca'
          A memory reference using 'AX', 'BC', 'DE', or 'HL' for the
          address, for calls.
     'Wcv'
          A memory reference using any 16-bit register pair for the
          address, for calls.
     'Wd2'
          A memory reference using 'DE' as a base register, with an
          optional offset.
     'Wde'
          A memory reference using 'DE' as a base register, without any
          offset.
     'Wfr'
          Any memory reference to an address in the far address space.
     'Wh1'
          A memory reference using 'HL' as a base register, with an
          optional one-byte offset.
     'Whb'
          A memory reference using 'HL' as a base register, with 'B' or
          'C' as the index register.
     'Whl'
          A memory reference using 'HL' as a base register, without any
          offset.
     'Ws1'
          A memory reference using 'SP' as a base register, with an
          optional one-byte offset.
     'Y'
          Any memory reference to an address in the near address space.
     'A'
          The 'AX' register.
     'B'
          The 'BC' register.
     'D'
          The 'DE' register.
     'R'
          'A' through 'L' registers.
     'S'
          The 'SP' register.
     'T'
          The 'HL' register.
     'Z08W'
          The 16-bit 'R8' register.
     'Z10W'
          The 16-bit 'R10' register.
     'Zint'
          The registers reserved for interrupts ('R24' to 'R31').
     'a'
          The 'A' register.
     'b'
          The 'B' register.
     'c'
          The 'C' register.
     'd'
          The 'D' register.
     'e'
          The 'E' register.
     'h'
          The 'H' register.
     'l'
          The 'L' register.
     'v'
          The virtual registers.
     'w'
          The 'PSW' register.
     'x'
          The 'X' register.

_RX--'config/rx/constraints.md'_
     'Q'
          An address which does not involve register indirect addressing
          or pre/post increment/decrement addressing.

     'Symbol'
          A symbol reference.

     'Int08'
          A constant in the range -256 to 255, inclusive.

     'Sint08'
          A constant in the range -128 to 127, inclusive.

     'Sint16'
          A constant in the range -32768 to 32767, inclusive.

     'Sint24'
          A constant in the range -8388608 to 8388607, inclusive.

     'Uint04'
          A constant in the range 0 to 15, inclusive.

_S/390 and zSeries--'config/s390/s390.h'_
     'a'
          Address register (general purpose register except r0)

     'c'
          Condition code register

     'd'
          Data register (arbitrary general purpose register)

     'f'
          Floating-point register

     'I'
          Unsigned 8-bit constant (0-255)

     'J'
          Unsigned 12-bit constant (0-4095)

     'K'
          Signed 16-bit constant (-32768-32767)

     'L'
          Value appropriate as displacement.
          '(0..4095)'
               for short displacement
          '(-524288..524287)'
               for long displacement

     'M'
          Constant integer with a value of 0x7fffffff.

     'N'
          Multiple letter constraint followed by 4 parameter letters.
          '0..9:'
               number of the part counting from most to least
               significant
          'H,Q:'
               mode of the part
          'D,S,H:'
               mode of the containing operand
          '0,F:'
               value of the other parts (F--all bits set)
          The constraint matches if the specified part of a constant has
          a value different from its other parts.

     'Q'
          Memory reference without index register and with short
          displacement.

     'R'
          Memory reference with index register and short displacement.

     'S'
          Memory reference without index register but with long
          displacement.

     'T'
          Memory reference with index register and long displacement.

     'U'
          Pointer with short displacement.

     'W'
          Pointer with long displacement.

     'Y'
          Shift count operand.

_SPARC--'config/sparc/sparc.h'_
     'f'
          Floating-point register on the SPARC-V8 architecture and lower
          floating-point register on the SPARC-V9 architecture.

     'e'
          Floating-point register.  It is equivalent to 'f' on the
          SPARC-V8 architecture and contains both lower and upper
          floating-point registers on the SPARC-V9 architecture.

     'c'
          Floating-point condition code register.

     'd'
          Lower floating-point register.  It is only valid on the
          SPARC-V9 architecture when the Visual Instruction Set is
          available.

     'b'
          Floating-point register.  It is only valid on the SPARC-V9
          architecture when the Visual Instruction Set is available.

     'h'
          64-bit global or out register for the SPARC-V8+ architecture.

     'C'
          The constant all-ones, for floating-point.

     'A'
          Signed 5-bit constant

     'D'
          A vector constant

     'I'
          Signed 13-bit constant

     'J'
          Zero

     'K'
          32-bit constant with the low 12 bits clear (a constant that
          can be loaded with the 'sethi' instruction)

     'L'
          A constant in the range supported by 'movcc' instructions
          (11-bit signed immediate)

     'M'
          A constant in the range supported by 'movrcc' instructions
          (10-bit signed immediate)

     'N'
          Same as 'K', except that it verifies that bits that are not in
          the lower 32-bit range are all zero.  Must be used instead of
          'K' for modes wider than 'SImode'

     'O'
          The constant 4096

     'G'
          Floating-point zero

     'H'
          Signed 13-bit constant, sign-extended to 32 or 64 bits

     'P'
          The constant -1

     'Q'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single sethi
          instruction

     'R'
          Floating-point constant whose integral representation can be
          moved into an integer register using a single mov instruction

     'S'
          Floating-point constant whose integral representation can be
          moved into an integer register using a high/lo_sum instruction
          sequence

     'T'
          Memory address aligned to an 8-byte boundary

     'U'
          Even register

     'W'
          Memory address for 'e' constraint registers

     'w'
          Memory address with only a base register

     'Y'
          Vector zero

_SPU--'config/spu/spu.h'_
     'a'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is treated as a 64 bit value.

     'c'
          An immediate for and/xor/or instructions.  const_int is
          treated as a 64 bit value.

     'd'
          An immediate for the 'iohl' instruction.  const_int is treated
          as a 64 bit value.

     'f'
          An immediate which can be loaded with 'fsmbi'.

     'A'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is treated as a 32 bit value.

     'B'
          An immediate for most arithmetic instructions.  const_int is
          treated as a 32 bit value.

     'C'
          An immediate for and/xor/or instructions.  const_int is
          treated as a 32 bit value.

     'D'
          An immediate for the 'iohl' instruction.  const_int is treated
          as a 32 bit value.

     'I'
          A constant in the range [-64, 63] for shift/rotate
          instructions.

     'J'
          An unsigned 7-bit constant for conversion/nop/channel
          instructions.

     'K'
          A signed 10-bit constant for most arithmetic instructions.

     'M'
          A signed 16 bit immediate for 'stop'.

     'N'
          An unsigned 16-bit constant for 'iohl' and 'fsmbi'.

     'O'
          An unsigned 7-bit constant whose 3 least significant bits are
          0.

     'P'
          An unsigned 3-bit constant for 16-byte rotates and shifts

     'R'
          Call operand, reg, for indirect calls

     'S'
          Call operand, symbol, for relative calls.

     'T'
          Call operand, const_int, for absolute calls.

     'U'
          An immediate which can be loaded with the il/ila/ilh/ilhu
          instructions.  const_int is sign extended to 128 bit.

     'W'
          An immediate for shift and rotate instructions.  const_int is
          treated as a 32 bit value.

     'Y'
          An immediate for and/xor/or instructions.  const_int is sign
          extended as a 128 bit.

     'Z'
          An immediate for the 'iohl' instruction.  const_int is sign
          extended to 128 bit.

_TI C6X family--'config/c6x/constraints.md'_
     'a'
          Register file A (A0-A31).

     'b'
          Register file B (B0-B31).

     'A'
          Predicate registers in register file A (A0-A2 on C64X and
          higher, A1 and A2 otherwise).

     'B'
          Predicate registers in register file B (B0-B2).

     'C'
          A call-used register in register file B (B0-B9, B16-B31).

     'Da'
          Register file A, excluding predicate registers (A3-A31, plus
          A0 if not C64X or higher).

     'Db'
          Register file B, excluding predicate registers (B3-B31).

     'Iu4'
          Integer constant in the range 0 ... 15.

     'Iu5'
          Integer constant in the range 0 ... 31.

     'In5'
          Integer constant in the range -31 ... 0.

     'Is5'
          Integer constant in the range -16 ... 15.

     'I5x'
          Integer constant that can be the operand of an ADDA or a SUBA
          insn.

     'IuB'
          Integer constant in the range 0 ... 65535.

     'IsB'
          Integer constant in the range -32768 ... 32767.

     'IsC'
          Integer constant in the range -2^{20} ... 2^{20} - 1.

     'Jc'
          Integer constant that is a valid mask for the clr instruction.

     'Js'
          Integer constant that is a valid mask for the set instruction.

     'Q'
          Memory location with A base register.

     'R'
          Memory location with B base register.

     'Z'
          Register B14 (aka DP).

_TILE-Gx--'config/tilegx/constraints.md'_
     'R00'
     'R01'
     'R02'
     'R03'
     'R04'
     'R05'
     'R06'
     'R07'
     'R08'
     'R09'
     'R10'
          Each of these represents a register constraint for an
          individual register, from r0 to r10.

     'I'
          Signed 8-bit integer constant.

     'J'
          Signed 16-bit integer constant.

     'K'
          Unsigned 16-bit integer constant.

     'L'
          Integer constant that fits in one signed byte when incremented
          by one (-129 ... 126).

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement which requires printing with '%In' and
          '%in' on TILE-Gx.  For example:

               asm ("st_add %I0,%1,%i0" : "=m<>" (*mem) : "r" (val));

     'M'
          A bit mask suitable for the BFINS instruction.

     'N'
          Integer constant that is a byte tiled out eight times.

     'O'
          The integer zero constant.

     'P'
          Integer constant that is a sign-extended byte tiled out as
          four shorts.

     'Q'
          Integer constant that fits in one signed byte when incremented
          (-129 ... 126), but excluding -1.

     'S'
          Integer constant that has all 1 bits consecutive and starting
          at bit 0.

     'T'
          A 16-bit fragment of a got, tls, or pc-relative reference.

     'U'
          Memory operand except postincrement.  This is roughly the same
          as 'm' when not used together with '<' or '>'.

     'W'
          An 8-element vector constant with identical elements.

     'Y'
          A 4-element vector constant with identical elements.

     'Z0'
          The integer constant 0xffffffff.

     'Z1'
          The integer constant 0xffffffff00000000.

_TILEPro--'config/tilepro/constraints.md'_
     'R00'
     'R01'
     'R02'
     'R03'
     'R04'
     'R05'
     'R06'
     'R07'
     'R08'
     'R09'
     'R10'
          Each of these represents a register constraint for an
          individual register, from r0 to r10.

     'I'
          Signed 8-bit integer constant.

     'J'
          Signed 16-bit integer constant.

     'K'
          Nonzero integer constant with low 16 bits zero.

     'L'
          Integer constant that fits in one signed byte when incremented
          by one (-129 ... 126).

     'm'
          Memory operand.  If used together with '<' or '>', the operand
          can have postincrement which requires printing with '%In' and
          '%in' on TILEPro.  For example:

               asm ("swadd %I0,%1,%i0" : "=m<>" (mem) : "r" (val));

     'M'
          A bit mask suitable for the MM instruction.

     'N'
          Integer constant that is a byte tiled out four times.

     'O'
          The integer zero constant.

     'P'
          Integer constant that is a sign-extended byte tiled out as two
          shorts.

     'Q'
          Integer constant that fits in one signed byte when incremented
          (-129 ... 126), but excluding -1.

     'T'
          A symbolic operand, or a 16-bit fragment of a got, tls, or
          pc-relative reference.

     'U'
          Memory operand except postincrement.  This is roughly the same
          as 'm' when not used together with '<' or '>'.

     'W'
          A 4-element vector constant with identical elements.

     'Y'
          A 2-element vector constant with identical elements.

_Visium--'config/visium/constraints.md'_
     'b'
          EAM register 'mdb'

     'c'
          EAM register 'mdc'

     'f'
          Floating point register

     'l'
          General register, but not 'r29', 'r30' and 'r31'

     't'
          Register 'r1'

     'u'
          Register 'r2'

     'v'
          Register 'r3'

     'G'
          Floating-point constant 0.0

     'J'
          Integer constant in the range 0 ..  65535 (16-bit immediate)

     'K'
          Integer constant in the range 1 ..  31 (5-bit immediate)

     'L'
          Integer constant in the range -65535 ..  -1 (16-bit negative
          immediate)

     'M'
          Integer constant -1

     'O'
          Integer constant 0

     'P'
          Integer constant 32

_x86 family--'config/i386/constraints.md'_
     'R'
          Legacy register--the eight integer registers available on all
          i386 processors ('a', 'b', 'c', 'd', 'si', 'di', 'bp', 'sp').

     'q'
          Any register accessible as 'Rl'.  In 32-bit mode, 'a', 'b',
          'c', and 'd'; in 64-bit mode, any integer register.

     'Q'
          Any register accessible as 'Rh': 'a', 'b', 'c', and 'd'.

     'a'
          The 'a' register.

     'b'
          The 'b' register.

     'c'
          The 'c' register.

     'd'
          The 'd' register.

     'S'
          The 'si' register.

     'D'
          The 'di' register.

     'A'
          The 'a' and 'd' registers.  This class is used for
          instructions that return double word results in the 'ax:dx'
          register pair.  Single word values will be allocated either in
          'ax' or 'dx'.  For example on i386 the following implements
          'rdtsc':

               unsigned long long rdtsc (void)
               {
                 unsigned long long tick;
                 __asm__ __volatile__("rdtsc":"=A"(tick));
                 return tick;
               }

          This is not correct on x86-64 as it would allocate tick in
          either 'ax' or 'dx'.  You have to use the following variant
          instead:

               unsigned long long rdtsc (void)
               {
                 unsigned int tickl, tickh;
                 __asm__ __volatile__("rdtsc":"=a"(tickl),"=d"(tickh));
                 return ((unsigned long long)tickh << 32)|tickl;
               }

     'f'
          Any 80387 floating-point (stack) register.

     't'
          Top of 80387 floating-point stack ('%st(0)').

     'u'
          Second from top of 80387 floating-point stack ('%st(1)').

     'y'
          Any MMX register.

     'x'
          Any SSE register.

     'Yz'
          First SSE register ('%xmm0').

     'I'
          Integer constant in the range 0 ... 31, for 32-bit shifts.

     'J'
          Integer constant in the range 0 ... 63, for 64-bit shifts.

     'K'
          Signed 8-bit integer constant.

     'L'
          '0xFF' or '0xFFFF', for andsi as a zero-extending move.

     'M'
          0, 1, 2, or 3 (shifts for the 'lea' instruction).

     'N'
          Unsigned 8-bit integer constant (for 'in' and 'out'
          instructions).

     'G'
          Standard 80387 floating point constant.

     'C'
          Standard SSE floating point constant.

     'e'
          32-bit signed integer constant, or a symbolic reference known
          to fit that range (for immediate operands in sign-extending
          x86-64 instructions).

     'Z'
          32-bit unsigned integer constant, or a symbolic reference
          known to fit that range (for immediate operands in
          zero-extending x86-64 instructions).

_Xstormy16--'config/stormy16/stormy16.h'_
     'a'
          Register r0.

     'b'
          Register r1.

     'c'
          Register r2.

     'd'
          Register r8.

     'e'
          Registers r0 through r7.

     't'
          Registers r0 and r1.

     'y'
          The carry register.

     'z'
          Registers r8 and r9.

     'I'
          A constant between 0 and 3 inclusive.

     'J'
          A constant that has exactly one bit set.

     'K'
          A constant that has exactly one bit clear.

     'L'
          A constant between 0 and 255 inclusive.

     'M'
          A constant between -255 and 0 inclusive.

     'N'
          A constant between -3 and 0 inclusive.

     'O'
          A constant between 1 and 4 inclusive.

     'P'
          A constant between -4 and -1 inclusive.

     'Q'
          A memory reference that is a stack push.

     'R'
          A memory reference that is a stack pop.

     'S'
          A memory reference that refers to a constant address of known
          value.

     'T'
          The register indicated by Rx (not implemented yet).

     'U'
          A constant that is not between 2 and 15 inclusive.

     'Z'
          The constant 0.

_Xtensa--'config/xtensa/constraints.md'_
     'a'
          General-purpose 32-bit register

     'b'
          One-bit boolean register

     'A'
          MAC16 40-bit accumulator register

     'I'
          Signed 12-bit integer constant, for use in MOVI instructions

     'J'
          Signed 8-bit integer constant, for use in ADDI instructions

     'K'
          Integer constant valid for BccI instructions

     'L'
          Unsigned constant valid for BccUI instructions

