This is ../../llvm-user-manual/llvm.info, produced by makeinfo version
4.13 from ../../llvm-user-manual/llvm.texi.

Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies
published by Embecosm support introducing others to free and open
source software and hardware.

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* llvm: (llvm).                The LLVM compiler
END-INFO-DIR-ENTRY
 This file documents the use of the LLVM compiler.

 Copyright (C) 2015 Embecosm Limited
Copyright (C) 1988-2015 Free Software Foundation, Inc.

 Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a, c) (see below), and with the Back-Cover Texts being (b, d)
(see below).  A copy of the license is included in the section entitled
"GNU Free Documentation License".

 (a) The FSF's Front-Cover Text is:

 A GNU Manual

 (b) The FSF's Back-Cover Text is:

 You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.

 (c) Embecosm's Front-Cover Text is:

 Derivative Manual for LLVM

 (d) Embecosm's Back-Cover Text is:

 You have freedom to copy and modify this manual.  Copies
published by Embecosm support introducing others to free and open
source software and hardware.



File: llvm.info,  Node: C Implementation,  Next: C++ Implementation,  Prev: Invoking LLVM,  Up: Top

4 C Implementation-Defined Behavior
***********************************

A conforming implementation of ISO C is required to document its choice
of behavior in each of the areas that are designated "implementation
defined".  The following lists all such areas, along with the section
numbers from the ISO/IEC 9899:1990, ISO/IEC 9899:1999 and ISO/IEC
9899:2011 standards.  Some areas are only implementation-defined in one
version of the standard.

 Some choices depend on the externally determined ABI for the platform
(including standard character encodings) which GCC follows; these are
listed as "determined by ABI" below.  *Note Binary Compatibility:
Compatibility, and `http://gcc.gnu.org/readings.html'.  Some choices
are documented in the preprocessor manual.  *Note
Implementation-defined behavior: (cpp)Implementation-defined behavior.
Some choices are made by the library and operating system (or other
environment when compiling for a freestanding environment); refer to
their documentation for details.

* Menu:

* Translation implementation::
* Environment implementation::
* Identifiers implementation::
* Characters implementation::
* Integers implementation::
* Floating point implementation::
* Arrays and pointers implementation::
* Hints implementation::
* Structures unions enumerations and bit-fields implementation::
* Qualifiers implementation::
* Declarators implementation::
* Statements implementation::
* Preprocessing directives implementation::
* Library functions implementation::
* Architecture implementation::
* Locale-specific behavior implementation::


File: llvm.info,  Node: Translation implementation,  Next: Environment implementation,  Up: C Implementation

4.1 Translation
===============

   * `How a diagnostic is identified (C90 3.7, C99 and C11 3.10, C90,
     C99 and C11 5.1.1.3).'

     Diagnostics consist of all the output sent to stderr by GCC.

   * `Whether each nonempty sequence of white-space characters other
     than new-line is retained or replaced by one space character in
     translation phase 3 (C90, C99 and C11 5.1.1.2).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.



File: llvm.info,  Node: Environment implementation,  Next: Identifiers implementation,  Prev: Translation implementation,  Up: C Implementation

4.2 Environment
===============

The behavior of most of these points are dependent on the implementation
of the C library, and are not defined by GCC itself.

   * `The mapping between physical source file multibyte characters and
     the source character set in translation phase 1 (C90, C99 and C11
     5.1.1.2).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.



File: llvm.info,  Node: Identifiers implementation,  Next: Characters implementation,  Prev: Environment implementation,  Up: C Implementation

4.3 Identifiers
===============

   * `Which additional multibyte characters may appear in identifiers
     and their correspondence to universal character names (C99 and C11
     6.4.2).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.

   * `The number of significant initial characters in an identifier
     (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).'

     For internal names, all characters are significant.  For external
     names, the number of significant characters are defined by the
     linker; for almost all targets, all characters are significant.

   * `Whether case distinctions are significant in an identifier with
     external linkage (C90 6.1.2).'

     This is a property of the linker.  C99 and C11 require that case
     distinctions are always significant in identifiers with external
     linkage and systems without this property are not supported by GCC.



File: llvm.info,  Node: Characters implementation,  Next: Integers implementation,  Prev: Identifiers implementation,  Up: C Implementation

4.4 Characters
==============

   * `The number of bits in a byte (C90 3.4, C99 and C11 3.6).'

     Determined by ABI.

   * `The values of the members of the execution character set (C90,
     C99 and C11 5.2.1).'

     Determined by ABI.

   * `The unique value of the member of the execution character set
     produced for each of the standard alphabetic escape sequences
     (C90, C99 and C11 5.2.2).'

     Determined by ABI.

   * `The value of a `char' object into which has been stored any
     character other than a member of the basic execution character set
     (C90 6.1.2.5, C99 and C11 6.2.5).'

     Determined by ABI.

   * `Which of `signed char' or `unsigned char' has the same range,
     representation, and behavior as "plain" `char' (C90 6.1.2.5, C90
     6.2.1.1, C99 and C11 6.2.5, C99 and C11 6.3.1.1).'

     Determined by ABI.  The options `-funsigned-char' and
     `-fsigned-char' change the default.  *Note Options Controlling C
     Dialect: C Dialect Options.

   * `The mapping of members of the source character set (in character
     constants and string literals) to members of the execution
     character set (C90 6.1.3.4, C99 and C11 6.4.4.4, C90, C99 and C11
     5.1.1.2).'

     Determined by ABI.

   * `The value of an integer character constant containing more than
     one character or containing a character or escape sequence that
     does not map to a single-byte execution character (C90 6.1.3.4,
     C99 and C11 6.4.4.4).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.

   * `The value of a wide character constant containing more than one
     multibyte character or a single multibyte character that maps to
     multiple members of the extended execution character set, or
     containing a multibyte character or escape sequence not
     represented in the extended execution character set (C90 6.1.3.4,
     C99 and C11 6.4.4.4).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.

   * `The current locale used to convert a wide character constant
     consisting of a single multibyte character that maps to a member
     of the extended execution character set into a corresponding wide
     character code (C90 6.1.3.4, C99 and C11 6.4.4.4).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.

   * `Whether differently-prefixed wide string literal tokens can be
     concatenated and, if so, the treatment of the resulting multibyte
     character sequence (C11 6.4.5).'

     Such tokens may not be concatenated.

   * `The current locale used to convert a wide string literal into
     corresponding wide character codes (C90 6.1.4, C99 and C11 6.4.5).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.

   * `The value of a string literal containing a multibyte character or
     escape sequence not represented in the execution character set
     (C90 6.1.4, C99 and C11 6.4.5).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.

   * `The encoding of any of `wchar_t', `char16_t', and `char32_t'
     where the corresponding standard encoding macro
     (`__STDC_ISO_10646__', `__STDC_UTF_16__', or `__STDC_UTF_32__') is
     not defined (C11 6.10.8.2).'

     *Note Implementation-defined behavior: (cpp)Implementation-defined
     behavior.  `char16_t' and `char32_t' literals are always encoded
     in UTF-16 and UTF-32 respectively.



File: llvm.info,  Node: Integers implementation,  Next: Floating point implementation,  Prev: Characters implementation,  Up: C Implementation

4.5 Integers
============

   * `Any extended integer types that exist in the implementation (C99
     and C11 6.2.5).'

     GCC does not support any extended integer types.

   * `Whether signed integer types are represented using sign and
     magnitude, two's complement, or one's complement, and whether the
     extraordinary value is a trap representation or an ordinary value
     (C99 and C11 6.2.6.2).'

     GCC supports only two's complement integer types, and all bit
     patterns are ordinary values.

   * `The rank of any extended integer type relative to another extended
     integer type with the same precision (C99 and C11 6.3.1.1).'

     GCC does not support any extended integer types.

   * `The result of, or the signal raised by, converting an integer to a
     signed integer type when the value cannot be represented in an
     object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).'

     For conversion to a type of width N, the value is reduced modulo
     2^N to be within range of the type; no signal is raised.

   * `The results of some bitwise operations on signed integers (C90
     6.3, C99 and C11 6.5).'

     Bitwise operators act on the representation of the value including
     both the sign and value bits, where the sign bit is considered
     immediately above the highest-value value bit.  Signed `>>' acts
     on negative numbers by sign extension.

     GCC does not use the latitude given in C99 and C11 only to treat
     certain aspects of signed `<<' as undefined, but this is subject to
     change.

   * `The sign of the remainder on integer division (C90 6.3.5).'

     GCC always follows the C99 and C11 requirement that the result of
     division is truncated towards zero.



File: llvm.info,  Node: Floating point implementation,  Next: Arrays and pointers implementation,  Prev: Integers implementation,  Up: C Implementation

4.6 Floating Point
==================

   * `The accuracy of the floating-point operations and of the library
     functions in `<math.h>' and `<complex.h>' that return
     floating-point results (C90, C99 and C11 5.2.4.2.2).'

     The accuracy is unknown.

   * `The rounding behaviors characterized by non-standard values of
     `FLT_ROUNDS'  (C90, C99 and C11 5.2.4.2.2).'

     GCC does not use such values.

   * `The evaluation methods characterized by non-standard negative
     values of `FLT_EVAL_METHOD' (C99 and C11 5.2.4.2.2).'

     GCC does not use such values.

   * `The direction of rounding when an integer is converted to a
     floating-point number that cannot exactly represent the original
     value (C90 6.2.1.3, C99 and C11 6.3.1.4).'

     C99 Annex F is followed.

   * `The direction of rounding when a floating-point number is
     converted to a narrower floating-point number (C90 6.2.1.4, C99
     and C11 6.3.1.5).'

     C99 Annex F is followed.

   * `How the nearest representable value or the larger or smaller
     representable value immediately adjacent to the nearest
     representable value is chosen for certain floating constants (C90
     6.1.3.1, C99 and C11 6.4.4.2).'

     C99 Annex F is followed.

   * `Whether and how floating expressions are contracted when not
     disallowed by the `FP_CONTRACT' pragma (C99 and C11 6.5).'

     Expressions are currently only contracted if `-ffp-contract=fast',
     `-funsafe-math-optimizations' or `-ffast-math' are used.  This is
     subject to change.

   * `The default state for the `FENV_ACCESS' pragma (C99 and C11
     7.6.1).'

     This pragma is not implemented, but the default is to "off" unless
     `-frounding-math' is used in which case it is "on".

   * `Additional floating-point exceptions, rounding modes,
     environments, and classifications, and their macro names (C99 and
     C11 7.6, C99 and C11 7.12).'

     This is dependent on the implementation of the C library, and is
     not defined by GCC itself.

   * `The default state for the `FP_CONTRACT' pragma (C99 and C11
     7.12.2).'

     This pragma is not implemented.  Expressions are currently only
     contracted if `-ffp-contract=fast', `-funsafe-math-optimizations'
     or `-ffast-math' are used.  This is subject to change.

   * `Whether the "inexact" floating-point exception can be raised when
     the rounded result actually does equal the mathematical result in
     an IEC 60559 conformant implementation (C99 F.9).'

     This is dependent on the implementation of the C library, and is
     not defined by GCC itself.

   * `Whether the "underflow" (and "inexact") floating-point exception
     can be raised when a result is tiny but not inexact in an IEC
     60559 conformant implementation (C99 F.9).'

     This is dependent on the implementation of the C library, and is
     not defined by GCC itself.



File: llvm.info,  Node: Arrays and pointers implementation,  Next: Hints implementation,  Prev: Floating point implementation,  Up: C Implementation

4.7 Arrays and Pointers
=======================

   * `The result of converting a pointer to an integer or vice versa
     (C90 6.3.4, C99 and C11 6.3.2.3).'

     A cast from pointer to integer discards most-significant bits if
     the pointer representation is larger than the integer type,
     sign-extends(1) if the pointer representation is smaller than the
     integer type, otherwise the bits are unchanged.

     A cast from integer to pointer discards most-significant bits if
     the pointer representation is smaller than the integer type,
     extends according to the signedness of the integer type if the
     pointer representation is larger than the integer type, otherwise
     the bits are unchanged.

     When casting from pointer to integer and back again, the resulting
     pointer must reference the same object as the original pointer,
     otherwise the behavior is undefined.  That is, one may not use
     integer arithmetic to avoid the undefined behavior of pointer
     arithmetic as proscribed in C99 and C11 6.5.6/8.

   * `The size of the result of subtracting two pointers to elements of
     the same array (C90 6.3.6, C99 and C11 6.5.6).'

     The value is as specified in the standard and the type is
     determined by the ABI.


 ---------- Footnotes ----------

 (1) Future versions of GCC may zero-extend, or use a target-defined
`ptr_extend' pattern.  Do not rely on sign extension.


File: llvm.info,  Node: Hints implementation,  Next: Structures unions enumerations and bit-fields implementation,  Prev: Arrays and pointers implementation,  Up: C Implementation

4.8 Hints
=========

   * `The extent to which suggestions made by using the `register'
     storage-class specifier are effective (C90 6.5.1, C99 and C11
     6.7.1).'

     The `register' specifier affects code generation only in these
     ways:

        * When used as part of the register variable extension, see
          *note Explicit Reg Vars::.

        * When `-O0' is in use, the compiler allocates distinct stack
          memory for all variables that do not have the `register'
          storage-class specifier; if `register' is specified, the
          variable may have a shorter lifespan than the code would
          indicate and may never be placed in memory.

        * On some rare x86 targets, `setjmp' doesn't save the registers
          in all circumstances.  In those cases, GCC doesn't allocate
          any variables in registers unless they are marked `register'.


   * `The extent to which suggestions made by using the inline function
     specifier are effective (C99 and C11 6.7.4).'

     GCC will not inline any functions if the `-fno-inline' option is
     used or if `-O0' is used.  Otherwise, GCC may still be unable to
     inline a function for many reasons; the `-Winline' option may be
     used to determine if a function has not been inlined and why not.



File: llvm.info,  Node: Structures unions enumerations and bit-fields implementation,  Next: Qualifiers implementation,  Prev: Hints implementation,  Up: C Implementation

4.9 Structures, Unions, Enumerations, and Bit-Fields
====================================================

   * `A member of a union object is accessed using a member of a
     different type (C90 6.3.2.3).'

     The relevant bytes of the representation of the object are treated
     as an object of the type used for the access.  *Note
     Type-punning::.  This may be a trap representation.

   * `Whether a "plain" `int' bit-field is treated as a `signed int'
     bit-field or as an `unsigned int' bit-field (C90 6.5.2, C90
     6.5.2.1, C99 and C11 6.7.2, C99 and C11 6.7.2.1).'

     By default it is treated as `signed int' but this may be changed
     by the `-funsigned-bitfields' option.

   * `Allowable bit-field types other than `_Bool', `signed int', and
     `unsigned int' (C99 and C11 6.7.2.1).'

     Other integer types, such as `long int', and enumerated types are
     permitted even in strictly conforming mode.

   * `Whether atomic types are permitted for bit-fields (C11 6.7.2.1).'

     Atomic types are not permitted for bit-fields.

   * `Whether a bit-field can straddle a storage-unit boundary (C90
     6.5.2.1, C99 and C11 6.7.2.1).'

     Determined by ABI.

   * `The order of allocation of bit-fields within a unit (C90 6.5.2.1,
     C99 and C11 6.7.2.1).'

     Determined by ABI.

   * `The alignment of non-bit-field members of structures (C90
     6.5.2.1, C99 and C11 6.7.2.1).'

     Determined by ABI.

   * `The integer type compatible with each enumerated type (C90
     6.5.2.2, C99 and C11 6.7.2.2).'

     Normally, the type is `unsigned int' if there are no negative
     values in the enumeration, otherwise `int'.  If `-fshort-enums' is
     specified, then if there are negative values it is the first of
     `signed char', `short' and `int' that can represent all the
     values, otherwise it is the first of `unsigned char', `unsigned
     short' and `unsigned int' that can represent all the values.

     On some targets, `-fshort-enums' is the default; this is
     determined by the ABI.



File: llvm.info,  Node: Qualifiers implementation,  Next: Declarators implementation,  Prev: Structures unions enumerations and bit-fields implementation,  Up: C Implementation

4.10 Qualifiers
===============

   * `What constitutes an access to an object that has
     volatile-qualified type (C90 6.5.3, C99 and C11 6.7.3).'

     Such an object is normally accessed by pointers and used for
     accessing hardware.  In most expressions, it is intuitively
     obvious what is a read and what is a write.  For example

          volatile int *dst = SOMEVALUE;
          volatile int *src = SOMEOTHERVALUE;
          *dst = *src;

     will cause a read of the volatile object pointed to by SRC and
     store the value into the volatile object pointed to by DST.  There
     is no guarantee that these reads and writes are atomic, especially
     for objects larger than `int'.

     However, if the volatile storage is not being modified, and the
     value of the volatile storage is not used, then the situation is
     less obvious.  For example

          volatile int *src = SOMEVALUE;
          *src;

     According to the C standard, such an expression is an rvalue whose
     type is the unqualified version of its original type, i.e. `int'.
     Whether GCC interprets this as a read of the volatile object being
     pointed to or only as a request to evaluate the expression for its
     side-effects depends on this type.

     If it is a scalar type, or on most targets an aggregate type whose
     only member object is of a scalar type, or a union type whose
     member objects are of scalar types, the expression is interpreted
     by GCC as a read of the volatile object; in the other cases, the
     expression is only evaluated for its side-effects.



File: llvm.info,  Node: Declarators implementation,  Next: Statements implementation,  Prev: Qualifiers implementation,  Up: C Implementation

4.11 Declarators
================

   * `The maximum number of declarators that may modify an arithmetic,
     structure or union type (C90 6.5.4).'

     GCC is only limited by available memory.



File: llvm.info,  Node: Statements implementation,  Next: Preprocessing directives implementation,  Prev: Declarators implementation,  Up: C Implementation

4.12 Statements
===============

   * `The maximum number of `case' values in a `switch' statement (C90
     6.6.4.2).'

     GCC is only limited by available memory.



File: llvm.info,  Node: Preprocessing directives implementation,  Next: Library functions implementation,  Prev: Statements implementation,  Up: C Implementation

4.13 Preprocessing Directives
=============================

*Note Implementation-defined behavior: (cpp)Implementation-defined
behavior, for details of these aspects of implementation-defined
behavior.

   * `The locations within `#pragma' directives where header name
     preprocessing tokens are recognized (C11 6.4, C11 6.4.7).'

   * `How sequences in both forms of header names are mapped to headers
     or external source file names (C90 6.1.7, C99 and C11 6.4.7).'

   * `Whether the value of a character constant in a constant expression
     that controls conditional inclusion matches the value of the same
     character constant in the execution character set (C90 6.8.1, C99
     and C11 6.10.1).'

   * `Whether the value of a single-character character constant in a
     constant expression that controls conditional inclusion may have a
     negative value (C90 6.8.1, C99 and C11 6.10.1).'

   * `The places that are searched for an included `<>' delimited
     header, and how the places are specified or the header is
     identified (C90 6.8.2, C99 and C11 6.10.2).'

   * `How the named source file is searched for in an included `""'
     delimited header (C90 6.8.2, C99 and C11 6.10.2).'

   * `The method by which preprocessing tokens (possibly resulting from
     macro expansion) in a `#include' directive are combined into a
     header name (C90 6.8.2, C99 and C11 6.10.2).'

   * `The nesting limit for `#include' processing (C90 6.8.2, C99 and
     C11 6.10.2).'

   * `Whether the `#' operator inserts a `\' character before the `\'
     character that begins a universal character name in a character
     constant or string literal (C99 and C11 6.10.3.2).'

   * `The behavior on each recognized non-`STDC #pragma' directive (C90
     6.8.6, C99 and C11 6.10.6).'

     *Note Pragmas: (cpp)Pragmas, for details of pragmas accepted by
     GCC on all targets.  *Note Pragmas Accepted by GCC: Pragmas, for
     details of target-specific pragmas.

   * `The definitions for `__DATE__' and `__TIME__' when respectively,
     the date and time of translation are not available (C90 6.8.8, C99
     6.10.8, C11 6.10.8.1).'



File: llvm.info,  Node: Library functions implementation,  Next: Architecture implementation,  Prev: Preprocessing directives implementation,  Up: C Implementation

4.14 Library Functions
======================

The behavior of most of these points are dependent on the implementation
of the C library, and are not defined by GCC itself.

   * `The null pointer constant to which the macro `NULL' expands (C90
     7.1.6, C99 7.17, C11 7.19).'

     In `<stddef.h>', `NULL' expands to `((void *)0)'.  GCC does not
     provide the other headers which define `NULL' and some library
     implementations may use other definitions in those headers.



File: llvm.info,  Node: Architecture implementation,  Next: Locale-specific behavior implementation,  Prev: Library functions implementation,  Up: C Implementation

4.15 Architecture
=================

   * `The values or expressions assigned to the macros specified in the
     headers `<float.h>', `<limits.h>', and `<stdint.h>' (C90, C99 and
     C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).'

     Determined by ABI.

   * `The result of attempting to indirectly access an object with
     automatic or thread storage duration from a thread other than the
     one with which it is associated (C11 6.2.4).'

     Such accesses are supported, subject to the same requirements for
     synchronization for concurrent accesses as for concurrent accesses
     to any object.

   * `The number, order, and encoding of bytes in any object (when not
     explicitly specified in this International Standard) (C99 and C11
     6.2.6.1).'

     Determined by ABI.

   * `Whether any extended alignments are supported and the contexts in
     which they are supported (C11 6.2.8).'

     Extended alignments up to 2^28 (bytes) are supported for objects
     of automatic storage duration.  Alignments supported for objects
     of static and thread storage duration are determined by the ABI.

   * `Valid alignment values other than those returned by an _Alignof
     expression for fundamental types, if any (C11 6.2.8).'

     Valid alignments are powers of 2 up to and including 2^28.

   * `The value of the result of the `sizeof' and `_Alignof' operators
     (C90 6.3.3.4, C99 and C11 6.5.3.4).'

     Determined by ABI.



File: llvm.info,  Node: Locale-specific behavior implementation,  Prev: Architecture implementation,  Up: C Implementation

4.16 Locale-Specific Behavior
=============================

The behavior of these points are dependent on the implementation of the
C library, and are not defined by GCC itself.


File: llvm.info,  Node: C++ Implementation,  Next: C Extensions,  Prev: C Implementation,  Up: Top

5 C++ Implementation-Defined Behavior
*************************************

A conforming implementation of ISO C++ is required to document its
choice of behavior in each of the areas that are designated
"implementation defined".  The following lists all such areas, along
with the section numbers from the ISO/IEC 14882:1998 and ISO/IEC
14882:2003 standards.  Some areas are only implementation-defined in
one version of the standard.

 Some choices depend on the externally determined ABI for the platform
(including standard character encodings) which GCC follows; these are
listed as "determined by ABI" below.  *Note Binary Compatibility:
Compatibility, and `http://gcc.gnu.org/readings.html'.  Some choices
are documented in the preprocessor manual.  *Note
Implementation-defined behavior: (cpp)Implementation-defined behavior.
Some choices are documented in the corresponding document for the C
language.  *Note C Implementation::.  Some choices are made by the
library and operating system (or other environment when compiling for a
freestanding environment); refer to their documentation for details.

* Menu:

* Conditionally-supported behavior::
* Exception handling::


File: llvm.info,  Node: Conditionally-supported behavior,  Next: Exception handling,  Up: C++ Implementation

5.1 Conditionally-Supported Behavior
====================================

`Each implementation shall include documentation that identifies all
conditionally-supported constructs that it does not support (C++0x
1.4).'

   * `Whether an argument of class type with a non-trivial copy
     constructor or destructor can be passed to ... (C++0x 5.2.2).'

     Such argument passing is supported, using the same
     pass-by-invisible-reference approach used for normal function
     arguments of such types.



File: llvm.info,  Node: Exception handling,  Prev: Conditionally-supported behavior,  Up: C++ Implementation

5.2 Exception Handling
======================

   * `In the situation where no matching handler is found, it is
     implementation-defined whether or not the stack is unwound before
     std::terminate() is called (C++98 15.5.1).'

     The stack is not unwound before std::terminate is called.



File: llvm.info,  Node: C Extensions,  Next: C++ Extensions,  Prev: C++ Implementation,  Up: Top

6 Extensions to the C Language Family
*************************************

GNU C provides several language features not found in ISO standard C.
(The `-pedantic' option directs GCC to print a warning message if any
of these features is used.)  To test for the availability of these
features in conditional compilation, check for a predefined macro
`__GNUC__', which is always defined under GCC.

 These extensions are available in C and Objective-C.  Most of them are
also available in C++.  *Note Extensions to the C++ Language: C++
Extensions, for extensions that apply _only_ to C++.

 Some features that are in ISO C99 but not C90 or C++ are also, as
extensions, accepted by GCC in C90 mode and in C++.

* Menu:

* Statement Exprs::     Putting statements and declarations inside expressions.
* Local Labels::        Labels local to a block.
* Labels as Values::    Getting pointers to labels, and computed gotos.
* Nested Functions::    As in Algol and Pascal, lexical scoping of functions.
* Constructing Calls::  Dispatching a call to another function.
* Typeof::              `typeof': referring to the type of an expression.
* Conditionals::        Omitting the middle operand of a `?:' expression.
* __int128::		128-bit integers---`__int128'.
* Long Long::           Double-word integers---`long long int'.
* Complex::             Data types for complex numbers.
* Floating Types::      Additional Floating Types.
* Half-Precision::      Half-Precision Floating Point.
* Decimal Float::       Decimal Floating Types.
* Hex Floats::          Hexadecimal floating-point constants.
* Fixed-Point::         Fixed-Point Types.
* Named Address Spaces::Named address spaces.
* Zero Length::         Zero-length arrays.
* Empty Structures::    Structures with no members.
* Variable Length::     Arrays whose length is computed at run time.
* Variadic Macros::     Macros with a variable number of arguments.
* Escaped Newlines::    Slightly looser rules for escaped newlines.
* Subscripting::        Any array can be subscripted, even if not an lvalue.
* Pointer Arith::       Arithmetic on `void'-pointers and function pointers.
* Pointers to Arrays::  Pointers to arrays with qualifiers work as expected.
* Initializers::        Non-constant initializers.
* Compound Literals::   Compound literals give structures, unions
                        or arrays as values.
* Designated Inits::    Labeling elements of initializers.
* Case Ranges::         `case 1 ... 9' and such.
* Cast to Union::       Casting to union type from any member of the union.
* Mixed Declarations::  Mixing declarations and code.
* Function Attributes:: Declaring that functions have no side effects,
                        or that they can never return.
* Label Attributes::    Specifying attributes on labels.
* Attribute Syntax::    Formal syntax for attributes.
* Function Prototypes:: Prototype declarations and old-style definitions.
* C++ Comments::        C++ comments are recognized.
* Dollar Signs::        Dollar sign is allowed in identifiers.
* Character Escapes::   `\e' stands for the character <ESC>.
* Variable Attributes:: Specifying attributes of variables.
* Type Attributes::     Specifying attributes of types.
* Alignment::           Inquiring about the alignment of a type or variable.
* Inline::              Defining inline functions (as fast as macros).
* Volatiles::           What constitutes an access to a volatile object.
* Using Assembly Language with C:: Instructions and extensions for interfacing C with assembler.
* Alternate Keywords::  `__const__', `__asm__', etc., for header files.
* Incomplete Enums::    `enum foo;', with details to follow.
* Function Names::      Printable strings which are the name of the current
                        function.
* Return Address::      Getting the return or frame address of a function.
* Vector Extensions::   Using vector instructions through built-in functions.
* Offsetof::            Special syntax for implementing `offsetof'.
* __sync Builtins::     Legacy built-in functions for atomic memory access.
* __atomic Builtins::   Atomic built-in functions with memory model.
* Integer Overflow Builtins:: Built-in functions to perform arithmetics and
                        arithmetic overflow checking.
* x86 specific memory model extensions for transactional memory:: x86 memory models.
* Object Size Checking:: Built-in functions for limited buffer overflow
                        checking.
* Pointer Bounds Checker builtins:: Built-in functions for Pointer Bounds Checker.
* Cilk Plus Builtins::  Built-in functions for the Cilk Plus language extension.
* Other Builtins::      Other built-in functions.
* Target Builtins::     Built-in functions specific to particular targets.
* Target Format Checks:: Format checks specific to particular targets.
* Pragmas::             Pragmas accepted by GCC.
* Unnamed Fields::      Unnamed struct/union fields within structs/unions.
* Thread-Local::        Per-thread variables.
* Binary constants::    Binary constants using the `0b' prefix.


File: llvm.info,  Node: Statement Exprs,  Next: Local Labels,  Up: C Extensions

6.1 Statements and Declarations in Expressions
==============================================

A compound statement enclosed in parentheses may appear as an expression
in GNU C.  This allows you to use loops, switches, and local variables
within an expression.

 Recall that a compound statement is a sequence of statements surrounded
by braces; in this construct, parentheses go around the braces.  For
example:

     ({ int y = foo (); int z;
        if (y > 0) z = y;
        else z = - y;
        z; })

is a valid (though slightly more complex than necessary) expression for
the absolute value of `foo ()'.

 The last thing in the compound statement should be an expression
followed by a semicolon; the value of this subexpression serves as the
value of the entire construct.  (If you use some other kind of statement
last within the braces, the construct has type `void', and thus
effectively no value.)

 This feature is especially useful in making macro definitions "safe"
(so that they evaluate each operand exactly once).  For example, the
"maximum" function is commonly defined as a macro in standard C as
follows:

     #define max(a,b) ((a) > (b) ? (a) : (b))

But this definition computes either A or B twice, with bad results if
the operand has side effects.  In GNU C, if you know the type of the
operands (here taken as `int'), you can define the macro safely as
follows:

     #define maxint(a,b) \
       ({int _a = (a), _b = (b); _a > _b ? _a : _b; })

 Embedded statements are not allowed in constant expressions, such as
the value of an enumeration constant, the width of a bit-field, or the
initial value of a static variable.

 If you don't know the type of the operand, you can still do this, but
you must use `typeof' or `__auto_type' (*note Typeof::).

 In G++, the result value of a statement expression undergoes array and
function pointer decay, and is returned by value to the enclosing
expression.  For instance, if `A' is a class, then

             A a;

             ({a;}).Foo ()

constructs a temporary `A' object to hold the result of the statement
expression, and that is used to invoke `Foo'.  Therefore the `this'
pointer observed by `Foo' is not the address of `a'.

 In a statement expression, any temporaries created within a statement
are destroyed at that statement's end.  This makes statement
expressions inside macros slightly different from function calls.  In
the latter case temporaries introduced during argument evaluation are
destroyed at the end of the statement that includes the function call.
In the statement expression case they are destroyed during the
statement expression.  For instance,

     #define macro(a)  ({__typeof__(a) b = (a); b + 3; })
     template<typename T> T function(T a) { T b = a; return b + 3; }

     void foo ()
     {
       macro (X ());
       function (X ());
     }

has different places where temporaries are destroyed.  For the `macro'
case, the temporary `X' is destroyed just after the initialization of
`b'.  In the `function' case that temporary is destroyed when the
function returns.

 These considerations mean that it is probably a bad idea to use
statement expressions of this form in header files that are designed to
work with C++.  (Note that some versions of the GNU C Library contained
header files using statement expressions that lead to precisely this
bug.)

 Jumping into a statement expression with `goto' or using a `switch'
statement outside the statement expression with a `case' or `default'
label inside the statement expression is not permitted.  Jumping into a
statement expression with a computed `goto' (*note Labels as Values::)
has undefined behavior.  Jumping out of a statement expression is
permitted, but if the statement expression is part of a larger
expression then it is unspecified which other subexpressions of that
expression have been evaluated except where the language definition
requires certain subexpressions to be evaluated before or after the
statement expression.  In any case, as with a function call, the
evaluation of a statement expression is not interleaved with the
evaluation of other parts of the containing expression.  For example,

       foo (), (({ bar1 (); goto a; 0; }) + bar2 ()), baz();

calls `foo' and `bar1' and does not call `baz' but may or may not call
`bar2'.  If `bar2' is called, it is called after `foo' and before
`bar1'.


File: llvm.info,  Node: Local Labels,  Next: Labels as Values,  Prev: Statement Exprs,  Up: C Extensions

6.2 Locally Declared Labels
===========================

GCC allows you to declare "local labels" in any nested block scope.  A
local label is just like an ordinary label, but you can only reference
it (with a `goto' statement, or by taking its address) within the block
in which it is declared.

 A local label declaration looks like this:

     __label__ LABEL;

or

     __label__ LABEL1, LABEL2, /* ... */;

 Local label declarations must come at the beginning of the block,
before any ordinary declarations or statements.

 The label declaration defines the label _name_, but does not define
the label itself.  You must do this in the usual way, with `LABEL:',
within the statements of the statement expression.

 The local label feature is useful for complex macros.  If a macro
contains nested loops, a `goto' can be useful for breaking out of them.
However, an ordinary label whose scope is the whole function cannot be
used: if the macro can be expanded several times in one function, the
label is multiply defined in that function.  A local label avoids this
problem.  For example:

     #define SEARCH(value, array, target)              \
     do {                                              \
       __label__ found;                                \
       typeof (target) _SEARCH_target = (target);      \
       typeof (*(array)) *_SEARCH_array = (array);     \
       int i, j;                                       \
       int value;                                      \
       for (i = 0; i < max; i++)                       \
         for (j = 0; j < max; j++)                     \
           if (_SEARCH_array[i][j] == _SEARCH_target)  \
             { (value) = i; goto found; }              \
       (value) = -1;                                   \
      found:;                                          \
     } while (0)

 This could also be written using a statement expression:

     #define SEARCH(array, target)                     \
     ({                                                \
       __label__ found;                                \
       typeof (target) _SEARCH_target = (target);      \
       typeof (*(array)) *_SEARCH_array = (array);     \
       int i, j;                                       \
       int value;                                      \
       for (i = 0; i < max; i++)                       \
         for (j = 0; j < max; j++)                     \
           if (_SEARCH_array[i][j] == _SEARCH_target)  \
             { value = i; goto found; }                \
       value = -1;                                     \
      found:                                           \
       value;                                          \
     })

 Local label declarations also make the labels they declare visible to
nested functions, if there are any.  *Note Nested Functions::, for
details.


File: llvm.info,  Node: Labels as Values,  Next: Nested Functions,  Prev: Local Labels,  Up: C Extensions

6.3 Labels as Values
====================

You can get the address of a label defined in the current function (or
a containing function) with the unary operator `&&'.  The value has
type `void *'.  This value is a constant and can be used wherever a
constant of that type is valid.  For example:

     void *ptr;
     /* ... */
     ptr = &&foo;

 To use these values, you need to be able to jump to one.  This is done
with the computed goto statement(1), `goto *EXP;'.  For example,

     goto *ptr;

Any expression of type `void *' is allowed.

 One way of using these constants is in initializing a static array that
serves as a jump table:

     static void *array[] = { &&foo, &&bar, &&hack };

Then you can select a label with indexing, like this:

     goto *array[i];

Note that this does not check whether the subscript is in bounds--array
indexing in C never does that.

 Such an array of label values serves a purpose much like that of the
`switch' statement.  The `switch' statement is cleaner, so use that
rather than an array unless the problem does not fit a `switch'
statement very well.

 Another use of label values is in an interpreter for threaded code.
The labels within the interpreter function can be stored in the
threaded code for super-fast dispatching.

 You may not use this mechanism to jump to code in a different function.
If you do that, totally unpredictable things happen.  The best way to
avoid this is to store the label address only in automatic variables and
never pass it as an argument.

 An alternate way to write the above example is

     static const int array[] = { &&foo - &&foo, &&bar - &&foo,
                                  &&hack - &&foo };
     goto *(&&foo + array[i]);

This is more friendly to code living in shared libraries, as it reduces
the number of dynamic relocations that are needed, and by consequence,
allows the data to be read-only.  This alternative with label
differences is not supported for the AVR target, please use the first
approach for AVR programs.

 The `&&foo' expressions for the same label might have different values
if the containing function is inlined or cloned.  If a program relies
on them being always the same,
`__attribute__((__noinline__,__noclone__))' should be used to prevent
inlining and cloning.  If `&&foo' is used in a static variable
initializer, inlining and cloning is forbidden.

 ---------- Footnotes ----------

 (1) The analogous feature in Fortran is called an assigned goto, but
that name seems inappropriate in C, where one can do more than simply
store label addresses in label variables.


File: llvm.info,  Node: Nested Functions,  Next: Constructing Calls,  Prev: Labels as Values,  Up: C Extensions

6.4 Nested Functions
====================

A "nested function" is a function defined inside another function.
Nested functions are supported as an extension in GNU C, but are not
supported by GNU C++.

 The nested function's name is local to the block where it is defined.
For example, here we define a nested function named `square', and call
it twice:

     foo (double a, double b)
     {
       double square (double z) { return z * z; }

       return square (a) + square (b);
     }

 The nested function can access all the variables of the containing
function that are visible at the point of its definition.  This is
called "lexical scoping".  For example, here we show a nested function
which uses an inherited variable named `offset':

     bar (int *array, int offset, int size)
     {
       int access (int *array, int index)
         { return array[index + offset]; }
       int i;
       /* ... */
       for (i = 0; i < size; i++)
         /* ... */ access (array, i) /* ... */
     }

 Nested function definitions are permitted within functions in the
places where variable definitions are allowed; that is, in any block,
mixed with the other declarations and statements in the block.

 It is possible to call the nested function from outside the scope of
its name by storing its address or passing the address to another
function:

     hack (int *array, int size)
     {
       void store (int index, int value)
         { array[index] = value; }

       intermediate (store, size);
     }

 Here, the function `intermediate' receives the address of `store' as
an argument.  If `intermediate' calls `store', the arguments given to
`store' are used to store into `array'.  But this technique works only
so long as the containing function (`hack', in this example) does not
exit.

 If you try to call the nested function through its address after the
containing function exits, all hell breaks loose.  If you try to call
it after a containing scope level exits, and if it refers to some of
the variables that are no longer in scope, you may be lucky, but it's
not wise to take the risk.  If, however, the nested function does not
refer to anything that has gone out of scope, you should be safe.

 GCC implements taking the address of a nested function using a
technique called "trampolines".  This technique was described in
`Lexical Closures for C++' (Thomas M. Breuel, USENIX C++ Conference
Proceedings, October 17-21, 1988).

 A nested function can jump to a label inherited from a containing
function, provided the label is explicitly declared in the containing
function (*note Local Labels::).  Such a jump returns instantly to the
containing function, exiting the nested function that did the `goto'
and any intermediate functions as well.  Here is an example:

     bar (int *array, int offset, int size)
     {
       __label__ failure;
       int access (int *array, int index)
         {
           if (index > size)
             goto failure;
           return array[index + offset];
         }
       int i;
       /* ... */
       for (i = 0; i < size; i++)
         /* ... */ access (array, i) /* ... */
       /* ... */
       return 0;

      /* Control comes here from `access'
         if it detects an error.  */
      failure:
       return -1;
     }

 A nested function always has no linkage.  Declaring one with `extern'
or `static' is erroneous.  If you need to declare the nested function
before its definition, use `auto' (which is otherwise meaningless for
function declarations).

     bar (int *array, int offset, int size)
     {
       __label__ failure;
       auto int access (int *, int);
       /* ... */
       int access (int *array, int index)
         {
           if (index > size)
             goto failure;
           return array[index + offset];
         }
       /* ... */
     }


File: llvm.info,  Node: Constructing Calls,  Next: Typeof,  Prev: Nested Functions,  Up: C Extensions

6.5 Constructing Function Calls
===============================

Using the built-in functions described below, you can record the
arguments a function received, and call another function with the same
arguments, without knowing the number or types of the arguments.

 You can also record the return value of that function call, and later
return that value, without knowing what data type the function tried to
return (as long as your caller expects that data type).

 However, these built-in functions may interact badly with some
sophisticated features or other extensions of the language.  It is,
therefore, not recommended to use them outside very simple functions
acting as mere forwarders for their arguments.

 -- Built-in Function: void * __builtin_apply_args ()
     This built-in function returns a pointer to data describing how to
     perform a call with the same arguments as are passed to the
     current function.

     The function saves the arg pointer register, structure value
     address, and all registers that might be used to pass arguments to
     a function into a block of memory allocated on the stack.  Then it
     returns the address of that block.

 -- Built-in Function: void * __builtin_apply (void (*FUNCTION)(), void
          *ARGUMENTS, size_t SIZE)
     This built-in function invokes FUNCTION with a copy of the
     parameters described by ARGUMENTS and SIZE.

     The value of ARGUMENTS should be the value returned by
     `__builtin_apply_args'.  The argument SIZE specifies the size of
     the stack argument data, in bytes.

     This function returns a pointer to data describing how to return
     whatever value is returned by FUNCTION.  The data is saved in a
     block of memory allocated on the stack.

     It is not always simple to compute the proper value for SIZE.  The
     value is used by `__builtin_apply' to compute the amount of data
     that should be pushed on the stack and copied from the incoming
     argument area.

 -- Built-in Function: void __builtin_return (void *RESULT)
     This built-in function returns the value described by RESULT from
     the containing function.  You should specify, for RESULT, a value
     returned by `__builtin_apply'.

 -- Built-in Function:  __builtin_va_arg_pack ()
     This built-in function represents all anonymous arguments of an
     inline function.  It can be used only in inline functions that are
     always inlined, never compiled as a separate function, such as
     those using `__attribute__ ((__always_inline__))' or
     `__attribute__ ((__gnu_inline__))' extern inline functions.  It
     must be only passed as last argument to some other function with
     variable arguments.  This is useful for writing small wrapper
     inlines for variable argument functions, when using preprocessor
     macros is undesirable.  For example:
          extern int myprintf (FILE *f, const char *format, ...);
          extern inline __attribute__ ((__gnu_inline__)) int
          myprintf (FILE *f, const char *format, ...)
          {
            int r = fprintf (f, "myprintf: ");
            if (r < 0)
              return r;
            int s = fprintf (f, format, __builtin_va_arg_pack ());
            if (s < 0)
              return s;
            return r + s;
          }

 -- Built-in Function: size_t __builtin_va_arg_pack_len ()
     This built-in function returns the number of anonymous arguments of
     an inline function.  It can be used only in inline functions that
     are always inlined, never compiled as a separate function, such as
     those using `__attribute__ ((__always_inline__))' or
     `__attribute__ ((__gnu_inline__))' extern inline functions.  For
     example following does link- or run-time checking of open
     arguments for optimized code:
          #ifdef __OPTIMIZE__
          extern inline __attribute__((__gnu_inline__)) int
          myopen (const char *path, int oflag, ...)
          {
            if (__builtin_va_arg_pack_len () > 1)
              warn_open_too_many_arguments ();

            if (__builtin_constant_p (oflag))
              {
                if ((oflag & O_CREAT) != 0 && __builtin_va_arg_pack_len () < 1)
                  {
                    warn_open_missing_mode ();
                    return __open_2 (path, oflag);
                  }
                return open (path, oflag, __builtin_va_arg_pack ());
              }

            if (__builtin_va_arg_pack_len () < 1)
              return __open_2 (path, oflag);

            return open (path, oflag, __builtin_va_arg_pack ());
          }
          #endif


File: llvm.info,  Node: Typeof,  Next: Conditionals,  Prev: Constructing Calls,  Up: C Extensions

6.6 Referring to a Type with `typeof'
=====================================

Another way to refer to the type of an expression is with `typeof'.
The syntax of using of this keyword looks like `sizeof', but the
construct acts semantically like a type name defined with `typedef'.

 There are two ways of writing the argument to `typeof': with an
expression or with a type.  Here is an example with an expression:

     typeof (x[0](1))

This assumes that `x' is an array of pointers to functions; the type
described is that of the values of the functions.

 Here is an example with a typename as the argument:

     typeof (int *)

Here the type described is that of pointers to `int'.

 If you are writing a header file that must work when included in ISO C
programs, write `__typeof__' instead of `typeof'.  *Note Alternate
Keywords::.

 A `typeof' construct can be used anywhere a typedef name can be used.
For example, you can use it in a declaration, in a cast, or inside of
`sizeof' or `typeof'.

 The operand of `typeof' is evaluated for its side effects if and only
if it is an expression of variably modified type or the name of such a
type.

 `typeof' is often useful in conjunction with statement expressions
(*note Statement Exprs::).  Here is how the two together can be used to
define a safe "maximum" macro which operates on any arithmetic type and
evaluates each of its arguments exactly once:

     #define max(a,b) \
       ({ typeof (a) _a = (a); \
           typeof (b) _b = (b); \
         _a > _b ? _a : _b; })

 The reason for using names that start with underscores for the local
variables is to avoid conflicts with variable names that occur within
the expressions that are substituted for `a' and `b'.  Eventually we
hope to design a new form of declaration syntax that allows you to
declare variables whose scopes start only after their initializers;
this will be a more reliable way to prevent such conflicts.

Some more examples of the use of `typeof':

   * This declares `y' with the type of what `x' points to.

          typeof (*x) y;

   * This declares `y' as an array of such values.

          typeof (*x) y[4];

   * This declares `y' as an array of pointers to characters:

          typeof (typeof (char *)[4]) y;

     It is equivalent to the following traditional C declaration:

          char *y[4];

     To see the meaning of the declaration using `typeof', and why it
     might be a useful way to write, rewrite it with these macros:

          #define pointer(T)  typeof(T *)
          #define array(T, N) typeof(T [N])

     Now the declaration can be rewritten this way:

          array (pointer (char), 4) y;

     Thus, `array (pointer (char), 4)' is the type of arrays of 4
     pointers to `char'.

 In GNU C, but not GNU C++, you may also declare the type of a variable
as `__auto_type'.  In that case, the declaration must declare only one
variable, whose declarator must just be an identifier, the declaration
must be initialized, and the type of the variable is determined by the
initializer; the name of the variable is not in scope until after the
initializer.  (In C++, you should use C++11 `auto' for this purpose.)
Using `__auto_type', the "maximum" macro above could be written as:

     #define max(a,b) \
       ({ __auto_type _a = (a); \
           __auto_type _b = (b); \
         _a > _b ? _a : _b; })

 Using `__auto_type' instead of `typeof' has two advantages:

   * Each argument to the macro appears only once in the expansion of
     the macro.  This prevents the size of the macro expansion growing
     exponentially when calls to such macros are nested inside
     arguments of such macros.

   * If the argument to the macro has variably modified type, it is
     evaluated only once when using `__auto_type', but twice if
     `typeof' is used.


File: llvm.info,  Node: Conditionals,  Next: __int128,  Prev: Typeof,  Up: C Extensions

6.7 Conditionals with Omitted Operands
======================================

The middle operand in a conditional expression may be omitted.  Then if
the first operand is nonzero, its value is the value of the conditional
expression.

 Therefore, the expression

     x ? : y

has the value of `x' if that is nonzero; otherwise, the value of `y'.

 This example is perfectly equivalent to

     x ? x : y

In this simple case, the ability to omit the middle operand is not
especially useful.  When it becomes useful is when the first operand
does, or may (if it is a macro argument), contain a side effect.  Then
repeating the operand in the middle would perform the side effect
twice.  Omitting the middle operand uses the value already computed
without the undesirable effects of recomputing it.


File: llvm.info,  Node: __int128,  Next: Long Long,  Prev: Conditionals,  Up: C Extensions

6.8 128-bit Integers
====================

As an extension the integer scalar type `__int128' is supported for
targets which have an integer mode wide enough to hold 128 bits.
Simply write `__int128' for a signed 128-bit integer, or `unsigned
__int128' for an unsigned 128-bit integer.  There is no support in GCC
for expressing an integer constant of type `__int128' for targets with
`long long' integer less than 128 bits wide.


File: llvm.info,  Node: Long Long,  Next: Complex,  Prev: __int128,  Up: C Extensions

6.9 Double-Word Integers
========================

ISO C99 supports data types for integers that are at least 64 bits wide,
and as an extension GCC supports them in C90 mode and in C++.  Simply
write `long long int' for a signed integer, or `unsigned long long int'
for an unsigned integer.  To make an integer constant of type `long
long int', add the suffix `LL' to the integer.  To make an integer
constant of type `unsigned long long int', add the suffix `ULL' to the
integer.

 You can use these types in arithmetic like any other integer types.
Addition, subtraction, and bitwise boolean operations on these types
are open-coded on all types of machines.  Multiplication is open-coded
if the machine supports a fullword-to-doubleword widening multiply
instruction.  Division and shifts are open-coded only on machines that
provide special support.  The operations that are not open-coded use
special library routines that come with GCC.

 There may be pitfalls when you use `long long' types for function
arguments without function prototypes.  If a function expects type
`int' for its argument, and you pass a value of type `long long int',
confusion results because the caller and the subroutine disagree about
the number of bytes for the argument.  Likewise, if the function
expects `long long int' and you pass `int'.  The best way to avoid such
problems is to use prototypes.


File: llvm.info,  Node: Complex,  Next: Floating Types,  Prev: Long Long,  Up: C Extensions

6.10 Complex Numbers
====================

ISO C99 supports complex floating data types, and as an extension GCC
supports them in C90 mode and in C++.  GCC also supports complex
integer data types which are not part of ISO C99.  You can declare
complex types using the keyword `_Complex'.  As an extension, the older
GNU keyword `__complex__' is also supported.

 For example, `_Complex double x;' declares `x' as a variable whose
real part and imaginary part are both of type `double'.  `_Complex
short int y;' declares `y' to have real and imaginary parts of type
`short int'; this is not likely to be useful, but it shows that the set
of complex types is complete.

 To write a constant with a complex data type, use the suffix `i' or
`j' (either one; they are equivalent).  For example, `2.5fi' has type
`_Complex float' and `3i' has type `_Complex int'.  Such a constant
always has a pure imaginary value, but you can form any complex value
you like by adding one to a real constant.  This is a GNU extension; if
you have an ISO C99 conforming C library (such as the GNU C Library),
and want to construct complex constants of floating type, you should
include `<complex.h>' and use the macros `I' or `_Complex_I' instead.

 To extract the real part of a complex-valued expression EXP, write
`__real__ EXP'.  Likewise, use `__imag__' to extract the imaginary
part.  This is a GNU extension; for values of floating type, you should
use the ISO C99 functions `crealf', `creal', `creall', `cimagf',
`cimag' and `cimagl', declared in `<complex.h>' and also provided as
built-in functions by GCC.

 The operator `~' performs complex conjugation when used on a value
with a complex type.  This is a GNU extension; for values of floating
type, you should use the ISO C99 functions `conjf', `conj' and `conjl',
declared in `<complex.h>' and also provided as built-in functions by
GCC.

 GCC can allocate complex automatic variables in a noncontiguous
fashion; it's even possible for the real part to be in a register while
the imaginary part is on the stack (or vice versa).  Only the DWARF 2
debug info format can represent this, so use of DWARF 2 is recommended.
If you are using the stabs debug info format, GCC describes a
noncontiguous complex variable as if it were two separate variables of
noncomplex type.  If the variable's actual name is `foo', the two
fictitious variables are named `foo$real' and `foo$imag'.  You can
examine and set these two fictitious variables with your debugger.


File: llvm.info,  Node: Floating Types,  Next: Half-Precision,  Prev: Complex,  Up: C Extensions

6.11 Additional Floating Types
==============================

As an extension, GNU C supports additional floating types, `__float80'
and `__float128' to support 80-bit (`XFmode') and 128-bit (`TFmode')
floating types.  Support for additional types includes the arithmetic
operators: add, subtract, multiply, divide; unary arithmetic operators;
relational operators; equality operators; and conversions to and from
integer and other floating types.  Use a suffix `w' or `W' in a literal
constant of type `__float80' and `q' or `Q' for `_float128'.  You can
declare complex types using the corresponding internal complex type,
`XCmode' for `__float80' type and `TCmode' for `__float128' type:

     typedef _Complex float __attribute__((mode(TC))) _Complex128;
     typedef _Complex float __attribute__((mode(XC))) _Complex80;

 Not all targets support additional floating-point types.  `__float80'
and `__float128' types are supported on x86 and IA-64 targets.  The
`__float128' type is supported on hppa HP-UX targets.


File: llvm.info,  Node: Half-Precision,  Next: Decimal Float,  Prev: Floating Types,  Up: C Extensions

6.12 Half-Precision Floating Point
==================================

On ARM targets, GCC supports half-precision (16-bit) floating point via
the `__fp16' type.  You must enable this type explicitly with the
`-mfp16-format' command-line option in order to use it.

 ARM supports two incompatible representations for half-precision
floating-point values.  You must choose one of the representations and
use it consistently in your program.

 Specifying `-mfp16-format=ieee' selects the IEEE 754-2008 format.
This format can represent normalized values in the range of 2^-14 to
65504.  There are 11 bits of significand precision, approximately 3
decimal digits.

 Specifying `-mfp16-format=alternative' selects the ARM alternative
format.  This representation is similar to the IEEE format, but does
not support infinities or NaNs.  Instead, the range of exponents is
extended, so that this format can represent normalized values in the
range of 2^-14 to 131008.

 The `__fp16' type is a storage format only.  For purposes of
arithmetic and other operations, `__fp16' values in C or C++
expressions are automatically promoted to `float'.  In addition, you
cannot declare a function with a return value or parameters of type
`__fp16'.

 Note that conversions from `double' to `__fp16' involve an
intermediate conversion to `float'.  Because of rounding, this can
sometimes produce a different result than a direct conversion.

 ARM provides hardware support for conversions between `__fp16' and
`float' values as an extension to VFP and NEON (Advanced SIMD).  GCC
generates code using these hardware instructions if you compile with
options to select an FPU that provides them; for example,
`-mfpu=neon-fp16 -mfloat-abi=softfp', in addition to the
`-mfp16-format' option to select a half-precision format.

 Language-level support for the `__fp16' data type is independent of
whether GCC generates code using hardware floating-point instructions.
In cases where hardware support is not specified, GCC implements
conversions between `__fp16' and `float' values as library calls.


File: llvm.info,  Node: Decimal Float,  Next: Hex Floats,  Prev: Half-Precision,  Up: C Extensions

6.13 Decimal Floating Types
===========================

As an extension, GNU C supports decimal floating types as defined in
the N1312 draft of ISO/IEC WDTR24732.  Support for decimal floating
types in GCC will evolve as the draft technical report changes.
Calling conventions for any target might also change.  Not all targets
support decimal floating types.

 The decimal floating types are `_Decimal32', `_Decimal64', and
`_Decimal128'.  They use a radix of ten, unlike the floating types
`float', `double', and `long double' whose radix is not specified by
the C standard but is usually two.

 Support for decimal floating types includes the arithmetic operators
add, subtract, multiply, divide; unary arithmetic operators; relational
operators; equality operators; and conversions to and from integer and
other floating types.  Use a suffix `df' or `DF' in a literal constant
of type `_Decimal32', `dd' or `DD' for `_Decimal64', and `dl' or `DL'
for `_Decimal128'.

 GCC support of decimal float as specified by the draft technical report
is incomplete:

   * When the value of a decimal floating type cannot be represented in
     the integer type to which it is being converted, the result is
     undefined rather than the result value specified by the draft
     technical report.

   * GCC does not provide the C library functionality associated with
     `math.h', `fenv.h', `stdio.h', `stdlib.h', and `wchar.h', which
     must come from a separate C library implementation.  Because of
     this the GNU C compiler does not define macro `__STDC_DEC_FP__' to
     indicate that the implementation conforms to the technical report.

 Types `_Decimal32', `_Decimal64', and `_Decimal128' are supported by
the DWARF 2 debug information format.


File: llvm.info,  Node: Hex Floats,  Next: Fixed-Point,  Prev: Decimal Float,  Up: C Extensions

6.14 Hex Floats
===============

ISO C99 supports floating-point numbers written not only in the usual
decimal notation, such as `1.55e1', but also numbers such as `0x1.fp3'
written in hexadecimal format.  As a GNU extension, GCC supports this
in C90 mode (except in some cases when strictly conforming) and in C++.
In that format the `0x' hex introducer and the `p' or `P' exponent
field are mandatory.  The exponent is a decimal number that indicates
the power of 2 by which the significant part is multiplied.  Thus
`0x1.f' is 1 15/16, `p3' multiplies it by 8, and the value of `0x1.fp3'
is the same as `1.55e1'.

 Unlike for floating-point numbers in the decimal notation the exponent
is always required in the hexadecimal notation.  Otherwise the compiler
would not be able to resolve the ambiguity of, e.g., `0x1.f'.  This
could mean `1.0f' or `1.9375' since `f' is also the extension for
floating-point constants of type `float'.


File: llvm.info,  Node: Fixed-Point,  Next: Named Address Spaces,  Prev: Hex Floats,  Up: C Extensions

6.15 Fixed-Point Types
======================

As an extension, GNU C supports fixed-point types as defined in the
N1169 draft of ISO/IEC DTR 18037.  Support for fixed-point types in GCC
will evolve as the draft technical report changes.  Calling conventions
for any target might also change.  Not all targets support fixed-point
types.

 The fixed-point types are `short _Fract', `_Fract', `long _Fract',
`long long _Fract', `unsigned short _Fract', `unsigned _Fract',
`unsigned long _Fract', `unsigned long long _Fract', `_Sat short
_Fract', `_Sat _Fract', `_Sat long _Fract', `_Sat long long _Fract',
`_Sat unsigned short _Fract', `_Sat unsigned _Fract', `_Sat unsigned
long _Fract', `_Sat unsigned long long _Fract', `short _Accum',
`_Accum', `long _Accum', `long long _Accum', `unsigned short _Accum',
`unsigned _Accum', `unsigned long _Accum', `unsigned long long _Accum',
`_Sat short _Accum', `_Sat _Accum', `_Sat long _Accum', `_Sat long long
_Accum', `_Sat unsigned short _Accum', `_Sat unsigned _Accum', `_Sat
unsigned long _Accum', `_Sat unsigned long long _Accum'.

 Fixed-point data values contain fractional and optional integral parts.
The format of fixed-point data varies and depends on the target machine.

 Support for fixed-point types includes:
   * prefix and postfix increment and decrement operators (`++', `--')

   * unary arithmetic operators (`+', `-', `!')

   * binary arithmetic operators (`+', `-', `*', `/')

   * binary shift operators (`<<', `>>')

   * relational operators (`<', `<=', `>=', `>')

   * equality operators (`==', `!=')

   * assignment operators (`+=', `-=', `*=', `/=', `<<=', `>>=')

   * conversions to and from integer, floating-point, or fixed-point
     types

 Use a suffix in a fixed-point literal constant:
   * `hr' or `HR' for `short _Fract' and `_Sat short _Fract'

   * `r' or `R' for `_Fract' and `_Sat _Fract'

   * `lr' or `LR' for `long _Fract' and `_Sat long _Fract'

   * `llr' or `LLR' for `long long _Fract' and `_Sat long long _Fract'

   * `uhr' or `UHR' for `unsigned short _Fract' and `_Sat unsigned
     short _Fract'

   * `ur' or `UR' for `unsigned _Fract' and `_Sat unsigned _Fract'

   * `ulr' or `ULR' for `unsigned long _Fract' and `_Sat unsigned long
     _Fract'

   * `ullr' or `ULLR' for `unsigned long long _Fract' and `_Sat
     unsigned long long _Fract'

   * `hk' or `HK' for `short _Accum' and `_Sat short _Accum'

   * `k' or `K' for `_Accum' and `_Sat _Accum'

   * `lk' or `LK' for `long _Accum' and `_Sat long _Accum'

   * `llk' or `LLK' for `long long _Accum' and `_Sat long long _Accum'

   * `uhk' or `UHK' for `unsigned short _Accum' and `_Sat unsigned
     short _Accum'

   * `uk' or `UK' for `unsigned _Accum' and `_Sat unsigned _Accum'

   * `ulk' or `ULK' for `unsigned long _Accum' and `_Sat unsigned long
     _Accum'

   * `ullk' or `ULLK' for `unsigned long long _Accum' and `_Sat
     unsigned long long _Accum'

 GCC support of fixed-point types as specified by the draft technical
report is incomplete:

   * Pragmas to control overflow and rounding behaviors are not
     implemented.

 Fixed-point types are supported by the DWARF 2 debug information
format.


File: llvm.info,  Node: Named Address Spaces,  Next: Zero Length,  Prev: Fixed-Point,  Up: C Extensions

6.16 Named Address Spaces
=========================

As an extension, GNU C supports named address spaces as defined in the
N1275 draft of ISO/IEC DTR 18037.  Support for named address spaces in
GCC will evolve as the draft technical report changes.  Calling
conventions for any target might also change.  At present, only the
AVR, SPU, M32C, and RL78 targets support address spaces other than the
generic address space.

 Address space identifiers may be used exactly like any other C type
qualifier (e.g., `const' or `volatile').  See the N1275 document for
more details.

6.16.1 AVR Named Address Spaces
-------------------------------

On the AVR target, there are several address spaces that can be used in
order to put read-only data into the flash memory and access that data
by means of the special instructions `LPM' or `ELPM' needed to read
from flash.

 Per default, any data including read-only data is located in RAM (the
generic address space) so that non-generic address spaces are needed to
locate read-only data in flash memory _and_ to generate the right
instructions to access this data without using (inline) assembler code.

`__flash'
     The `__flash' qualifier locates data in the `.progmem.data'
     section. Data is read using the `LPM' instruction. Pointers to
     this address space are 16 bits wide.

`__flash1'
`__flash2'
`__flash3'
`__flash4'
`__flash5'
     These are 16-bit address spaces locating data in section
     `.progmemN.data' where N refers to address space `__flashN'.  The
     compiler sets the `RAMPZ' segment register appropriately before
     reading data by means of the `ELPM' instruction.

`__memx'
     This is a 24-bit address space that linearizes flash and RAM: If
     the high bit of the address is set, data is read from RAM using
     the lower two bytes as RAM address.  If the high bit of the
     address is clear, data is read from flash with `RAMPZ' set
     according to the high byte of the address.  *Note
     `__builtin_avr_flash_segment': AVR Built-in Functions.

     Objects in this address space are located in `.progmemx.data'.

 Example

     char my_read (const __flash char ** p)
     {
         /* p is a pointer to RAM that points to a pointer to flash.
            The first indirection of p reads that flash pointer
            from RAM and the second indirection reads a char from this
            flash address.  */

         return **p;
     }

     /* Locate array[] in flash memory */
     const __flash int array[] = { 3, 5, 7, 11, 13, 17, 19 };

     int i = 1;

     int main (void)
     {
        /* Return 17 by reading from flash memory */
        return array[array[i]];
     }

For each named address space supported by avr-gcc there is an equally
named but uppercase built-in macro defined.  The purpose is to
facilitate testing if respective address space support is available or
not:

     #ifdef __FLASH
     const __flash int var = 1;

     int read_var (void)
     {
         return var;
     }
     #else
     #include <avr/pgmspace.h> /* From AVR-LibC */

     const int var PROGMEM = 1;

     int read_var (void)
     {
         return (int) pgm_read_word (&var);
     }
     #endif /* __FLASH */

Notice that attribute *note `progmem': AVR Variable Attributes.
locates data in flash but accesses to these data read from generic
address space, i.e.  from RAM, so that you need special accessors like
`pgm_read_byte' from AVR-LibC (http://nongnu.org/avr-libc/user-manual/)
together with attribute `progmem'.

Limitations and caveats

   * Reading across the 64 KiB section boundary of the `__flash' or
     `__flashN' address spaces shows undefined behavior. The only
     address space that supports reading across the 64 KiB flash
     segment boundaries is `__memx'.

   * If you use one of the `__flashN' address spaces you must arrange
     your linker script to locate the `.progmemN.data' sections
     according to your needs.

   * Any data or pointers to the non-generic address spaces must be
     qualified as `const', i.e. as read-only data.  This still applies
     if the data in one of these address spaces like software version
     number or calibration lookup table are intended to be changed
     after load time by, say, a boot loader. In this case the right
     qualification is `const' `volatile' so that the compiler must not
     optimize away known values or insert them as immediates into
     operands of instructions.

   * The following code initializes a variable `pfoo' located in static
     storage with a 24-bit address:
          extern const __memx char foo;
          const __memx void *pfoo = &foo;

     Such code requires at least binutils 2.23, see
     PR13503 (http://sourceware.org/PR13503).


6.16.2 M32C Named Address Spaces
--------------------------------

On the M32C target, with the R8C and M16C CPU variants, variables
qualified with `__far' are accessed using 32-bit addresses in order to
access memory beyond the first 64 Ki bytes.  If `__far' is used with
the M32CM or M32C CPU variants, it has no effect.

6.16.3 RL78 Named Address Spaces
--------------------------------

On the RL78 target, variables qualified with `__far' are accessed with
32-bit pointers (20-bit addresses) rather than the default 16-bit
addresses.  Non-far variables are assumed to appear in the topmost
64 KiB of the address space.

6.16.4 SPU Named Address Spaces
-------------------------------

On the SPU target variables may be declared as belonging to another
address space by qualifying the type with the `__ea' address space
identifier:

     extern int __ea i;

The compiler generates special code to access the variable `i'.  It may
use runtime library support, or generate special machine instructions
to access that address space.


File: llvm.info,  Node: Zero Length,  Next: Empty Structures,  Prev: Named Address Spaces,  Up: C Extensions

6.17 Arrays of Length Zero
==========================

Zero-length arrays are allowed in GNU C.  They are very useful as the
last element of a structure that is really a header for a
variable-length object:

     struct line {
       int length;
       char contents[0];
     };

     struct line *thisline = (struct line *)
       malloc (sizeof (struct line) + this_length);
     thisline->length = this_length;

 In ISO C90, you would have to give `contents' a length of 1, which
means either you waste space or complicate the argument to `malloc'.

 In ISO C99, you would use a "flexible array member", which is slightly
different in syntax and semantics:

   * Flexible array members are written as `contents[]' without the `0'.

   * Flexible array members have incomplete type, and so the `sizeof'
     operator may not be applied.  As a quirk of the original
     implementation of zero-length arrays, `sizeof' evaluates to zero.

   * Flexible array members may only appear as the last member of a
     `struct' that is otherwise non-empty.

   * A structure containing a flexible array member, or a union
     containing such a structure (possibly recursively), may not be a
     member of a structure or an element of an array.  (However, these
     uses are permitted by GCC as extensions.)

 Non-empty initialization of zero-length arrays is treated like any
case where there are more initializer elements than the array holds, in
that a suitable warning about "excess elements in array" is given, and
the excess elements (all of them, in this case) are ignored.

 GCC allows static initialization of flexible array members.  This is
equivalent to defining a new structure containing the original
structure followed by an array of sufficient size to contain the data.
E.g. in the following, `f1' is constructed as if it were declared like
`f2'.

     struct f1 {
       int x; int y[];
     } f1 = { 1, { 2, 3, 4 } };

     struct f2 {
       struct f1 f1; int data[3];
     } f2 = { { 1 }, { 2, 3, 4 } };

The convenience of this extension is that `f1' has the desired type,
eliminating the need to consistently refer to `f2.f1'.

 This has symmetry with normal static arrays, in that an array of
unknown size is also written with `[]'.

 Of course, this extension only makes sense if the extra data comes at
the end of a top-level object, as otherwise we would be overwriting
data at subsequent offsets.  To avoid undue complication and confusion
with initialization of deeply nested arrays, we simply disallow any
non-empty initialization except when the structure is the top-level
object.  For example:

     struct foo { int x; int y[]; };
     struct bar { struct foo z; };

     struct foo a = { 1, { 2, 3, 4 } };        // Valid.
     struct bar b = { { 1, { 2, 3, 4 } } };    // Invalid.
     struct bar c = { { 1, { } } };            // Valid.
     struct foo d[1] = { { 1, { 2, 3, 4 } } };  // Invalid.


File: llvm.info,  Node: Empty Structures,  Next: Variable Length,  Prev: Zero Length,  Up: C Extensions

6.18 Structures with No Members
===============================

GCC permits a C structure to have no members:

     struct empty {
     };

 The structure has size zero.  In C++, empty structures are part of the
language.  G++ treats empty structures as if they had a single member
of type `char'.


File: llvm.info,  Node: Variable Length,  Next: Variadic Macros,  Prev: Empty Structures,  Up: C Extensions

6.19 Arrays of Variable Length
==============================

Variable-length automatic arrays are allowed in ISO C99, and as an
extension GCC accepts them in C90 mode and in C++.  These arrays are
declared like any other automatic arrays, but with a length that is not
a constant expression.  The storage is allocated at the point of
declaration and deallocated when the block scope containing the
declaration exits.  For example:

     FILE *
     concat_fopen (char *s1, char *s2, char *mode)
     {
       char str[strlen (s1) + strlen (s2) + 1];
       strcpy (str, s1);
       strcat (str, s2);
       return fopen (str, mode);
     }

 Jumping or breaking out of the scope of the array name deallocates the
storage.  Jumping into the scope is not allowed; you get an error
message for it.

 As an extension, GCC accepts variable-length arrays as a member of a
structure or a union.  For example:

     void
     foo (int n)
     {
       struct S { int x[n]; };
     }

 You can use the function `alloca' to get an effect much like
variable-length arrays.  The function `alloca' is available in many
other C implementations (but not in all).  On the other hand,
variable-length arrays are more elegant.

 There are other differences between these two methods.  Space allocated
with `alloca' exists until the containing _function_ returns.  The
space for a variable-length array is deallocated as soon as the array
name's scope ends.  (If you use both variable-length arrays and
`alloca' in the same function, deallocation of a variable-length array
also deallocates anything more recently allocated with `alloca'.)

 You can also use variable-length arrays as arguments to functions:

     struct entry
     tester (int len, char data[len][len])
     {
       /* ... */
     }

 The length of an array is computed once when the storage is allocated
and is remembered for the scope of the array in case you access it with
`sizeof'.

 If you want to pass the array first and the length afterward, you can
use a forward declaration in the parameter list--another GNU extension.

     struct entry
     tester (int len; char data[len][len], int len)
     {
       /* ... */
     }

 The `int len' before the semicolon is a "parameter forward
declaration", and it serves the purpose of making the name `len' known
when the declaration of `data' is parsed.

 You can write any number of such parameter forward declarations in the
parameter list.  They can be separated by commas or semicolons, but the
last one must end with a semicolon, which is followed by the "real"
parameter declarations.  Each forward declaration must match a "real"
declaration in parameter name and data type.  ISO C99 does not support
parameter forward declarations.


File: llvm.info,  Node: Variadic Macros,  Next: Escaped Newlines,  Prev: Variable Length,  Up: C Extensions

6.20 Macros with a Variable Number of Arguments.
================================================

In the ISO C standard of 1999, a macro can be declared to accept a
variable number of arguments much as a function can.  The syntax for
defining the macro is similar to that of a function.  Here is an
example:

     #define debug(format, ...) fprintf (stderr, format, __VA_ARGS__)

Here `...' is a "variable argument".  In the invocation of such a
macro, it represents the zero or more tokens until the closing
parenthesis that ends the invocation, including any commas.  This set of
tokens replaces the identifier `__VA_ARGS__' in the macro body wherever
it appears.  See the CPP manual for more information.

 GCC has long supported variadic macros, and used a different syntax
that allowed you to give a name to the variable arguments just like any
other argument.  Here is an example:

     #define debug(format, args...) fprintf (stderr, format, args)

This is in all ways equivalent to the ISO C example above, but arguably
more readable and descriptive.

 GNU CPP has two further variadic macro extensions, and permits them to
be used with either of the above forms of macro definition.

 In standard C, you are not allowed to leave the variable argument out
entirely; but you are allowed to pass an empty argument.  For example,
this invocation is invalid in ISO C, because there is no comma after
the string:

     debug ("A message")

 GNU CPP permits you to completely omit the variable arguments in this
way.  In the above examples, the compiler would complain, though since
the expansion of the macro still has the extra comma after the format
string.

 To help solve this problem, CPP behaves specially for variable
arguments used with the token paste operator, `##'.  If instead you
write

     #define debug(format, ...) fprintf (stderr, format, ## __VA_ARGS__)

and if the variable arguments are omitted or empty, the `##' operator
causes the preprocessor to remove the comma before it.  If you do
provide some variable arguments in your macro invocation, GNU CPP does
not complain about the paste operation and instead places the variable
arguments after the comma.  Just like any other pasted macro argument,
these arguments are not macro expanded.


File: llvm.info,  Node: Escaped Newlines,  Next: Subscripting,  Prev: Variadic Macros,  Up: C Extensions

6.21 Slightly Looser Rules for Escaped Newlines
===============================================

The preprocessor treatment of escaped newlines is more relaxed than
that specified by the C90 standard, which requires the newline to
immediately follow a backslash.  GCC's implementation allows whitespace
in the form of spaces, horizontal and vertical tabs, and form feeds
between the backslash and the subsequent newline.  The preprocessor
issues a warning, but treats it as a valid escaped newline and combines
the two lines to form a single logical line.  This works within
comments and tokens, as well as between tokens.  Comments are _not_
treated as whitespace for the purposes of this relaxation, since they
have not yet been replaced with spaces.


File: llvm.info,  Node: Subscripting,  Next: Pointer Arith,  Prev: Escaped Newlines,  Up: C Extensions

6.22 Non-Lvalue Arrays May Have Subscripts
==========================================

In ISO C99, arrays that are not lvalues still decay to pointers, and
may be subscripted, although they may not be modified or used after the
next sequence point and the unary `&' operator may not be applied to
them.  As an extension, GNU C allows such arrays to be subscripted in
C90 mode, though otherwise they do not decay to pointers outside C99
mode.  For example, this is valid in GNU C though not valid in C90:

     struct foo {int a[4];};

     struct foo f();

     bar (int index)
     {
       return f().a[index];
     }


File: llvm.info,  Node: Pointer Arith,  Next: Pointers to Arrays,  Prev: Subscripting,  Up: C Extensions

6.23 Arithmetic on `void'- and Function-Pointers
================================================

In GNU C, addition and subtraction operations are supported on pointers
to `void' and on pointers to functions.  This is done by treating the
size of a `void' or of a function as 1.

 A consequence of this is that `sizeof' is also allowed on `void' and
on function types, and returns 1.

 The option `-Wpointer-arith' requests a warning if these extensions
are used.


File: llvm.info,  Node: Pointers to Arrays,  Next: Initializers,  Prev: Pointer Arith,  Up: C Extensions

6.24 Pointers to Arrays with Qualifiers Work as Expected
========================================================

In GNU C, pointers to arrays with qualifiers work similar to pointers
to other qualified types. For example, a value of type `int (*)[5]' can
be used to initialize a variable of type `const int (*)[5]'.  These
types are incompatible in ISO C because the `const' qualifier is
formally attached to the element type of the array and not the array
itself.

     extern void
     transpose (int N, int M, double out[M][N], const double in[N][M]);
     double x[3][2];
     double y[2][3];
     ...
     transpose(3, 2, y, x);


File: llvm.info,  Node: Initializers,  Next: Compound Literals,  Prev: Pointers to Arrays,  Up: C Extensions

6.25 Non-Constant Initializers
==============================

As in standard C++ and ISO C99, the elements of an aggregate
initializer for an automatic variable are not required to be constant
expressions in GNU C.  Here is an example of an initializer with
run-time varying elements:

     foo (float f, float g)
     {
       float beat_freqs[2] = { f-g, f+g };
       /* ... */
     }


File: llvm.info,  Node: Compound Literals,  Next: Designated Inits,  Prev: Initializers,  Up: C Extensions

6.26 Compound Literals
======================

ISO C99 supports compound literals.  A compound literal looks like a
cast containing an initializer.  Its value is an object of the type
specified in the cast, containing the elements specified in the
initializer; it is an lvalue.  As an extension, GCC supports compound
literals in C90 mode and in C++, though the semantics are somewhat
different in C++.

 Usually, the specified type is a structure.  Assume that `struct foo'
and `structure' are declared as shown:

     struct foo {int a; char b[2];} structure;

Here is an example of constructing a `struct foo' with a compound
literal:

     structure = ((struct foo) {x + y, 'a', 0});

This is equivalent to writing the following:

     {
       struct foo temp = {x + y, 'a', 0};
       structure = temp;
     }

 You can also construct an array, though this is dangerous in C++, as
explained below.  If all the elements of the compound literal are (made
up of) simple constant expressions, suitable for use in initializers of
objects of static storage duration, then the compound literal can be
coerced to a pointer to its first element and used in such an
initializer, as shown here:

     char **foo = (char *[]) { "x", "y", "z" };

 Compound literals for scalar types and union types are also allowed,
but then the compound literal is equivalent to a cast.

 As a GNU extension, GCC allows initialization of objects with static
storage duration by compound literals (which is not possible in ISO
C99, because the initializer is not a constant).  It is handled as if
the object is initialized only with the bracket enclosed list if the
types of the compound literal and the object match.  The initializer
list of the compound literal must be constant.  If the object being
initialized has array type of unknown size, the size is determined by
compound literal size.

     static struct foo x = (struct foo) {1, 'a', 'b'};
     static int y[] = (int []) {1, 2, 3};
     static int z[] = (int [3]) {1};

The above lines are equivalent to the following:
     static struct foo x = {1, 'a', 'b'};
     static int y[] = {1, 2, 3};
     static int z[] = {1, 0, 0};

 In C, a compound literal designates an unnamed object with static or
automatic storage duration.  In C++, a compound literal designates a
temporary object, which only lives until the end of its
full-expression.  As a result, well-defined C code that takes the
address of a subobject of a compound literal can be undefined in C++,
so the C++ compiler rejects the conversion of a temporary array to a
pointer.  For instance, if the array compound literal example above
appeared inside a function, any subsequent use of `foo' in C++ has
undefined behavior because the lifetime of the array ends after the
declaration of `foo'.

 As an optimization, the C++ compiler sometimes gives array compound
literals longer lifetimes: when the array either appears outside a
function or has const-qualified type.  If `foo' and its initializer had
elements of `char *const' type rather than `char *', or if `foo' were a
global variable, the array would have static storage duration.  But it
is probably safest just to avoid the use of array compound literals in
code compiled as C++.


File: llvm.info,  Node: Designated Inits,  Next: Case Ranges,  Prev: Compound Literals,  Up: C Extensions

6.27 Designated Initializers
============================

Standard C90 requires the elements of an initializer to appear in a
fixed order, the same as the order of the elements in the array or
structure being initialized.

 In ISO C99 you can give the elements in any order, specifying the array
indices or structure field names they apply to, and GNU C allows this as
an extension in C90 mode as well.  This extension is not implemented in
GNU C++.

 To specify an array index, write `[INDEX] =' before the element value.
For example,

     int a[6] = { [4] = 29, [2] = 15 };

is equivalent to

     int a[6] = { 0, 0, 15, 0, 29, 0 };

The index values must be constant expressions, even if the array being
initialized is automatic.

 An alternative syntax for this that has been obsolete since GCC 2.5 but
GCC still accepts is to write `[INDEX]' before the element value, with
no `='.

 To initialize a range of elements to the same value, write `[FIRST ...
LAST] = VALUE'.  This is a GNU extension.  For example,

     int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };

If the value in it has side-effects, the side-effects happen only once,
not for each initialized field by the range initializer.

Note that the length of the array is the highest value specified plus
one.

 In a structure initializer, specify the name of a field to initialize
with `.FIELDNAME =' before the element value.  For example, given the
following structure,

     struct point { int x, y; };

the following initialization

     struct point p = { .y = yvalue, .x = xvalue };

is equivalent to

     struct point p = { xvalue, yvalue };

 Another syntax that has the same meaning, obsolete since GCC 2.5, is
`FIELDNAME:', as shown here:

     struct point p = { y: yvalue, x: xvalue };

 Omitted field members are implicitly initialized the same as objects
that have static storage duration.

 The `[INDEX]' or `.FIELDNAME' is known as a "designator".  You can
also use a designator (or the obsolete colon syntax) when initializing
a union, to specify which element of the union should be used.  For
example,

     union foo { int i; double d; };

     union foo f = { .d = 4 };

converts 4 to a `double' to store it in the union using the second
element.  By contrast, casting 4 to type `union foo' stores it into the
union as the integer `i', since it is an integer.  (*Note Cast to
Union::.)

 You can combine this technique of naming elements with ordinary C
initialization of successive elements.  Each initializer element that
does not have a designator applies to the next consecutive element of
the array or structure.  For example,

     int a[6] = { [1] = v1, v2, [4] = v4 };

is equivalent to

     int a[6] = { 0, v1, v2, 0, v4, 0 };

 Labeling the elements of an array initializer is especially useful
when the indices are characters or belong to an `enum' type.  For
example:

     int whitespace[256]
       = { [' '] = 1, ['\t'] = 1, ['\h'] = 1,
           ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 };

 You can also write a series of `.FIELDNAME' and `[INDEX]' designators
before an `=' to specify a nested subobject to initialize; the list is
taken relative to the subobject corresponding to the closest
surrounding brace pair.  For example, with the `struct point'
declaration above:

     struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };

If the same field is initialized multiple times, it has the value from
the last initialization.  If any such overridden initialization has
side-effect, it is unspecified whether the side-effect happens or not.
Currently, GCC discards them and issues a warning.


File: llvm.info,  Node: Case Ranges,  Next: Cast to Union,  Prev: Designated Inits,  Up: C Extensions

6.28 Case Ranges
================

You can specify a range of consecutive values in a single `case' label,
like this:

     case LOW ... HIGH:

This has the same effect as the proper number of individual `case'
labels, one for each integer value from LOW to HIGH, inclusive.

 This feature is especially useful for ranges of ASCII character codes:

     case 'A' ... 'Z':

 *Be careful:* Write spaces around the `...', for otherwise it may be
parsed wrong when you use it with integer values.  For example, write
this:

     case 1 ... 5:

rather than this:

     case 1...5:


File: llvm.info,  Node: Cast to Union,  Next: Mixed Declarations,  Prev: Case Ranges,  Up: C Extensions

6.29 Cast to a Union Type
=========================

A cast to union type is similar to other casts, except that the type
specified is a union type.  You can specify the type either with `union
TAG' or with a typedef name.  A cast to union is actually a
constructor, not a cast, and hence does not yield an lvalue like normal
casts.  (*Note Compound Literals::.)

 The types that may be cast to the union type are those of the members
of the union.  Thus, given the following union and variables:

     union foo { int i; double d; };
     int x;
     double y;

both `x' and `y' can be cast to type `union foo'.

 Using the cast as the right-hand side of an assignment to a variable of
union type is equivalent to storing in a member of the union:

     union foo u;
     /* ... */
     u = (union foo) x  ==  u.i = x
     u = (union foo) y  ==  u.d = y

 You can also use the union cast as a function argument:

     void hack (union foo);
     /* ... */
     hack ((union foo) x);


File: llvm.info,  Node: Mixed Declarations,  Next: Function Attributes,  Prev: Cast to Union,  Up: C Extensions

6.30 Mixed Declarations and Code
================================

ISO C99 and ISO C++ allow declarations and code to be freely mixed
within compound statements.  As an extension, GNU C also allows this in
C90 mode.  For example, you could do:

     int i;
     /* ... */
     i++;
     int j = i + 2;

 Each identifier is visible from where it is declared until the end of
the enclosing block.


File: llvm.info,  Node: Function Attributes,  Next: Label Attributes,  Prev: Mixed Declarations,  Up: C Extensions

6.31 Declaring Attributes of Functions
======================================

In GNU C, you declare certain things about functions called in your
program which help the compiler optimize function calls and check your
code more carefully.

 The keyword `__attribute__' allows you to specify special attributes
when making a declaration.  This keyword is followed by an attribute
specification inside double parentheses.  The following attributes are
currently defined for functions on all targets: `aligned',
`alloc_size', `alloc_align', `assume_aligned', `noreturn',
`returns_twice', `noinline', `noclone', `no_icf', `always_inline',
`flatten', `pure', `const', `nothrow', `sentinel', `format',
`format_arg', `no_instrument_function', `no_split_stack', `section',
`constructor', `destructor', `used', `unused', `deprecated', `weak',
`malloc', `alias', `ifunc', `warn_unused_result', `nonnull',
`returns_nonnull', `gnu_inline', `externally_visible', `hot', `cold',
`artificial', `no_sanitize_address', `no_address_safety_analysis',
`no_sanitize_thread', `no_sanitize_undefined', `no_reorder',
`bnd_legacy', `bnd_instrument', `stack_protect', `error' and `warning'.
Several other attributes are defined for functions on particular target
systems.  Other attributes, including `section' are supported for
variables declarations (*note Variable Attributes::), labels (*note
Label Attributes::) and for types (*note Type Attributes::).

 GCC plugins may provide their own attributes.

 You may also specify attributes with `__' preceding and following each
keyword.  This allows you to use them in header files without being
concerned about a possible macro of the same name.  For example, you
may use `__noreturn__' instead of `noreturn'.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

`alias ("TARGET")'
     The `alias' attribute causes the declaration to be emitted as an
     alias for another symbol, which must be specified.  For instance,

          void __f () { /* Do something. */; }
          void f () __attribute__ ((weak, alias ("__f")));

     defines `f' to be a weak alias for `__f'.  In C++, the mangled
     name for the target must be used.  It is an error if `__f' is not
     defined in the same translation unit.

     Not all target machines support this attribute.

`aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment for the function,
     measured in bytes.

     You cannot use this attribute to decrease the alignment of a
     function, only to increase it.  However, when you explicitly
     specify a function alignment this overrides the effect of the
     `-falign-functions' (*note Optimize Options::) option for this
     function.

     Note that the effectiveness of `aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for functions to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  See your linker
     documentation for further information.

     The `aligned' attribute can also be used for variables and fields
     (*note Variable Attributes::.)

`alloc_size'
     The `alloc_size' attribute is used to tell the compiler that the
     function return value points to memory, where the size is given by
     one or two of the functions parameters.  GCC uses this information
     to improve the correctness of `__builtin_object_size'.

     The function parameter(s) denoting the allocated size are
     specified by one or two integer arguments supplied to the
     attribute.  The allocated size is either the value of the single
     function argument specified or the product of the two function
     arguments specified.  Argument numbering starts at one.

     For instance,

          void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))
          void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))

     declares that `my_calloc' returns memory of the size given by the
     product of parameter 1 and 2 and that `my_realloc' returns memory
     of the size given by parameter 2.

`alloc_align'
     The `alloc_align' attribute is used to tell the compiler that the
     function return value points to memory, where the returned pointer
     minimum alignment is given by one of the functions parameters.
     GCC uses this information to improve pointer alignment analysis.

     The function parameter denoting the allocated alignment is
     specified by one integer argument, whose number is the argument of
     the attribute.  Argument numbering starts at one.

     For instance,

          void* my_memalign(size_t, size_t) __attribute__((alloc_align(1)))

     declares that `my_memalign' returns memory with minimum alignment
     given by parameter 1.

`assume_aligned'
     The `assume_aligned' attribute is used to tell the compiler that
     the function return value points to memory, where the returned
     pointer minimum alignment is given by the first argument.  If the
     attribute has two arguments, the second argument is misalignment
     offset.

     For instance

          void* my_alloc1(size_t) __attribute__((assume_aligned(16)))
          void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))

     declares that `my_alloc1' returns 16-byte aligned pointer and that
     `my_alloc2' returns a pointer whose value modulo 32 is equal to 8.

`always_inline'
     Generally, functions are not inlined unless optimization is
     specified.  For functions declared inline, this attribute inlines
     the function independent of any restrictions that otherwise apply
     to inlining.  Failure to inline such a function is diagnosed as an
     error.  Note that if such a function is called indirectly the
     compiler may or may not inline it depending on optimization level
     and a failure to inline an indirect call may or may not be
     diagnosed.

`gnu_inline'
     This attribute should be used with a function that is also declared
     with the `inline' keyword.  It directs GCC to treat the function
     as if it were defined in gnu90 mode even when compiling in C99 or
     gnu99 mode.

     If the function is declared `extern', then this definition of the
     function is used only for inlining.  In no case is the function
     compiled as a standalone function, not even if you take its address
     explicitly.  Such an address becomes an external reference, as if
     you had only declared the function, and had not defined it.  This
     has almost the effect of a macro.  The way to use this is to put a
     function definition in a header file with this attribute, and put
     another copy of the function, without `extern', in a library file.
     The definition in the header file causes most calls to the
     function to be inlined.  If any uses of the function remain, they
     refer to the single copy in the library.  Note that the two
     definitions of the functions need not be precisely the same,
     although if they do not have the same effect your program may
     behave oddly.

     In C, if the function is neither `extern' nor `static', then the
     function is compiled as a standalone function, as well as being
     inlined where possible.

     This is how GCC traditionally handled functions declared `inline'.
     Since ISO C99 specifies a different semantics for `inline', this
     function attribute is provided as a transition measure and as a
     useful feature in its own right.  This attribute is available in
     GCC 4.1.3 and later.  It is available if either of the
     preprocessor macros `__GNUC_GNU_INLINE__' or
     `__GNUC_STDC_INLINE__' are defined.  *Note An Inline Function is
     As Fast As a Macro: Inline.

     In C++, this attribute does not depend on `extern' in any way, but
     it still requires the `inline' keyword to enable its special
     behavior.

`artificial'
     This attribute is useful for small inline wrappers that if possible
     should appear during debugging as a unit.  Depending on the debug
     info format it either means marking the function as artificial or
     using the caller location for all instructions within the inlined
     body.

`bank_switch'
     When added to an interrupt handler with the M32C port, causes the
     prologue and epilogue to use bank switching to preserve the
     registers rather than saving them on the stack.

`flatten'
     Generally, inlining into a function is limited.  For a function
     marked with this attribute, every call inside this function is
     inlined, if possible.  Whether the function itself is considered
     for inlining depends on its size and the current inlining
     parameters.

`error ("MESSAGE")'
     If this attribute is used on a function declaration and a call to
     such a function is not eliminated through dead code elimination or
     other optimizations, an error that includes MESSAGE is diagnosed.
     This is useful for compile-time checking, especially together with
     `__builtin_constant_p' and inline functions where checking the
     inline function arguments is not possible through `extern char
     [(condition) ? 1 : -1];' tricks.  While it is possible to leave
     the function undefined and thus invoke a link failure, when using
     this attribute the problem is diagnosed earlier and with exact
     location of the call even in presence of inline functions or when
     not emitting debugging information.

`warning ("MESSAGE")'
     If this attribute is used on a function declaration and a call to
     such a function is not eliminated through dead code elimination or
     other optimizations, a warning that includes MESSAGE is diagnosed.
     This is useful for compile-time checking, especially together with
     `__builtin_constant_p' and inline functions.  While it is possible
     to define the function with a message in `.gnu.warning*' section,
     when using this attribute the problem is diagnosed earlier and
     with exact location of the call even in presence of inline
     functions or when not emitting debugging information.

`cdecl'
     On the x86-32 targets, the `cdecl' attribute causes the compiler to
     assume that the calling function pops off the stack space used to
     pass arguments.  This is useful to override the effects of the
     `-mrtd' switch.

`const'
     Many functions do not examine any values except their arguments,
     and have no effects except the return value.  Basically this is
     just slightly more strict class than the `pure' attribute below,
     since function is not allowed to read global memory.

     Note that a function that has pointer arguments and examines the
     data pointed to must _not_ be declared `const'.  Likewise, a
     function that calls a non-`const' function usually must not be
     `const'.  It does not make sense for a `const' function to return
     `void'.

`constructor'
`destructor'
`constructor (PRIORITY)'
`destructor (PRIORITY)'
     The `constructor' attribute causes the function to be called
     automatically before execution enters `main ()'.  Similarly, the
     `destructor' attribute causes the function to be called
     automatically after `main ()' completes or `exit ()' is called.
     Functions with these attributes are useful for initializing data
     that is used implicitly during the execution of the program.

     You may provide an optional integer priority to control the order
     in which constructor and destructor functions are run.  A
     constructor with a smaller priority number runs before a
     constructor with a larger priority number; the opposite
     relationship holds for destructors.  So, if you have a constructor
     that allocates a resource and a destructor that deallocates the
     same resource, both functions typically have the same priority.
     The priorities for constructor and destructor functions are the
     same as those specified for namespace-scope C++ objects (*note C++
     Attributes::).

     These attributes are not currently implemented for Objective-C.

`deprecated'
`deprecated (MSG)'
     The `deprecated' attribute results in a warning if the function is
     used anywhere in the source file.  This is useful when identifying
     functions that are expected to be removed in a future version of a
     program.  The warning also includes the location of the declaration
     of the deprecated function, to enable users to easily find further
     information about why the function is deprecated, or what they
     should do instead.  Note that the warnings only occurs for uses:

          int old_fn () __attribute__ ((deprecated));
          int old_fn ();
          int (*fn_ptr)() = old_fn;

     results in a warning on line 3 but not line 2.  The optional MSG
     argument, which must be a string, is printed in the warning if
     present.

     The `deprecated' attribute can also be used for variables and
     types (*note Variable Attributes::, *note Type Attributes::.)

`disinterrupt'
     On Epiphany and MeP targets, this attribute causes the compiler to
     emit instructions to disable interrupts for the duration of the
     given function.

`dllexport'
     On Microsoft Windows targets and Symbian OS targets the
     `dllexport' attribute causes the compiler to provide a global
     pointer to a pointer in a DLL, so that it can be referenced with
     the `dllimport' attribute.  On Microsoft Windows targets, the
     pointer name is formed by combining `_imp__' and the function or
     variable name.

     You can use `__declspec(dllexport)' as a synonym for
     `__attribute__ ((dllexport))' for compatibility with other
     compilers.

     On systems that support the `visibility' attribute, this attribute
     also implies "default" visibility.  It is an error to explicitly
     specify any other visibility.

     GCC's default behavior is to emit all inline functions with the
     `dllexport' attribute.  Since this can cause object file-size
     bloat, you can use `-fno-keep-inline-dllexport', which tells GCC to
     ignore the attribute for inlined functions unless the
     `-fkeep-inline-functions' flag is used instead.

     The attribute is ignored for undefined symbols.

     When applied to C++ classes, the attribute marks defined
     non-inlined member functions and static data members as exports.
     Static consts initialized in-class are not marked unless they are
     also defined out-of-class.

     For Microsoft Windows targets there are alternative methods for
     including the symbol in the DLL's export table such as using a
     `.def' file with an `EXPORTS' section or, with GNU ld, using the
     `--export-all' linker flag.

`dllimport'
     On Microsoft Windows and Symbian OS targets, the `dllimport'
     attribute causes the compiler to reference a function or variable
     via a global pointer to a pointer that is set up by the DLL
     exporting the symbol.  The attribute implies `extern'.  On
     Microsoft Windows targets, the pointer name is formed by combining
     `_imp__' and the function or variable name.

     You can use `__declspec(dllimport)' as a synonym for
     `__attribute__ ((dllimport))' for compatibility with other
     compilers.

     On systems that support the `visibility' attribute, this attribute
     also implies "default" visibility.  It is an error to explicitly
     specify any other visibility.

     Currently, the attribute is ignored for inlined functions.  If the
     attribute is applied to a symbol _definition_, an error is
     reported.  If a symbol previously declared `dllimport' is later
     defined, the attribute is ignored in subsequent references, and a
     warning is emitted.  The attribute is also overridden by a
     subsequent declaration as `dllexport'.

     When applied to C++ classes, the attribute marks non-inlined
     member functions and static data members as imports.  However, the
     attribute is ignored for virtual methods to allow creation of
     vtables using thunks.

     On the SH Symbian OS target the `dllimport' attribute also has
     another affect--it can cause the vtable and run-time type
     information for a class to be exported.  This happens when the
     class has a dllimported constructor or a non-inline, non-pure
     virtual function and, for either of those two conditions, the
     class also has an inline constructor or destructor and has a key
     function that is defined in the current translation unit.

     For Microsoft Windows targets the use of the `dllimport' attribute
     on functions is not necessary, but provides a small performance
     benefit by eliminating a thunk in the DLL.  The use of the
     `dllimport' attribute on imported variables can be avoided by
     passing the `--enable-auto-import' switch to the GNU linker.  As
     with functions, using the attribute for a variable eliminates a
     thunk in the DLL.

     One drawback to using this attribute is that a pointer to a
     _variable_ marked as `dllimport' cannot be used as a constant
     address. However, a pointer to a _function_ with the `dllimport'
     attribute can be used as a constant initializer; in this case, the
     address of a stub function in the import lib is referenced.  On
     Microsoft Windows targets, the attribute can be disabled for
     functions by setting the `-mnop-fun-dllimport' flag.

`eightbit_data'
     Use this attribute on the H8/300, H8/300H, and H8S to indicate
     that the specified variable should be placed into the eight-bit
     data section.  The compiler generates more efficient code for
     certain operations on data in the eight-bit data area.  Note the
     eight-bit data area is limited to 256 bytes of data.

     You must use GAS and GLD from GNU binutils version 2.7 or later for
     this attribute to work correctly.

`exception'
     Use this attribute on the NDS32 target to indicate that the
     specified function is an exception handler.  The compiler will
     generate corresponding sections for use in an exception handler.

`exception_handler'
     Use this attribute on the Blackfin to indicate that the specified
     function is an exception handler.  The compiler generates function
     entry and exit sequences suitable for use in an exception handler
     when this attribute is present.

`externally_visible'
     This attribute, attached to a global variable or function,
     nullifies the effect of the `-fwhole-program' command-line option,
     so the object remains visible outside the current compilation unit.

     If `-fwhole-program' is used together with `-flto' and `gold' is
     used as the linker plugin, `externally_visible' attributes are
     automatically added to functions (not variable yet due to a
     current `gold' issue) that are accessed outside of LTO objects
     according to resolution file produced by `gold'.  For other
     linkers that cannot generate resolution file, explicit
     `externally_visible' attributes are still necessary.

`far'
     On 68HC11 and 68HC12 the `far' attribute causes the compiler to
     use a calling convention that takes care of switching memory banks
     when entering and leaving a function.  This calling convention is
     also the default when using the `-mlong-calls' option.

     On 68HC12 the compiler uses the `call' and `rtc' instructions to
     call and return from a function.

     On 68HC11 the compiler generates a sequence of instructions to
     invoke a board-specific routine to switch the memory bank and call
     the real function.  The board-specific routine simulates a `call'.
     At the end of a function, it jumps to a board-specific routine
     instead of using `rts'.  The board-specific return routine
     simulates the `rtc'.

     On MeP targets this causes the compiler to use a calling convention
     that assumes the called function is too far away for the built-in
     addressing modes.

`fast_interrupt'
     Use this attribute on the M32C and RX ports to indicate that the
     specified function is a fast interrupt handler.  This is just like
     the `interrupt' attribute, except that `freit' is used to return
     instead of `reit'.

`fastcall'
     On x86-32 targets, the `fastcall' attribute causes the compiler to
     pass the first argument (if of integral type) in the register ECX
     and the second argument (if of integral type) in the register EDX.
     Subsequent and other typed arguments are passed on the stack.  The
     called function pops the arguments off the stack.  If the number
     of arguments is variable all arguments are pushed on the stack.

`thiscall'
     On x86-32 targets, the `thiscall' attribute causes the compiler to
     pass the first argument (if of integral type) in the register ECX.
     Subsequent and other typed arguments are passed on the stack. The
     called function pops the arguments off the stack.  If the number
     of arguments is variable all arguments are pushed on the stack.
     The `thiscall' attribute is intended for C++ non-static member
     functions.  As a GCC extension, this calling convention can be
     used for C functions and for static member methods.

`format (ARCHETYPE, STRING-INDEX, FIRST-TO-CHECK)'
     The `format' attribute specifies that a function takes `printf',
     `scanf', `strftime' or `strfmon' style arguments that should be
     type-checked against a format string.  For example, the
     declaration:

          extern int
          my_printf (void *my_object, const char *my_format, ...)
                __attribute__ ((format (printf, 2, 3)));

     causes the compiler to check the arguments in calls to `my_printf'
     for consistency with the `printf' style format string argument
     `my_format'.

     The parameter ARCHETYPE determines how the format string is
     interpreted, and should be `printf', `scanf', `strftime',
     `gnu_printf', `gnu_scanf', `gnu_strftime' or `strfmon'.  (You can
     also use `__printf__', `__scanf__', `__strftime__' or
     `__strfmon__'.)  On MinGW targets, `ms_printf', `ms_scanf', and
     `ms_strftime' are also present.  ARCHETYPE values such as `printf'
     refer to the formats accepted by the system's C runtime library,
     while values prefixed with `gnu_' always refer to the formats
     accepted by the GNU C Library.  On Microsoft Windows targets,
     values prefixed with `ms_' refer to the formats accepted by the
     `msvcrt.dll' library.  The parameter STRING-INDEX specifies which
     argument is the format string argument (starting from 1), while
     FIRST-TO-CHECK is the number of the first argument to check
     against the format string.  For functions where the arguments are
     not available to be checked (such as `vprintf'), specify the third
     parameter as zero.  In this case the compiler only checks the
     format string for consistency.  For `strftime' formats, the third
     parameter is required to be zero.  Since non-static C++ methods
     have an implicit `this' argument, the arguments of such methods
     should be counted from two, not one, when giving values for
     STRING-INDEX and FIRST-TO-CHECK.

     In the example above, the format string (`my_format') is the second
     argument of the function `my_print', and the arguments to check
     start with the third argument, so the correct parameters for the
     format attribute are 2 and 3.

     The `format' attribute allows you to identify your own functions
     that take format strings as arguments, so that GCC can check the
     calls to these functions for errors.  The compiler always (unless
     `-ffreestanding' or `-fno-builtin' is used) checks formats for the
     standard library functions `printf', `fprintf', `sprintf',
     `scanf', `fscanf', `sscanf', `strftime', `vprintf', `vfprintf' and
     `vsprintf' whenever such warnings are requested (using
     `-Wformat'), so there is no need to modify the header file
     `stdio.h'.  In C99 mode, the functions `snprintf', `vsnprintf',
     `vscanf', `vfscanf' and `vsscanf' are also checked.  Except in
     strictly conforming C standard modes, the X/Open function
     `strfmon' is also checked as are `printf_unlocked' and
     `fprintf_unlocked'.  *Note Options Controlling C Dialect: C
     Dialect Options.

     For Objective-C dialects, `NSString' (or `__NSString__') is
     recognized in the same context.  Declarations including these
     format attributes are parsed for correct syntax, however the
     result of checking of such format strings is not yet defined, and
     is not carried out by this version of the compiler.

     The target may also provide additional types of format checks.
     *Note Format Checks Specific to Particular Target Machines: Target
     Format Checks.

`format_arg (STRING-INDEX)'
     The `format_arg' attribute specifies that a function takes a format
     string for a `printf', `scanf', `strftime' or `strfmon' style
     function and modifies it (for example, to translate it into
     another language), so the result can be passed to a `printf',
     `scanf', `strftime' or `strfmon' style function (with the
     remaining arguments to the format function the same as they would
     have been for the unmodified string).  For example, the
     declaration:

          extern char *
          my_dgettext (char *my_domain, const char *my_format)
                __attribute__ ((format_arg (2)));

     causes the compiler to check the arguments in calls to a `printf',
     `scanf', `strftime' or `strfmon' type function, whose format
     string argument is a call to the `my_dgettext' function, for
     consistency with the format string argument `my_format'.  If the
     `format_arg' attribute had not been specified, all the compiler
     could tell in such calls to format functions would be that the
     format string argument is not constant; this would generate a
     warning when `-Wformat-nonliteral' is used, but the calls could
     not be checked without the attribute.

     The parameter STRING-INDEX specifies which argument is the format
     string argument (starting from one).  Since non-static C++ methods
     have an implicit `this' argument, the arguments of such methods
     should be counted from two.

     The `format_arg' attribute allows you to identify your own
     functions that modify format strings, so that GCC can check the
     calls to `printf', `scanf', `strftime' or `strfmon' type function
     whose operands are a call to one of your own function.  The
     compiler always treats `gettext', `dgettext', and `dcgettext' in
     this manner except when strict ISO C support is requested by
     `-ansi' or an appropriate `-std' option, or `-ffreestanding' or
     `-fno-builtin' is used.  *Note Options Controlling C Dialect: C
     Dialect Options.

     For Objective-C dialects, the `format-arg' attribute may refer to
     an `NSString' reference for compatibility with the `format'
     attribute above.

     The target may also allow additional types in `format-arg'
     attributes.  *Note Format Checks Specific to Particular Target
     Machines: Target Format Checks.

`function_vector'
     Use this attribute on the H8/300, H8/300H, and H8S to indicate
     that the specified function should be called through the function
     vector.  Calling a function through the function vector reduces
     code size, however; the function vector has a limited size
     (maximum 128 entries on the H8/300 and 64 entries on the H8/300H
     and H8S) and shares space with the interrupt vector.

     On SH2A targets, this attribute declares a function to be called
     using the TBR relative addressing mode.  The argument to this
     attribute is the entry number of the same function in a vector
     table containing all the TBR relative addressable functions.  For
     correct operation the TBR must be setup accordingly to point to
     the start of the vector table before any functions with this
     attribute are invoked.  Usually a good place to do the
     initialization is the startup routine.  The TBR relative vector
     table can have at max 256 function entries.  The jumps to these
     functions are generated using a SH2A specific, non delayed branch
     instruction JSR/N @(disp8,TBR).  You must use GAS and GLD from GNU
     binutils version 2.7 or later for this attribute to work correctly.

     Please refer the example of M16C target, to see the use of this
     attribute while declaring a function,

     In an application, for a function being called once, this attribute
     saves at least 8 bytes of code; and if other successive calls are
     being made to the same function, it saves 2 bytes of code per each
     of these calls.

     On M16C/M32C targets, the `function_vector' attribute declares a
     special page subroutine call function. Use of this attribute
     reduces the code size by 2 bytes for each call generated to the
     subroutine. The argument to the attribute is the vector number
     entry from the special page vector table which contains the 16
     low-order bits of the subroutine's entry address. Each vector
     table has special page number (18 to 255) that is used in `jsrs'
     instructions.  Jump addresses of the routines are generated by
     adding 0x0F0000 (in case of M16C targets) or 0xFF0000 (in case of
     M32C targets), to the 2-byte addresses set in the vector table.
     Therefore you need to ensure that all the special page vector
     routines should get mapped within the address range 0x0F0000 to
     0x0FFFFF (for M16C) and 0xFF0000 to 0xFFFFFF (for M32C).

     In the following example 2 bytes are saved for each call to
     function `foo'.

          void foo (void) __attribute__((function_vector(0x18)));
          void foo (void)
          {
          }

          void bar (void)
          {
              foo();
          }

     If functions are defined in one file and are called in another
     file, then be sure to write this declaration in both files.

     This attribute is ignored for R8C target.

`ifunc ("RESOLVER")'
     The `ifunc' attribute is used to mark a function as an indirect
     function using the STT_GNU_IFUNC symbol type extension to the ELF
     standard.  This allows the resolution of the symbol value to be
     determined dynamically at load time, and an optimized version of
     the routine can be selected for the particular processor or other
     system characteristics determined then.  To use this attribute,
     first define the implementation functions available, and a
     resolver function that returns a pointer to the selected
     implementation function.  The implementation functions'
     declarations must match the API of the function being implemented,
     the resolver's declaration is be a function returning pointer to
     void function returning void:

          void *my_memcpy (void *dst, const void *src, size_t len)
          {
            ...
          }

          static void (*resolve_memcpy (void)) (void)
          {
            return my_memcpy; // we'll just always select this routine
          }

     The exported header file declaring the function the user calls
     would contain:

          extern void *memcpy (void *, const void *, size_t);

     allowing the user to call this as a regular function, unaware of
     the implementation.  Finally, the indirect function needs to be
     defined in the same translation unit as the resolver function:

          void *memcpy (void *, const void *, size_t)
               __attribute__ ((ifunc ("resolve_memcpy")));

     Indirect functions cannot be weak.  Binutils version 2.20.1 or
     higher and GNU C Library version 2.11.1 are required to use this
     feature.

`interrupt'
     Use this attribute on the ARC, ARM, AVR, CR16, Epiphany, M32C,
     M32R/D, m68k, MeP, MIPS, MSP430, RL78, RX, Visium and Xstormy16
     ports to indicate that the specified function is an interrupt
     handler.  The compiler generates function entry and exit sequences
     suitable for use in an interrupt handler when this attribute is
     present.  With Epiphany targets it may also generate a special
     section with code to initialize the interrupt vector table.

     Note, interrupt handlers for the Blackfin, H8/300, H8/300H, H8S,
     MicroBlaze, and SH processors can be specified via the
     `interrupt_handler' attribute.

     Note, on the ARC, you must specify the kind of interrupt to be
     handled in a parameter to the interrupt attribute like this:

          void f () __attribute__ ((interrupt ("ilink1")));

     Permissible values for this parameter are: `ilink1' and `ilink2'.

     Note, on the AVR, the hardware globally disables interrupts when an
     interrupt is executed.  The first instruction of an interrupt
     handler declared with this attribute is a `SEI' instruction to
     re-enable interrupts.  See also the `signal' function attribute
     that does not insert a `SEI' instruction.  If both `signal' and
     `interrupt' are specified for the same function, `signal' is
     silently ignored.

     Note, for the ARM, you can specify the kind of interrupt to be
     handled by adding an optional parameter to the interrupt attribute
     like this:

          void f () __attribute__ ((interrupt ("IRQ")));

     Permissible values for this parameter are: `IRQ', `FIQ', `SWI',
     `ABORT' and `UNDEF'.

     On ARMv7-M the interrupt type is ignored, and the attribute means
     the function may be called with a word-aligned stack pointer.

     Note, for the MSP430 you can provide an argument to the interrupt
     attribute which specifies a name or number.  If the argument is a
     number it indicates the slot in the interrupt vector table (0 -
     31) to which this handler should be assigned.  If the argument is
     a name it is treated as a symbolic name for the vector slot.
     These names should match up with appropriate entries in the linker
     script.  By default the names `watchdog' for vector 26, `nmi' for
     vector 30 and `reset' for vector 31 are recognized.

     You can also use the following function attributes to modify how
     normal functions interact with interrupt functions:

    `critical'
          Critical functions disable interrupts upon entry and restore
          the previous interrupt state upon exit.  Critical functions
          cannot also have the `naked' or `reentrant' attributes.  They
          can have the `interrupt' attribute.

    `reentrant'
          Reentrant functions disable interrupts upon entry and enable
          them upon exit.  Reentrant functions cannot also have the
          `naked' or `critical' attributes.  They can have the
          `interrupt' attribute.

    `wakeup'
          This attribute only applies to interrupt functions.  It is
          silently ignored if applied to a non-interrupt function.  A
          wakeup interrupt function will rouse the processor from any
          low-power state that it might be in when the function exits.


     On Epiphany targets one or more optional parameters can be added
     like this:

          void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();

     Permissible values for these parameters are: `reset',
     `software_exception', `page_miss', `timer0', `timer1', `message',
     `dma0', `dma1', `wand' and `swi'.  Multiple parameters indicate
     that multiple entries in the interrupt vector table should be
     initialized for this function, i.e. for each parameter NAME, a
     jump to the function is emitted in the section ivt_entry_NAME.
     The parameter(s) may be omitted entirely, in which case no
     interrupt vector table entry is provided.

     Note, on Epiphany targets, interrupts are enabled inside the
     function unless the `disinterrupt' attribute is also specified.

     On Epiphany targets, you can also use the following attribute to
     modify the behavior of an interrupt handler:
    `forwarder_section'
          The interrupt handler may be in external memory which cannot
          be reached by a branch instruction, so generate a local
          memory trampoline to transfer control.  The single parameter
          identifies the section where the trampoline is placed.

     The following examples are all valid uses of these attributes on
     Epiphany targets:
          void __attribute__ ((interrupt)) universal_handler ();
          void __attribute__ ((interrupt ("dma1"))) dma1_handler ();
          void __attribute__ ((interrupt ("dma0, dma1"))) universal_dma_handler ();
          void __attribute__ ((interrupt ("timer0"), disinterrupt))
            fast_timer_handler ();
          void __attribute__ ((interrupt ("dma0, dma1"), forwarder_section ("tramp")))
            external_dma_handler ();

     On MIPS targets, you can use the following attributes to modify
     the behavior of an interrupt handler:
    `use_shadow_register_set'
          Assume that the handler uses a shadow register set, instead of
          the main general-purpose registers.

    `keep_interrupts_masked'
          Keep interrupts masked for the whole function.  Without this
          attribute, GCC tries to reenable interrupts for as much of
          the function as it can.

    `use_debug_exception_return'
          Return using the `deret' instruction.  Interrupt handlers
          that don't have this attribute return using `eret' instead.

     You can use any combination of these attributes, as shown below:
          void __attribute__ ((interrupt)) v0 ();
          void __attribute__ ((interrupt, use_shadow_register_set)) v1 ();
          void __attribute__ ((interrupt, keep_interrupts_masked)) v2 ();
          void __attribute__ ((interrupt, use_debug_exception_return)) v3 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked)) v4 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               use_debug_exception_return)) v5 ();
          void __attribute__ ((interrupt, keep_interrupts_masked,
                               use_debug_exception_return)) v6 ();
          void __attribute__ ((interrupt, use_shadow_register_set,
                               keep_interrupts_masked,
                               use_debug_exception_return)) v7 ();

     On NDS32 target, this attribute is to indicate that the specified
     function is an interrupt handler.  The compiler will generate
     corresponding sections for use in an interrupt handler.  You can
     use the following attributes to modify the behavior:
    `nested'
          This interrupt service routine is interruptible.

    `not_nested'
          This interrupt service routine is not interruptible.

    `nested_ready'
          This interrupt service routine is interruptible after
          `PSW.GIE' (global interrupt enable) is set.  This allows
          interrupt service routine to finish some short critical code
          before enabling interrupts.

    `save_all'
          The system will help save all registers into stack before
          entering interrupt handler.

    `partial_save'
          The system will help save caller registers into stack before
          entering interrupt handler.

     On RL78, use `brk_interrupt' instead of `interrupt' for handlers
     intended to be used with the `BRK' opcode (i.e. those that must
     end with `RETB' instead of `RETI').

     On RX targets, you may specify one or more vector numbers as
     arguments to the attribute, as well as naming an alternate table
     name.  Parameters are handled sequentially, so one handler can be
     assigned to multiple entries in multiple tables.  One may also
     pass the magic string `"$default"' which causes the function to be
     used for any unfilled slots in the current table.

     This example shows a simple assignment of a function to one vector
     in the default table (note that preprocessor macros may be used for
     chip-specific symbolic vector names):
          void __attribute__ ((interrupt (5))) txd1_handler ();

     This example assigns a function to two slots in the default table
     (using preprocessor macros defined elsewhere) and makes it the
     default for the `dct' table:
          void __attribute__ ((interrupt (RXD1_VECT,RXD2_VECT,"dct","$default")))
          	txd1_handler ();

`interrupt_handler'
     Use this attribute on the Blackfin, m68k, H8/300, H8/300H, H8S,
     and SH to indicate that the specified function is an interrupt
     handler.  The compiler generates function entry and exit sequences
     suitable for use in an interrupt handler when this attribute is
     present.

`interrupt_thread'
     Use this attribute on fido, a subarchitecture of the m68k, to
     indicate that the specified function is an interrupt handler that
     is designed to run as a thread.  The compiler omits generate
     prologue/epilogue sequences and replaces the return instruction
     with a `sleep' instruction.  This attribute is available only on
     fido.

`isr'
     Use this attribute on ARM to write Interrupt Service Routines.
     This is an alias to the `interrupt' attribute above.

`kspisusp'
     When used together with `interrupt_handler', `exception_handler'
     or `nmi_handler', code is generated to load the stack pointer from
     the USP register in the function prologue.

`l1_text'
     This attribute specifies a function to be placed into L1
     Instruction SRAM. The function is put into a specific section
     named `.l1.text'.  With `-mfdpic', function calls with a such
     function as the callee or caller uses inlined PLT.

`l2'
     On the Blackfin, this attribute specifies a function to be placed
     into L2 SRAM. The function is put into a specific section named
     `.l1.text'. With `-mfdpic', callers of such functions use an
     inlined PLT.

`leaf'
     Calls to external functions with this attribute must return to the
     current compilation unit only by return or by exception handling.
     In particular, leaf functions are not allowed to call callback
     function passed to it from the current compilation unit or
     directly call functions exported by the unit or longjmp into the
     unit.  Leaf function might still call functions from other
     compilation units and thus they are not necessarily leaf in the
     sense that they contain no function calls at all.

     The attribute is intended for library functions to improve
     dataflow analysis.  The compiler takes the hint that any data not
     escaping the current compilation unit can not be used or modified
     by the leaf function.  For example, the `sin' function is a leaf
     function, but `qsort' is not.

     Note that leaf functions might invoke signals and signal handlers
     might be defined in the current compilation unit and use static
     variables.  The only compliant way to write such a signal handler
     is to declare such variables `volatile'.

     The attribute has no effect on functions defined within the
     current compilation unit.  This is to allow easy merging of
     multiple compilation units into one, for example, by using the
     link-time optimization.  For this reason the attribute is not
     allowed on types to annotate indirect calls.

`long_call/medium_call/short_call'
     These attributes specify how a particular function is called on
     ARC, ARM and Epiphany - with `medium_call' being specific to ARC.
     These attributes override the `-mlong-calls' (*note ARM Options::)
     command-line switch and `#pragma long_calls' settings.  For ARM,
     the `long_call' attribute indicates that the function might be far
     away from the call site and require a different (more expensive)
     calling sequence.   The `short_call' attribute always places the
     offset to the function from the call site into the `BL'
     instruction directly.

`longcall/shortcall'
     On the Blackfin, RS/6000 and PowerPC, the `longcall' attribute
     indicates that the function might be far away from the call site
     and require a different (more expensive) calling sequence.  The
     `shortcall' attribute indicates that the function is always close
     enough for the shorter calling sequence to be used.  These
     attributes override both the `-mlongcall' switch and, on the
     RS/6000 and PowerPC, the `#pragma longcall' setting.

     *Note RS/6000 and PowerPC Options::, for more information on
     whether long calls are necessary.

`long_call/near/far'
     These attributes specify how a particular function is called on
     MIPS.  The attributes override the `-mlong-calls' (*note MIPS
     Options::) command-line switch.  The `long_call' and `far'
     attributes are synonyms, and cause the compiler to always call the
     function by first loading its address into a register, and then
     using the contents of that register.  The `near' attribute has the
     opposite effect; it specifies that non-PIC calls should be made
     using the more efficient `jal' instruction.

`malloc'
     This tells the compiler that a function is `malloc'-like, i.e.,
     that the pointer P returned by the function cannot alias any other
     pointer valid when the function returns, and moreover no pointers
     to valid objects occur in any storage addressed by P.

     Using this attribute can improve optimization.  Functions like
     `malloc' and `calloc' have this property because they return a
     pointer to uninitialized or zeroed-out storage.  However, functions
     like `realloc' do not have this property, as they can return a
     pointer to storage containing pointers.

`mips16/nomips16'
     On MIPS targets, you can use the `mips16' and `nomips16' function
     attributes to locally select or turn off MIPS16 code generation.
     A function with the `mips16' attribute is emitted as MIPS16 code,
     while MIPS16 code generation is disabled for functions with the
     `nomips16' attribute.  These attributes override the `-mips16' and
     `-mno-mips16' options on the command line (*note MIPS Options::).

     When compiling files containing mixed MIPS16 and non-MIPS16 code,
     the preprocessor symbol `__mips16' reflects the setting on the
     command line, not that within individual functions.  Mixed MIPS16
     and non-MIPS16 code may interact badly with some GCC extensions
     such as `__builtin_apply' (*note Constructing Calls::).

`micromips/nomicromips'
     On MIPS targets, you can use the `micromips' and `nomicromips'
     function attributes to locally select or turn off microMIPS code
     generation.  A function with the `micromips' attribute is emitted
     as microMIPS code, while microMIPS code generation is disabled for
     functions with the `nomicromips' attribute.  These attributes
     override the `-mmicromips' and `-mno-micromips' options on the
     command line (*note MIPS Options::).

     When compiling files containing mixed microMIPS and non-microMIPS
     code, the preprocessor symbol `__mips_micromips' reflects the
     setting on the command line, not that within individual functions.
     Mixed microMIPS and non-microMIPS code may interact badly with
     some GCC extensions such as `__builtin_apply' (*note Constructing
     Calls::).

`model (MODEL-NAME)'
     On the M32R/D, use this attribute to set the addressability of an
     object, and of the code generated for a function.  The identifier
     MODEL-NAME is one of `small', `medium', or `large', representing
     each of the code models.

     Small model objects live in the lower 16MB of memory (so that their
     addresses can be loaded with the `ld24' instruction), and are
     callable with the `bl' instruction.

     Medium model objects may live anywhere in the 32-bit address space
     (the compiler generates `seth/add3' instructions to load their
     addresses), and are callable with the `bl' instruction.

     Large model objects may live anywhere in the 32-bit address space
     (the compiler generates `seth/add3' instructions to load their
     addresses), and may not be reachable with the `bl' instruction
     (the compiler generates the much slower `seth/add3/jl' instruction
     sequence).

     On IA-64, use this attribute to set the addressability of an
     object.  At present, the only supported identifier for MODEL-NAME
     is `small', indicating addressability via "small" (22-bit)
     addresses (so that their addresses can be loaded with the `addl'
     instruction).  Caveat: such addressing is by definition not
     position independent and hence this attribute must not be used for
     objects defined by shared libraries.

`ms_abi/sysv_abi'
     On 32-bit and 64-bit x86 targets, you can use an ABI attribute to
     indicate which calling convention should be used for a function.
     The `ms_abi' attribute tells the compiler to use the Microsoft ABI,
     while the `sysv_abi' attribute tells the compiler to use the ABI
     used on GNU/Linux and other systems.  The default is to use the
     Microsoft ABI when targeting Windows.  On all other systems, the
     default is the x86/AMD ABI.

     Note, the `ms_abi' attribute for Microsoft Windows 64-bit targets
     currently requires the `-maccumulate-outgoing-args' option.

`callee_pop_aggregate_return (NUMBER)'
     On x86-32 targets, you can use this attribute to control how
     aggregates are returned in memory.  If the caller is responsible
     for popping the hidden pointer together with the rest of the
     arguments, specify NUMBER equal to zero.  If callee is responsible
     for popping the hidden pointer, specify NUMBER equal to one.

     The default x86-32 ABI assumes that the callee pops the stack for
     hidden pointer.  However, on x86-32 Microsoft Windows targets, the
     compiler assumes that the caller pops the stack for hidden pointer.

`ms_hook_prologue'
     On 32-bit and 64-bit x86 targets, you can use this function
     attribute to make GCC generate the "hot-patching" function
     prologue used in Win32 API functions in Microsoft Windows XP
     Service Pack 2 and newer.

`hotpatch (HALFWORDS-BEFORE-FUNCTION-LABEL,HALFWORDS-AFTER-FUNCTION-LABEL)'
     On S/390 System z targets, you can use this function attribute to
     make GCC generate a "hot-patching" function prologue.  If the
     `-mhotpatch=' command-line option is used at the same time, the
     `hotpatch' attribute takes precedence.  The first of the two
     arguments specifies the number of halfwords to be added before the
     function label.  A second argument can be used to specify the
     number of halfwords to be added after the function label.  For
     both arguments the maximum allowed value is 1000000.

     If both arguments are zero, hotpatching is disabled.

`naked'
     This attribute is available on the ARM, AVR, MCORE, MSP430, NDS32,
     RL78, RX and SPU ports.  It allows the compiler to construct the
     requisite function declaration, while allowing the body of the
     function to be assembly code. The specified function will not have
     prologue/epilogue sequences generated by the compiler. Only basic
     `asm' statements can safely be included in naked functions (*note
     Basic Asm::). While using extended `asm' or a mixture of basic
     `asm' and C code may appear to work, they cannot be depended upon
     to work reliably and are not supported.

`near'
     On 68HC11 and 68HC12 the `near' attribute causes the compiler to
     use the normal calling convention based on `jsr' and `rts'.  This
     attribute can be used to cancel the effect of the `-mlong-calls'
     option.

     On MeP targets this attribute causes the compiler to assume the
     called function is close enough to use the normal calling
     convention, overriding the `-mtf' command-line option.

`nesting'
     Use this attribute together with `interrupt_handler',
     `exception_handler' or `nmi_handler' to indicate that the function
     entry code should enable nested interrupts or exceptions.

`nmi_handler'
     Use this attribute on the Blackfin to indicate that the specified
     function is an NMI handler.  The compiler generates function entry
     and exit sequences suitable for use in an NMI handler when this
     attribute is present.

`nocompression'
     On MIPS targets, you can use the `nocompression' function attribute
     to locally turn off MIPS16 and microMIPS code generation.  This
     attribute overrides the `-mips16' and `-mmicromips' options on the
     command line (*note MIPS Options::).

`no_instrument_function'
     If `-finstrument-functions' is given, profiling function calls are
     generated at entry and exit of most user-compiled functions.
     Functions with this attribute are not so instrumented.

`no_split_stack'
     If `-fsplit-stack' is given, functions have a small prologue which
     decides whether to split the stack.  Functions with the
     `no_split_stack' attribute do not have that prologue, and thus may
     run with only a small amount of stack space available.

`stack_protect'
     This function attribute make a stack protection of the function if
     flags `fstack-protector' or `fstack-protector-strong' or
     `fstack-protector-explicit' are set.

`noinline'
     This function attribute prevents a function from being considered
     for inlining.  If the function does not have side-effects, there
     are optimizations other than inlining that cause function calls to
     be optimized away, although the function call is live.  To keep
     such calls from being optimized away, put
          asm ("");

     (*note Extended Asm::) in the called function, to serve as a
     special side-effect.

`noclone'
     This function attribute prevents a function from being considered
     for cloning--a mechanism that produces specialized copies of
     functions and which is (currently) performed by interprocedural
     constant propagation.

`no_icf'
     This function attribute prevents a functions from being merged
     with another semantically equivalent function.

`nonnull (ARG-INDEX, ...)'
     The `nonnull' attribute specifies that some function parameters
     should be non-null pointers.  For instance, the declaration:

          extern void *
          my_memcpy (void *dest, const void *src, size_t len)
                  __attribute__((nonnull (1, 2)));

     causes the compiler to check that, in calls to `my_memcpy',
     arguments DEST and SRC are non-null.  If the compiler determines
     that a null pointer is passed in an argument slot marked as
     non-null, and the `-Wnonnull' option is enabled, a warning is
     issued.  The compiler may also choose to make optimizations based
     on the knowledge that certain function arguments will never be
     null.

     If no argument index list is given to the `nonnull' attribute, all
     pointer arguments are marked as non-null.  To illustrate, the
     following declaration is equivalent to the previous example:

          extern void *
          my_memcpy (void *dest, const void *src, size_t len)
                  __attribute__((nonnull));

`no_reorder'
     Do not reorder functions or variables marked `no_reorder' against
     each other or top level assembler statements the executable.  The
     actual order in the program will depend on the linker command
     line. Static variables marked like this are also not removed.
     This has a similar effect as the `-fno-toplevel-reorder' option,
     but only applies to the marked symbols.

`returns_nonnull'
     The `returns_nonnull' attribute specifies that the function return
     value should be a non-null pointer.  For instance, the declaration:

          extern void *
          mymalloc (size_t len) __attribute__((returns_nonnull));

     lets the compiler optimize callers based on the knowledge that the
     return value will never be null.

`noreturn'
     A few standard library functions, such as `abort' and `exit',
     cannot return.  GCC knows this automatically.  Some programs define
     their own functions that never return.  You can declare them
     `noreturn' to tell the compiler this fact.  For example,

          void fatal () __attribute__ ((noreturn));

          void
          fatal (/* ... */)
          {
            /* ... */ /* Print error message. */ /* ... */
            exit (1);
          }

     The `noreturn' keyword tells the compiler to assume that `fatal'
     cannot return.  It can then optimize without regard to what would
     happen if `fatal' ever did return.  This makes slightly better
     code.  More importantly, it helps avoid spurious warnings of
     uninitialized variables.

     The `noreturn' keyword does not affect the exceptional path when
     that applies: a `noreturn'-marked function may still return to the
     caller by throwing an exception or calling `longjmp'.

     Do not assume that registers saved by the calling function are
     restored before calling the `noreturn' function.

     It does not make sense for a `noreturn' function to have a return
     type other than `void'.

`nothrow'
     The `nothrow' attribute is used to inform the compiler that a
     function cannot throw an exception.  For example, most functions in
     the standard C library can be guaranteed not to throw an exception
     with the notable exceptions of `qsort' and `bsearch' that take
     function pointer arguments.

`nosave_low_regs'
     Use this attribute on SH targets to indicate that an
     `interrupt_handler' function should not save and restore registers
     R0..R7.  This can be used on SH3* and SH4* targets that have a
     second R0..R7 register bank for non-reentrant interrupt handlers.

`optimize'
     The `optimize' attribute is used to specify that a function is to
     be compiled with different optimization options than specified on
     the command line.  Arguments can either be numbers or strings.
     Numbers are assumed to be an optimization level.  Strings that
     begin with `O' are assumed to be an optimization option, while
     other options are assumed to be used with a `-f' prefix.  You can
     also use the `#pragma GCC optimize' pragma to set the optimization
     options that affect more than one function.  *Note Function
     Specific Option Pragmas::, for details about the `#pragma GCC
     optimize' pragma.

     This can be used for instance to have frequently-executed functions
     compiled with more aggressive optimization options that produce
     faster and larger code, while other functions can be compiled with
     less aggressive options.

`OS_main/OS_task'
     On AVR, functions with the `OS_main' or `OS_task' attribute do not
     save/restore any call-saved register in their prologue/epilogue.

     The `OS_main' attribute can be used when there _is guarantee_ that
     interrupts are disabled at the time when the function is entered.
     This saves resources when the stack pointer has to be changed to
     set up a frame for local variables.

     The `OS_task' attribute can be used when there is _no guarantee_
     that interrupts are disabled at that time when the function is
     entered like for, e.g. task functions in a multi-threading
     operating system. In that case, changing the stack pointer
     register is guarded by save/clear/restore of the global interrupt
     enable flag.

     The differences to the `naked' function attribute are:
        * `naked' functions do not have a return instruction whereas
          `OS_main' and `OS_task' functions have a `RET' or `RETI'
          return instruction.

        * `naked' functions do not set up a frame for local variables
          or a frame pointer whereas `OS_main' and `OS_task' do this as
          needed.

`pcs'
     The `pcs' attribute can be used to control the calling convention
     used for a function on ARM.  The attribute takes an argument that
     specifies the calling convention to use.

     When compiling using the AAPCS ABI (or a variant of it) then valid
     values for the argument are `"aapcs"' and `"aapcs-vfp"'.  In order
     to use a variant other than `"aapcs"' then the compiler must be
     permitted to use the appropriate co-processor registers (i.e., the
     VFP registers must be available in order to use `"aapcs-vfp"').
     For example,

          /* Argument passed in r0, and result returned in r0+r1.  */
          double f2d (float) __attribute__((pcs("aapcs")));

     Variadic functions always use the `"aapcs"' calling convention and
     the compiler rejects attempts to specify an alternative.

`pure'
     Many functions have no effects except the return value and their
     return value depends only on the parameters and/or global
     variables.  Such a function can be subject to common subexpression
     elimination and loop optimization just as an arithmetic operator
     would be.  These functions should be declared with the attribute
     `pure'.  For example,

          int square (int) __attribute__ ((pure));

     says that the hypothetical function `square' is safe to call fewer
     times than the program says.

     Some of common examples of pure functions are `strlen' or `memcmp'.
     Interesting non-pure functions are functions with infinite loops
     or those depending on volatile memory or other system resource,
     that may change between two consecutive calls (such as `feof' in a
     multithreading environment).

`hot'
     The `hot' attribute on a function is used to inform the compiler
     that the function is a hot spot of the compiled program.  The
     function is optimized more aggressively and on many targets it is
     placed into a special subsection of the text section so all hot
     functions appear close together, improving locality.

     When profile feedback is available, via `-fprofile-use', hot
     functions are automatically detected and this attribute is ignored.

`cold'
     The `cold' attribute on functions is used to inform the compiler
     that the function is unlikely to be executed.  The function is
     optimized for size rather than speed and on many targets it is
     placed into a special subsection of the text section so all cold
     functions appear close together, improving code locality of
     non-cold parts of program.  The paths leading to calls of cold
     functions within code are marked as unlikely by the branch
     prediction mechanism.  It is thus useful to mark functions used to
     handle unlikely conditions, such as `perror', as cold to improve
     optimization of hot functions that do call marked functions in
     rare occasions.

     When profile feedback is available, via `-fprofile-use', cold
     functions are automatically detected and this attribute is ignored.

`no_sanitize_address'
`no_address_safety_analysis'
     The `no_sanitize_address' attribute on functions is used to inform
     the compiler that it should not instrument memory accesses in the
     function when compiling with the `-fsanitize=address' option.  The
     `no_address_safety_analysis' is a deprecated alias of the
     `no_sanitize_address' attribute, new code should use
     `no_sanitize_address'.

`no_sanitize_thread'
     The `no_sanitize_thread' attribute on functions is used to inform
     the compiler that it should not instrument memory accesses in the
     function when compiling with the `-fsanitize=thread' option.

`no_sanitize_undefined'
     The `no_sanitize_undefined' attribute on functions is used to
     inform the compiler that it should not check for undefined behavior
     in the function when compiling with the `-fsanitize=undefined'
     option.

`bnd_legacy'
     The `bnd_legacy' attribute on functions is used to inform compiler
     that function should not be instrumented when compiled with
     `-fcheck-pointer-bounds' option.

`bnd_instrument'
     The `bnd_instrument' attribute on functions is used to inform
     compiler that function should be instrumented when compiled with
     `-fchkp-instrument-marked-only' option.

`regparm (NUMBER)'
     On x86-32 targets, the `regparm' attribute causes the compiler to
     pass arguments number one to NUMBER if they are of integral type
     in registers EAX, EDX, and ECX instead of on the stack.  Functions
     that take a variable number of arguments continue to be passed all
     of their arguments on the stack.

     Beware that on some ELF systems this attribute is unsuitable for
     global functions in shared libraries with lazy binding (which is
     the default).  Lazy binding sends the first call via resolving
     code in the loader, which might assume EAX, EDX and ECX can be
     clobbered, as per the standard calling conventions.  Solaris 8 is
     affected by this.  Systems with the GNU C Library version 2.1 or
     higher and FreeBSD are believed to be safe since the loaders there
     save EAX, EDX and ECX.  (Lazy binding can be disabled with the
     linker or the loader if desired, to avoid the problem.)

`reset'
     Use this attribute on the NDS32 target to indicate that the
     specified function is a reset handler.  The compiler will generate
     corresponding sections for use in a reset handler.  You can use
     the following attributes to provide extra exception handling:
    `nmi'
          Provide a user-defined function to handle NMI exception.

    `warm'
          Provide a user-defined function to handle warm reset
          exception.

`sseregparm'
     On x86-32 targets with SSE support, the `sseregparm' attribute
     causes the compiler to pass up to 3 floating-point arguments in
     SSE registers instead of on the stack.  Functions that take a
     variable number of arguments continue to pass all of their
     floating-point arguments on the stack.

`force_align_arg_pointer'
     On x86 targets, the `force_align_arg_pointer' attribute may be
     applied to individual function definitions, generating an alternate
     prologue and epilogue that realigns the run-time stack if
     necessary.  This supports mixing legacy codes that run with a
     4-byte aligned stack with modern codes that keep a 16-byte stack
     for SSE compatibility.

`renesas'
     On SH targets this attribute specifies that the function or struct
     follows the Renesas ABI.

`resbank'
     On the SH2A target, this attribute enables the high-speed register
     saving and restoration using a register bank for
     `interrupt_handler' routines.  Saving to the bank is performed
     automatically after the CPU accepts an interrupt that uses a
     register bank.

     The nineteen 32-bit registers comprising general register R0 to
     R14, control register GBR, and system registers MACH, MACL, and PR
     and the vector table address offset are saved into a register
     bank.  Register banks are stacked in first-in last-out (FILO)
     sequence.  Restoration from the bank is executed by issuing a
     RESBANK instruction.

`returns_twice'
     The `returns_twice' attribute tells the compiler that a function
     may return more than one time.  The compiler ensures that all
     registers are dead before calling such a function and emits a
     warning about the variables that may be clobbered after the second
     return from the function.  Examples of such functions are `setjmp'
     and `vfork'.  The `longjmp'-like counterpart of such function, if
     any, might need to be marked with the `noreturn' attribute.

`saveall'
     Use this attribute on the Blackfin, H8/300, H8/300H, and H8S to
     indicate that all registers except the stack pointer should be
     saved in the prologue regardless of whether they are used or not.

`save_volatiles'
     Use this attribute on the MicroBlaze to indicate that the function
     is an interrupt handler.  All volatile registers (in addition to
     non-volatile registers) are saved in the function prologue.  If
     the function is a leaf function, only volatiles used by the
     function are saved.  A normal function return is generated instead
     of a return from interrupt.

`break_handler'
     Use this attribute on the MicroBlaze ports to indicate that the
     specified function is an break handler.  The compiler generates
     function entry and exit sequences suitable for use in an break
     handler when this attribute is present. The return from
     `break_handler' is done through the `rtbd' instead of `rtsd'.

          void f () __attribute__ ((break_handler));

`section ("SECTION-NAME")'
     Normally, the compiler places the code it generates in the `text'
     section.  Sometimes, however, you need additional sections, or you
     need certain particular functions to appear in special sections.
     The `section' attribute specifies that a function lives in a
     particular section.  For example, the declaration:

          extern void foobar (void) __attribute__ ((section ("bar")));

     puts the function `foobar' in the `bar' section.

     Some file formats do not support arbitrary sections so the
     `section' attribute is not available on all platforms.  If you
     need to map the entire contents of a module to a particular
     section, consider using the facilities of the linker instead.

`sentinel'
     This function attribute ensures that a parameter in a function
     call is an explicit `NULL'.  The attribute is only valid on
     variadic functions.  By default, the sentinel is located at
     position zero, the last parameter of the function call.  If an
     optional integer position argument P is supplied to the attribute,
     the sentinel must be located at position P counting backwards from
     the end of the argument list.

          __attribute__ ((sentinel))
          is equivalent to
          __attribute__ ((sentinel(0)))

     The attribute is automatically set with a position of 0 for the
     built-in functions `execl' and `execlp'.  The built-in function
     `execle' has the attribute set with a position of 1.

     A valid `NULL' in this context is defined as zero with any pointer
     type.  If your system defines the `NULL' macro with an integer type
     then you need to add an explicit cast.  GCC replaces `stddef.h'
     with a copy that redefines NULL appropriately.

     The warnings for missing or incorrect sentinels are enabled with
     `-Wformat'.

`short_call'
     See `long_call/short_call'.

`shortcall'
     See `longcall/shortcall'.

`signal'
     Use this attribute on the AVR to indicate that the specified
     function is an interrupt handler.  The compiler generates function
     entry and exit sequences suitable for use in an interrupt handler
     when this attribute is present.

     See also the `interrupt' function attribute.

     The AVR hardware globally disables interrupts when an interrupt is
     executed.  Interrupt handler functions defined with the `signal'
     attribute do not re-enable interrupts.  It is save to enable
     interrupts in a `signal' handler.  This "save" only applies to the
     code generated by the compiler and not to the IRQ layout of the
     application which is responsibility of the application.

     If both `signal' and `interrupt' are specified for the same
     function, `signal' is silently ignored.

`sp_switch'
     Use this attribute on the SH to indicate an `interrupt_handler'
     function should switch to an alternate stack.  It expects a string
     argument that names a global variable holding the address of the
     alternate stack.

          void *alt_stack;
          void f () __attribute__ ((interrupt_handler,
                                    sp_switch ("alt_stack")));

`stdcall'
     On x86-32 targets, the `stdcall' attribute causes the compiler to
     assume that the called function pops off the stack space used to
     pass arguments, unless it takes a variable number of arguments.

`syscall_linkage'
     This attribute is used to modify the IA-64 calling convention by
     marking all input registers as live at all function exits.  This
     makes it possible to restart a system call after an interrupt
     without having to save/restore the input registers.  This also
     prevents kernel data from leaking into application code.

`target'
     The `target' attribute is used to specify that a function is to be
     compiled with different target options than specified on the
     command line.  This can be used for instance to have functions
     compiled with a different ISA (instruction set architecture) than
     the default.  You can also use the `#pragma GCC target' pragma to
     set more than one function to be compiled with specific target
     options.  *Note Function Specific Option Pragmas::, for details
     about the `#pragma GCC target' pragma.

     For instance on an x86, you could compile one function with
     `target("sse4.1,arch=core2")' and another with
     `target("sse4a,arch=amdfam10")'.  This is equivalent to compiling
     the first function with `-msse4.1' and `-march=core2' options, and
     the second function with `-msse4a' and `-march=amdfam10' options.
     It is up to the user to make sure that a function is only invoked
     on a machine that supports the particular ISA it is compiled for
     (for example by using `cpuid' on x86 to determine what feature
     bits and architecture family are used).

          int core2_func (void) __attribute__ ((__target__ ("arch=core2")));
          int sse3_func (void) __attribute__ ((__target__ ("sse3")));

     You can either use multiple strings to specify multiple options,
     or separate the options with a comma (`,').

     The `target' attribute is presently implemented for x86, PowerPC,
     and Nios II targets only.  The options supported are specific to
     each target.

     On the x86, the following options are allowed:

    `abm'
    `no-abm'
          Enable/disable the generation of the advanced bit
          instructions.

    `aes'
    `no-aes'
          Enable/disable the generation of the AES instructions.

    `default'
          *Note Function Multiversioning::, where it is used to specify
          the default function version.

    `mmx'
    `no-mmx'
          Enable/disable the generation of the MMX instructions.

    `pclmul'
    `no-pclmul'
          Enable/disable the generation of the PCLMUL instructions.

    `popcnt'
    `no-popcnt'
          Enable/disable the generation of the POPCNT instruction.

    `sse'
    `no-sse'
          Enable/disable the generation of the SSE instructions.

    `sse2'
    `no-sse2'
          Enable/disable the generation of the SSE2 instructions.

    `sse3'
    `no-sse3'
          Enable/disable the generation of the SSE3 instructions.

    `sse4'
    `no-sse4'
          Enable/disable the generation of the SSE4 instructions (both
          SSE4.1 and SSE4.2).

    `sse4.1'
    `no-sse4.1'
          Enable/disable the generation of the sse4.1 instructions.

    `sse4.2'
    `no-sse4.2'
          Enable/disable the generation of the sse4.2 instructions.

    `sse4a'
    `no-sse4a'
          Enable/disable the generation of the SSE4A instructions.

    `fma4'
    `no-fma4'
          Enable/disable the generation of the FMA4 instructions.

    `xop'
    `no-xop'
          Enable/disable the generation of the XOP instructions.

    `lwp'
    `no-lwp'
          Enable/disable the generation of the LWP instructions.

    `ssse3'
    `no-ssse3'
          Enable/disable the generation of the SSSE3 instructions.

    `cld'
    `no-cld'
          Enable/disable the generation of the CLD before string moves.

    `fancy-math-387'
    `no-fancy-math-387'
          Enable/disable the generation of the `sin', `cos', and `sqrt'
          instructions on the 387 floating-point unit.

    `fused-madd'
    `no-fused-madd'
          Enable/disable the generation of the fused multiply/add
          instructions.

    `ieee-fp'
    `no-ieee-fp'
          Enable/disable the generation of floating point that depends
          on IEEE arithmetic.

    `inline-all-stringops'
    `no-inline-all-stringops'
          Enable/disable inlining of string operations.

    `inline-stringops-dynamically'
    `no-inline-stringops-dynamically'
          Enable/disable the generation of the inline code to do small
          string operations and calling the library routines for large
          operations.

    `align-stringops'
    `no-align-stringops'
          Do/do not align destination of inlined string operations.

    `recip'
    `no-recip'
          Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and
          RSQRTPS instructions followed an additional Newton-Raphson
          step instead of doing a floating-point division.

    `arch=ARCH'
          Specify the architecture to generate code for in compiling
          the function.

    `tune=TUNE'
          Specify the architecture to tune for in compiling the
          function.

    `fpmath=FPMATH'
          Specify which floating-point unit to use.  The
          `target("fpmath=sse,387")' option must be specified as
          `target("fpmath=sse+387")' because the comma would separate
          different options.

     On the PowerPC, the following options are allowed:

    `altivec'
    `no-altivec'
          Generate code that uses (does not use) AltiVec instructions.
          In 32-bit code, you cannot enable AltiVec instructions unless
          `-mabi=altivec' is used on the command line.

    `cmpb'
    `no-cmpb'
          Generate code that uses (does not use) the compare bytes
          instruction implemented on the POWER6 processor and other
          processors that support the PowerPC V2.05 architecture.

    `dlmzb'
    `no-dlmzb'
          Generate code that uses (does not use) the string-search
          `dlmzb' instruction on the IBM 405, 440, 464 and 476
          processors.  This instruction is generated by default when
          targeting those processors.

    `fprnd'
    `no-fprnd'
          Generate code that uses (does not use) the FP round to integer
          instructions implemented on the POWER5+ processor and other
          processors that support the PowerPC V2.03 architecture.

    `hard-dfp'
    `no-hard-dfp'
          Generate code that uses (does not use) the decimal
          floating-point instructions implemented on some POWER
          processors.

    `isel'
    `no-isel'
          Generate code that uses (does not use) ISEL instruction.

    `mfcrf'
    `no-mfcrf'
          Generate code that uses (does not use) the move from condition
          register field instruction implemented on the POWER4
          processor and other processors that support the PowerPC V2.01
          architecture.

    `mfpgpr'
    `no-mfpgpr'
          Generate code that uses (does not use) the FP move to/from
          general purpose register instructions implemented on the
          POWER6X processor and other processors that support the
          extended PowerPC V2.05 architecture.

    `mulhw'
    `no-mulhw'
          Generate code that uses (does not use) the half-word multiply
          and multiply-accumulate instructions on the IBM 405, 440, 464
          and 476 processors.  These instructions are generated by
          default when targeting those processors.

    `multiple'
    `no-multiple'
          Generate code that uses (does not use) the load multiple word
          instructions and the store multiple word instructions.

    `update'
    `no-update'
          Generate code that uses (does not use) the load or store
          instructions that update the base register to the address of
          the calculated memory location.

    `popcntb'
    `no-popcntb'
          Generate code that uses (does not use) the popcount and
          double-precision FP reciprocal estimate instruction
          implemented on the POWER5 processor and other processors that
          support the PowerPC V2.02 architecture.

    `popcntd'
    `no-popcntd'
          Generate code that uses (does not use) the popcount
          instruction implemented on the POWER7 processor and other
          processors that support the PowerPC V2.06 architecture.

    `powerpc-gfxopt'
    `no-powerpc-gfxopt'
          Generate code that uses (does not use) the optional PowerPC
          architecture instructions in the Graphics group, including
          floating-point select.

    `powerpc-gpopt'
    `no-powerpc-gpopt'
          Generate code that uses (does not use) the optional PowerPC
          architecture instructions in the General Purpose group,
          including floating-point square root.

    `recip-precision'
    `no-recip-precision'
          Assume (do not assume) that the reciprocal estimate
          instructions provide higher-precision estimates than is
          mandated by the powerpc ABI.

    `string'
    `no-string'
          Generate code that uses (does not use) the load string
          instructions and the store string word instructions to save
          multiple registers and do small block moves.

    `vsx'
    `no-vsx'
          Generate code that uses (does not use) vector/scalar (VSX)
          instructions, and also enable the use of built-in functions
          that allow more direct access to the VSX instruction set.  In
          32-bit code, you cannot enable VSX or AltiVec instructions
          unless `-mabi=altivec' is used on the command line.

    `friz'
    `no-friz'
          Generate (do not generate) the `friz' instruction when the
          `-funsafe-math-optimizations' option is used to optimize
          rounding a floating-point value to 64-bit integer and back to
          floating point.  The `friz' instruction does not return the
          same value if the floating-point number is too large to fit
          in an integer.

    `avoid-indexed-addresses'
    `no-avoid-indexed-addresses'
          Generate code that tries to avoid (not avoid) the use of
          indexed load or store instructions.

    `paired'
    `no-paired'
          Generate code that uses (does not use) the generation of
          PAIRED simd instructions.

    `longcall'
    `no-longcall'
          Generate code that assumes (does not assume) that all calls
          are far away so that a longer more expensive calling sequence
          is required.

    `cpu=CPU'
          Specify the architecture to generate code for when compiling
          the function.  If you select the `target("cpu=power7")'
          attribute when generating 32-bit code, VSX and AltiVec
          instructions are not generated unless you use the
          `-mabi=altivec' option on the command line.

    `tune=TUNE'
          Specify the architecture to tune for when compiling the
          function.  If you do not specify the `target("tune=TUNE")'
          attribute and you do specify the `target("cpu=CPU")'
          attribute, compilation tunes for the CPU architecture, and
          not the default tuning specified on the command line.

     When compiling for Nios II, the following options are allowed:

    `custom-INSN=N'
    `no-custom-INSN'
          Each `custom-INSN=N' attribute locally enables use of a
          custom instruction with encoding N when generating code that
          uses INSN.  Similarly, `no-custom-INSN' locally inhibits use
          of the custom instruction INSN.  These target attributes
          correspond to the `-mcustom-INSN=N' and `-mno-custom-INSN'
          command-line options, and support the same set of INSN
          keywords.

    `custom-fpu-cfg=NAME'
          This attribute corresponds to the `-mcustom-fpu-cfg=NAME'
          command-line option, to select a predefined set of custom
          instructions named NAME.

     On the x86 and PowerPC back ends, the inliner does not inline a
     function that has different target options than the caller, unless
     the callee has a subset of the target options of the caller.  For
     example a function declared with `target("sse3")' can inline a
     function with `target("sse2")', since `-msse3' implies `-msse2'.

`tiny_data'
     Use this attribute on the H8/300H and H8S to indicate that the
     specified variable should be placed into the tiny data section.
     The compiler generates more efficient code for loads and stores on
     data in the tiny data section.  Note the tiny data area is limited
     to slightly under 32KB of data.

`trap_exit'
     Use this attribute on the SH for an `interrupt_handler' to return
     using `trapa' instead of `rte'.  This attribute expects an integer
     argument specifying the trap number to be used.

`trapa_handler'
     On SH targets this function attribute is similar to
     `interrupt_handler' but it does not save and restore all registers.

`unused'
     This attribute, attached to a function, means that the function is
     meant to be possibly unused.  GCC does not produce a warning for
     this function.

`used'
     This attribute, attached to a function, means that code must be
     emitted for the function even if it appears that the function is
     not referenced.  This is useful, for example, when the function is
     referenced only in inline assembly.

     When applied to a member function of a C++ class template, the
     attribute also means that the function is instantiated if the
     class itself is instantiated.

`vector'
     This RX attribute is similar to the `interrupt' attribute,
     including its parameters, but does not make the function an
     interrupt-handler type function (i.e. it retains the normal C
     function calling ABI).  See the `interrupt' attribute for a
     description of its arguments.

`version_id'
     This IA-64 HP-UX attribute, attached to a global variable or
     function, renames a symbol to contain a version string, thus
     allowing for function level versioning.  HP-UX system header files
     may use function level versioning for some system calls.

          extern int foo () __attribute__((version_id ("20040821")));

     Calls to FOO are mapped to calls to FOO{20040821}.

`visibility ("VISIBILITY_TYPE")'
     This attribute affects the linkage of the declaration to which it
     is attached.  There are four supported VISIBILITY_TYPE values:
     default, hidden, protected or internal visibility.

          void __attribute__ ((visibility ("protected")))
          f () { /* Do something. */; }
          int i __attribute__ ((visibility ("hidden")));

     The possible values of VISIBILITY_TYPE correspond to the
     visibility settings in the ELF gABI.

    "default"
          Default visibility is the normal case for the object file
          format.  This value is available for the visibility attribute
          to override other options that may change the assumed
          visibility of entities.

          On ELF, default visibility means that the declaration is
          visible to other modules and, in shared libraries, means that
          the declared entity may be overridden.

          On Darwin, default visibility means that the declaration is
          visible to other modules.

          Default visibility corresponds to "external linkage" in the
          language.

    "hidden"
          Hidden visibility indicates that the entity declared has a new
          form of linkage, which we call "hidden linkage".  Two
          declarations of an object with hidden linkage refer to the
          same object if they are in the same shared object.

    "internal"
          Internal visibility is like hidden visibility, but with
          additional processor specific semantics.  Unless otherwise
          specified by the psABI, GCC defines internal visibility to
          mean that a function is _never_ called from another module.
          Compare this with hidden functions which, while they cannot
          be referenced directly by other modules, can be referenced
          indirectly via function pointers.  By indicating that a
          function cannot be called from outside the module, GCC may
          for instance omit the load of a PIC register since it is known
          that the calling function loaded the correct value.

    "protected"
          Protected visibility is like default visibility except that it
          indicates that references within the defining module bind to
          the definition in that module.  That is, the declared entity
          cannot be overridden by another module.


     All visibilities are supported on many, but not all, ELF targets
     (supported when the assembler supports the `.visibility'
     pseudo-op).  Default visibility is supported everywhere.  Hidden
     visibility is supported on Darwin targets.

     The visibility attribute should be applied only to declarations
     that would otherwise have external linkage.  The attribute should
     be applied consistently, so that the same entity should not be
     declared with different settings of the attribute.

     In C++, the visibility attribute applies to types as well as
     functions and objects, because in C++ types have linkage.  A class
     must not have greater visibility than its non-static data member
     types and bases, and class members default to the visibility of
     their class.  Also, a declaration without explicit visibility is
     limited to the visibility of its type.

     In C++, you can mark member functions and static member variables
     of a class with the visibility attribute.  This is useful if you
     know a particular method or static member variable should only be
     used from one shared object; then you can mark it hidden while the
     rest of the class has default visibility.  Care must be taken to
     avoid breaking the One Definition Rule; for example, it is usually
     not useful to mark an inline method as hidden without marking the
     whole class as hidden.

     A C++ namespace declaration can also have the visibility attribute.

          namespace nspace1 __attribute__ ((visibility ("protected")))
          { /* Do something. */; }

     This attribute applies only to the particular namespace body, not
     to other definitions of the same namespace; it is equivalent to
     using `#pragma GCC visibility' before and after the namespace
     definition (*note Visibility Pragmas::).

     In C++, if a template argument has limited visibility, this
     restriction is implicitly propagated to the template instantiation.
     Otherwise, template instantiations and specializations default to
     the visibility of their template.

     If both the template and enclosing class have explicit visibility,
     the visibility from the template is used.

`vliw'
     On MeP, the `vliw' attribute tells the compiler to emit
     instructions in VLIW mode instead of core mode.  Note that this
     attribute is not allowed unless a VLIW coprocessor has been
     configured and enabled through command-line options.

`warn_unused_result'
     The `warn_unused_result' attribute causes a warning to be emitted
     if a caller of the function with this attribute does not use its
     return value.  This is useful for functions where not checking the
     result is either a security problem or always a bug, such as
     `realloc'.

          int fn () __attribute__ ((warn_unused_result));
          int foo ()
          {
            if (fn () < 0) return -1;
            fn ();
            return 0;
          }

     results in warning on line 5.

`weak'
     The `weak' attribute causes the declaration to be emitted as a weak
     symbol rather than a global.  This is primarily useful in defining
     library functions that can be overridden in user code, though it
     can also be used with non-function declarations.  Weak symbols are
     supported for ELF targets, and also for a.out targets when using
     the GNU assembler and linker.

`weakref'
`weakref ("TARGET")'
     The `weakref' attribute marks a declaration as a weak reference.
     Without arguments, it should be accompanied by an `alias' attribute
     naming the target symbol.  Optionally, the TARGET may be given as
     an argument to `weakref' itself.  In either case, `weakref'
     implicitly marks the declaration as `weak'.  Without a TARGET,
     given as an argument to `weakref' or to `alias', `weakref' is
     equivalent to `weak'.

          static int x() __attribute__ ((weakref ("y")));
          /* is equivalent to... */
          static int x() __attribute__ ((weak, weakref, alias ("y")));
          /* and to... */
          static int x() __attribute__ ((weakref));
          static int x() __attribute__ ((alias ("y")));

     A weak reference is an alias that does not by itself require a
     definition to be given for the target symbol.  If the target
     symbol is only referenced through weak references, then it becomes
     a `weak' undefined symbol.  If it is directly referenced, however,
     then such strong references prevail, and a definition is required
     for the symbol, not necessarily in the same translation unit.

     The effect is equivalent to moving all references to the alias to a
     separate translation unit, renaming the alias to the aliased
     symbol, declaring it as weak, compiling the two separate
     translation units and performing a reloadable link on them.

     At present, a declaration to which `weakref' is attached can only
     be `static'.


 You can specify multiple attributes in a declaration by separating them
by commas within the double parentheses or by immediately following an
attribute declaration with another attribute declaration.

 Some people object to the `__attribute__' feature, suggesting that ISO
C's `#pragma' should be used instead.  At the time `__attribute__' was
designed, there were two reasons for not doing this.

  1. It is impossible to generate `#pragma' commands from a macro.

  2. There is no telling what the same `#pragma' might mean in another
     compiler.

 These two reasons applied to almost any application that might have
been proposed for `#pragma'.  It was basically a mistake to use
`#pragma' for _anything_.

 The ISO C99 standard includes `_Pragma', which now allows pragmas to
be generated from macros.  In addition, a `#pragma GCC' namespace is
now in use for GCC-specific pragmas.  However, it has been found
convenient to use `__attribute__' to achieve a natural attachment of
attributes to their corresponding declarations, whereas `#pragma GCC'
is of use for constructs that do not naturally form part of the
grammar.  *Note Pragmas Accepted by GCC: Pragmas.


File: llvm.info,  Node: Label Attributes,  Next: Attribute Syntax,  Prev: Function Attributes,  Up: C Extensions

6.32 Label Attributes
=====================

GCC allows attributes to be set on C labels.  *Note Attribute Syntax::,
for details of the exact syntax for using attributes.  Other attributes
are available for functions (*note Function Attributes::), variables
(*note Variable Attributes::) and for types (*note Type Attributes::).

 This example uses the `cold' label attribute to indicate the
`ErrorHandling' branch is unlikely to be taken and that the
`ErrorHandling' label is unused:


        asm goto ("some asm" : : : : NoError);

     /* This branch (the fall-through from the asm) is less commonly used */
     ErrorHandling:
        __attribute__((cold, unused)); /* Semi-colon is required here */
        printf("error\n");
        return 0;

     NoError:
        printf("no error\n");
        return 1;

`unused'
     This feature is intended for program-generated code that may
     contain unused labels, but which is compiled with `-Wall'.  It is
     not normally appropriate to use in it human-written code, though it
     could be useful in cases where the code that jumps to the label is
     contained within an `#ifdef' conditional.

`hot'
     The `hot' attribute on a label is used to inform the compiler that
     the path following the label is more likely than paths that are
     not so annotated.  This attribute is used in cases where
     `__builtin_expect' cannot be used, for instance with computed goto
     or `asm goto'.

`cold'
     The `cold' attribute on labels is used to inform the compiler that
     the path following the label is unlikely to be executed.  This
     attribute is used in cases where `__builtin_expect' cannot be
     used, for instance with computed goto or `asm goto'.



File: llvm.info,  Node: Attribute Syntax,  Next: Function Prototypes,  Prev: Label Attributes,  Up: C Extensions

6.33 Attribute Syntax
=====================

This section describes the syntax with which `__attribute__' may be
used, and the constructs to which attribute specifiers bind, for the C
language.  Some details may vary for C++ and Objective-C.  Because of
infelicities in the grammar for attributes, some forms described here
may not be successfully parsed in all cases.

 There are some problems with the semantics of attributes in C++.  For
example, there are no manglings for attributes, although they may affect
code generation, so problems may arise when attributed types are used in
conjunction with templates or overloading.  Similarly, `typeid' does
not distinguish between types with different attributes.  Support for
attributes in C++ may be restricted in future to attributes on
declarations only, but not on nested declarators.

 *Note Function Attributes::, for details of the semantics of attributes
applying to functions.  *Note Variable Attributes::, for details of the
semantics of attributes applying to variables.  *Note Type Attributes::,
for details of the semantics of attributes applying to structure, union
and enumerated types.  *Note Label Attributes::, for details of the
semantics of attributes applying to labels.

 An "attribute specifier" is of the form `__attribute__
((ATTRIBUTE-LIST))'.  An "attribute list" is a possibly empty
comma-separated sequence of "attributes", where each attribute is one
of the following:

   * Empty.  Empty attributes are ignored.

   * A word (which may be an identifier such as `unused', or a reserved
     word such as `const').

   * A word, followed by, in parentheses, parameters for the attribute.
     These parameters take one of the following forms:

        * An identifier.  For example, `mode' attributes use this form.

        * An identifier followed by a comma and a non-empty
          comma-separated list of expressions.  For example, `format'
          attributes use this form.

        * A possibly empty comma-separated list of expressions.  For
          example, `format_arg' attributes use this form with the list
          being a single integer constant expression, and `alias'
          attributes use this form with the list being a single string
          constant.

 An "attribute specifier list" is a sequence of one or more attribute
specifiers, not separated by any other tokens.

Label Attributes
................

In GNU C, an attribute specifier list may appear after the colon
following a label, other than a `case' or `default' label.  GNU C++
only permits attributes on labels if the attribute specifier is
immediately followed by a semicolon (i.e., the label applies to an empty
statement).  If the semicolon is missing, C++ label attributes are
ambiguous, as it is permissible for a declaration, which could begin
with an attribute list, to be labelled in C++.  Declarations cannot be
labelled in C90 or C99, so the ambiguity does not arise there.

Type Attributes
...............

An attribute specifier list may appear as part of a `struct', `union'
or `enum' specifier.  It may go either immediately after the `struct',
`union' or `enum' keyword, or after the closing brace.  The former
syntax is preferred.  Where attribute specifiers follow the closing
brace, they are considered to relate to the structure, union or
enumerated type defined, not to any enclosing declaration the type
specifier appears in, and the type defined is not complete until after
the attribute specifiers.

All other attributes
....................

Otherwise, an attribute specifier appears as part of a declaration,
counting declarations of unnamed parameters and type names, and relates
to that declaration (which may be nested in another declaration, for
example in the case of a parameter declaration), or to a particular
declarator within a declaration.  Where an attribute specifier is
applied to a parameter declared as a function or an array, it should
apply to the function or array rather than the pointer to which the
parameter is implicitly converted, but this is not yet correctly
implemented.

 Any list of specifiers and qualifiers at the start of a declaration may
contain attribute specifiers, whether or not such a list may in that
context contain storage class specifiers.  (Some attributes, however,
are essentially in the nature of storage class specifiers, and only make
sense where storage class specifiers may be used; for example,
`section'.)  There is one necessary limitation to this syntax: the
first old-style parameter declaration in a function definition cannot
begin with an attribute specifier, because such an attribute applies to
the function instead by syntax described below (which, however, is not
yet implemented in this case).  In some other cases, attribute
specifiers are permitted by this grammar but not yet supported by the
compiler.  All attribute specifiers in this place relate to the
declaration as a whole.  In the obsolescent usage where a type of `int'
is implied by the absence of type specifiers, such a list of specifiers
and qualifiers may be an attribute specifier list with no other
specifiers or qualifiers.

 At present, the first parameter in a function prototype must have some
type specifier that is not an attribute specifier; this resolves an
ambiguity in the interpretation of `void f(int (__attribute__((foo))
x))', but is subject to change.  At present, if the parentheses of a
function declarator contain only attributes then those attributes are
ignored, rather than yielding an error or warning or implying a single
parameter of type int, but this is subject to change.

 An attribute specifier list may appear immediately before a declarator
(other than the first) in a comma-separated list of declarators in a
declaration of more than one identifier using a single list of
specifiers and qualifiers.  Such attribute specifiers apply only to the
identifier before whose declarator they appear.  For example, in

     __attribute__((noreturn)) void d0 (void),
         __attribute__((format(printf, 1, 2))) d1 (const char *, ...),
          d2 (void)

the `noreturn' attribute applies to all the functions declared; the
`format' attribute only applies to `d1'.

 An attribute specifier list may appear immediately before the comma,
`=' or semicolon terminating the declaration of an identifier other
than a function definition.  Such attribute specifiers apply to the
declared object or function.  Where an assembler name for an object or
function is specified (*note Asm Labels::), the attribute must follow
the `asm' specification.

 An attribute specifier list may, in future, be permitted to appear
after the declarator in a function definition (before any old-style
parameter declarations or the function body).

 Attribute specifiers may be mixed with type qualifiers appearing inside
the `[]' of a parameter array declarator, in the C99 construct by which
such qualifiers are applied to the pointer to which the array is
implicitly converted.  Such attribute specifiers apply to the pointer,
not to the array, but at present this is not implemented and they are
ignored.

 An attribute specifier list may appear at the start of a nested
declarator.  At present, there are some limitations in this usage: the
attributes correctly apply to the declarator, but for most individual
attributes the semantics this implies are not implemented.  When
attribute specifiers follow the `*' of a pointer declarator, they may
be mixed with any type qualifiers present.  The following describes the
formal semantics of this syntax.  It makes the most sense if you are
familiar with the formal specification of declarators in the ISO C
standard.

 Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration `T D1',
where `T' contains declaration specifiers that specify a type TYPE
(such as `int') and `D1' is a declarator that contains an identifier
IDENT.  The type specified for IDENT for derived declarators whose type
does not include an attribute specifier is as in the ISO C standard.

 If `D1' has the form `( ATTRIBUTE-SPECIFIER-LIST D )', and the
declaration `T D' specifies the type "DERIVED-DECLARATOR-TYPE-LIST
TYPE" for IDENT, then `T D1' specifies the type
"DERIVED-DECLARATOR-TYPE-LIST ATTRIBUTE-SPECIFIER-LIST TYPE" for IDENT.

 If `D1' has the form `* TYPE-QUALIFIER-AND-ATTRIBUTE-SPECIFIER-LIST
D', and the declaration `T D' specifies the type
"DERIVED-DECLARATOR-TYPE-LIST TYPE" for IDENT, then `T D1' specifies
the type "DERIVED-DECLARATOR-TYPE-LIST
TYPE-QUALIFIER-AND-ATTRIBUTE-SPECIFIER-LIST pointer to TYPE" for IDENT.

 For example,

     void (__attribute__((noreturn)) ****f) (void);

specifies the type "pointer to pointer to pointer to pointer to
non-returning function returning `void'".  As another example,

     char *__attribute__((aligned(8))) *f;

specifies the type "pointer to 8-byte-aligned pointer to `char'".  Note
again that this does not work with most attributes; for example, the
usage of `aligned' and `noreturn' attributes given above is not yet
supported.

 For compatibility with existing code written for compiler versions that
did not implement attributes on nested declarators, some laxity is
allowed in the placing of attributes.  If an attribute that only applies
to types is applied to a declaration, it is treated as applying to the
type of that declaration.  If an attribute that only applies to
declarations is applied to the type of a declaration, it is treated as
applying to that declaration; and, for compatibility with code placing
the attributes immediately before the identifier declared, such an
attribute applied to a function return type is treated as applying to
the function type, and such an attribute applied to an array element
type is treated as applying to the array type.  If an attribute that
only applies to function types is applied to a pointer-to-function
type, it is treated as applying to the pointer target type; if such an
attribute is applied to a function return type that is not a
pointer-to-function type, it is treated as applying to the function
type.


File: llvm.info,  Node: Function Prototypes,  Next: C++ Comments,  Prev: Attribute Syntax,  Up: C Extensions

6.34 Prototypes and Old-Style Function Definitions
==================================================

GNU C extends ISO C to allow a function prototype to override a later
old-style non-prototype definition.  Consider the following example:

     /* Use prototypes unless the compiler is old-fashioned.  */
     #ifdef __STDC__
     #define P(x) x
     #else
     #define P(x) ()
     #endif

     /* Prototype function declaration.  */
     int isroot P((uid_t));

     /* Old-style function definition.  */
     int
     isroot (x)   /* ??? lossage here ??? */
          uid_t x;
     {
       return x == 0;
     }

 Suppose the type `uid_t' happens to be `short'.  ISO C does not allow
this example, because subword arguments in old-style non-prototype
definitions are promoted.  Therefore in this example the function
definition's argument is really an `int', which does not match the
prototype argument type of `short'.

 This restriction of ISO C makes it hard to write code that is portable
to traditional C compilers, because the programmer does not know
whether the `uid_t' type is `short', `int', or `long'.  Therefore, in
cases like these GNU C allows a prototype to override a later old-style
definition.  More precisely, in GNU C, a function prototype argument
type overrides the argument type specified by a later old-style
definition if the former type is the same as the latter type before
promotion.  Thus in GNU C the above example is equivalent to the
following:

     int isroot (uid_t);

     int
     isroot (uid_t x)
     {
       return x == 0;
     }

GNU C++ does not support old-style function definitions, so this
extension is irrelevant.


File: llvm.info,  Node: C++ Comments,  Next: Dollar Signs,  Prev: Function Prototypes,  Up: C Extensions

6.35 C++ Style Comments
=======================

In GNU C, you may use C++ style comments, which start with `//' and
continue until the end of the line.  Many other C implementations allow
such comments, and they are included in the 1999 C standard.  However,
C++ style comments are not recognized if you specify an `-std' option
specifying a version of ISO C before C99, or `-ansi' (equivalent to
`-std=c90').


File: llvm.info,  Node: Dollar Signs,  Next: Character Escapes,  Prev: C++ Comments,  Up: C Extensions

6.36 Dollar Signs in Identifier Names
=====================================

In GNU C, you may normally use dollar signs in identifier names.  This
is because many traditional C implementations allow such identifiers.
However, dollar signs in identifiers are not supported on a few target
machines, typically because the target assembler does not allow them.


File: llvm.info,  Node: Character Escapes,  Next: Variable Attributes,  Prev: Dollar Signs,  Up: C Extensions

6.37 The Character <ESC> in Constants
=====================================

You can use the sequence `\e' in a string or character constant to
stand for the ASCII character <ESC>.


File: llvm.info,  Node: Variable Attributes,  Next: Type Attributes,  Prev: Character Escapes,  Up: C Extensions

6.38 Specifying Attributes of Variables
=======================================

The keyword `__attribute__' allows you to specify special attributes of
variables or structure fields.  This keyword is followed by an
attribute specification inside double parentheses.  Some attributes are
currently defined generically for variables.  Other attributes are
defined for variables on particular target systems.  Other attributes
are available for functions (*note Function Attributes::), labels
(*note Label Attributes::) and for types (*note Type Attributes::).
Other front ends might define more attributes (*note Extensions to the
C++ Language: C++ Extensions.).

 You may also specify attributes with `__' preceding and following each
keyword.  This allows you to use them in header files without being
concerned about a possible macro of the same name.  For example, you
may use `__aligned__' instead of `aligned'.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

`aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment for the variable or
     structure field, measured in bytes.  For example, the declaration:

          int x __attribute__ ((aligned (16))) = 0;

     causes the compiler to allocate the global variable `x' on a
     16-byte boundary.  On a 68040, this could be used in conjunction
     with an `asm' expression to access the `move16' instruction which
     requires 16-byte aligned operands.

     You can also specify the alignment of structure fields.  For
     example, to create a double-word aligned `int' pair, you could
     write:

          struct foo { int x[2] __attribute__ ((aligned (8))); };

     This is an alternative to creating a union with a `double' member,
     which forces the union to be double-word aligned.

     As in the preceding examples, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     variable or structure field.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a variable or
     field to the default alignment for the target architecture you are
     compiling for.  The default alignment is sufficient for all scalar
     types, but may not be enough for all vector types on a target that
     supports vector operations.  The default alignment is fixed for a
     particular target ABI.

     GCC also provides a target specific macro `__BIGGEST_ALIGNMENT__',
     which is the largest alignment ever used for any data type on the
     target machine you are compiling for.  For example, you could
     write:

          short array[3] __attribute__ ((aligned (__BIGGEST_ALIGNMENT__)));

     The compiler automatically sets the alignment for the declared
     variable or field to `__BIGGEST_ALIGNMENT__'.  Doing this can
     often make copy operations more efficient, because the compiler can
     use whatever instructions copy the biggest chunks of memory when
     performing copies to or from the variables or fields that you have
     aligned this way.  Note that the value of `__BIGGEST_ALIGNMENT__'
     may change depending on command-line options.

     When used on a struct, or struct member, the `aligned' attribute
     can only increase the alignment; in order to decrease it, the
     `packed' attribute must be specified as well.  When used as part
     of a typedef, the `aligned' attribute can both increase and
     decrease alignment, and specifying the `packed' attribute
     generates a warning.

     Note that the effectiveness of `aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8-byte alignment,
     then specifying `aligned(16)' in an `__attribute__' still only
     provides you with 8-byte alignment.  See your linker documentation
     for further information.

     The `aligned' attribute can also be used for functions (*note
     Function Attributes::.)

`cleanup (CLEANUP_FUNCTION)'
     The `cleanup' attribute runs a function when the variable goes out
     of scope.  This attribute can only be applied to auto function
     scope variables; it may not be applied to parameters or variables
     with static storage duration.  The function must take one
     parameter, a pointer to a type compatible with the variable.  The
     return value of the function (if any) is ignored.

     If `-fexceptions' is enabled, then CLEANUP_FUNCTION is run during
     the stack unwinding that happens during the processing of the
     exception.  Note that the `cleanup' attribute does not allow the
     exception to be caught, only to perform an action.  It is
     undefined what happens if CLEANUP_FUNCTION does not return
     normally.

`common'
`nocommon'
     The `common' attribute requests GCC to place a variable in
     "common" storage.  The `nocommon' attribute requests the
     opposite--to allocate space for it directly.

     These attributes override the default chosen by the `-fno-common'
     and `-fcommon' flags respectively.

`deprecated'
`deprecated (MSG)'
     The `deprecated' attribute results in a warning if the variable is
     used anywhere in the source file.  This is useful when identifying
     variables that are expected to be removed in a future version of a
     program.  The warning also includes the location of the declaration
     of the deprecated variable, to enable users to easily find further
     information about why the variable is deprecated, or what they
     should do instead.  Note that the warning only occurs for uses:

          extern int old_var __attribute__ ((deprecated));
          extern int old_var;
          int new_fn () { return old_var; }

     results in a warning on line 3 but not line 2.  The optional MSG
     argument, which must be a string, is printed in the warning if
     present.

     The `deprecated' attribute can also be used for functions and
     types (*note Function Attributes::, *note Type Attributes::.)

`mode (MODE)'
     This attribute specifies the data type for the
     declaration--whichever type corresponds to the mode MODE.  This in
     effect lets you request an integer or floating-point type
     according to its width.

     You may also specify a mode of `byte' or `__byte__' to indicate
     the mode corresponding to a one-byte integer, `word' or `__word__'
     for the mode of a one-word integer, and `pointer' or `__pointer__'
     for the mode used to represent pointers.

`packed'
     The `packed' attribute specifies that a variable or structure field
     should have the smallest possible alignment--one byte for a
     variable, and one bit for a field, unless you specify a larger
     value with the `aligned' attribute.

     Here is a structure in which the field `x' is packed, so that it
     immediately follows `a':

          struct foo
          {
            char a;
            int x[2] __attribute__ ((packed));
          };

     _Note:_ The 4.1, 4.2 and 4.3 series of GCC ignore the `packed'
     attribute on bit-fields of type `char'.  This has been fixed in
     GCC 4.4 but the change can lead to differences in the structure
     layout.  See the documentation of `-Wpacked-bitfield-compat' for
     more information.

`section ("SECTION-NAME")'
     Normally, the compiler places the objects it generates in sections
     like `data' and `bss'.  Sometimes, however, you need additional
     sections, or you need certain particular variables to appear in
     special sections, for example to map to special hardware.  The
     `section' attribute specifies that a variable (or function) lives
     in a particular section.  For example, this small program uses
     several specific section names:

          struct duart a __attribute__ ((section ("DUART_A"))) = { 0 };
          struct duart b __attribute__ ((section ("DUART_B"))) = { 0 };
          char stack[10000] __attribute__ ((section ("STACK"))) = { 0 };
          int init_data __attribute__ ((section ("INITDATA")));

          main()
          {
            /* Initialize stack pointer */
            init_sp (stack + sizeof (stack));

            /* Initialize initialized data */
            memcpy (&init_data, &data, &edata - &data);

            /* Turn on the serial ports */
            init_duart (&a);
            init_duart (&b);
          }

     Use the `section' attribute with _global_ variables and not
     _local_ variables, as shown in the example.

     You may use the `section' attribute with initialized or
     uninitialized global variables but the linker requires each object
     be defined once, with the exception that uninitialized variables
     tentatively go in the `common' (or `bss') section and can be
     multiply "defined".  Using the `section' attribute changes what
     section the variable goes into and may cause the linker to issue
     an error if an uninitialized variable has multiple definitions.
     You can force a variable to be initialized with the `-fno-common'
     flag or the `nocommon' attribute.

     Some file formats do not support arbitrary sections so the
     `section' attribute is not available on all platforms.  If you
     need to map the entire contents of a module to a particular
     section, consider using the facilities of the linker instead.

`shared'
     On Microsoft Windows, in addition to putting variable definitions
     in a named section, the section can also be shared among all
     running copies of an executable or DLL.  For example, this small
     program defines shared data by putting it in a named section
     `shared' and marking the section shareable:

          int foo __attribute__((section ("shared"), shared)) = 0;

          int
          main()
          {
            /* Read and write foo.  All running
               copies see the same value.  */
            return 0;
          }

     You may only use the `shared' attribute along with `section'
     attribute with a fully-initialized global definition because of
     the way linkers work.  See `section' attribute for more
     information.

     The `shared' attribute is only available on Microsoft Windows.

`tls_model ("TLS_MODEL")'
     The `tls_model' attribute sets thread-local storage model (*note
     Thread-Local::) of a particular `__thread' variable, overriding
     `-ftls-model=' command-line switch on a per-variable basis.  The
     TLS_MODEL argument should be one of `global-dynamic',
     `local-dynamic', `initial-exec' or `local-exec'.

     Not all targets support this attribute.

`unused'
     This attribute, attached to a variable, means that the variable is
     meant to be possibly unused.  GCC does not produce a warning for
     this variable.

`used'
     This attribute, attached to a variable with the static storage,
     means that the variable must be emitted even if it appears that
     the variable is not referenced.

     When applied to a static data member of a C++ class template, the
     attribute also means that the member is instantiated if the class
     itself is instantiated.

`vector_size (BYTES)'
     This attribute specifies the vector size for the variable,
     measured in bytes.  For example, the declaration:

          int foo __attribute__ ((vector_size (16)));

     causes the compiler to set the mode for `foo', to be 16 bytes,
     divided into `int' sized units.  Assuming a 32-bit int (a vector of
     4 units of 4 bytes), the corresponding mode of `foo' is V4SI.

     This attribute is only applicable to integral and float scalars,
     although arrays, pointers, and function return values are allowed
     in conjunction with this construct.

     Aggregates with this attribute are invalid, even if they are of
     the same size as a corresponding scalar.  For example, the
     declaration:

          struct S { int a; };
          struct S  __attribute__ ((vector_size (16))) foo;

     is invalid even if the size of the structure is the same as the
     size of the `int'.

`selectany'
     The `selectany' attribute causes an initialized global variable to
     have link-once semantics.  When multiple definitions of the
     variable are encountered by the linker, the first is selected and
     the remainder are discarded.  Following usage by the Microsoft
     compiler, the linker is told _not_ to warn about size or content
     differences of the multiple definitions.

     Although the primary usage of this attribute is for POD types, the
     attribute can also be applied to global C++ objects that are
     initialized by a constructor.  In this case, the static
     initialization and destruction code for the object is emitted in
     each translation defining the object, but the calls to the
     constructor and destructor are protected by a link-once guard
     variable.

     The `selectany' attribute is only available on Microsoft Windows
     targets.  You can use `__declspec (selectany)' as a synonym for
     `__attribute__ ((selectany))' for compatibility with other
     compilers.

`weak'
     The `weak' attribute is described in *note Function Attributes::.

`dllimport'
     The `dllimport' attribute is described in *note Function
     Attributes::.

`dllexport'
     The `dllexport' attribute is described in *note Function
     Attributes::.


6.38.1 AVR Variable Attributes
------------------------------

`progmem'
     The `progmem' attribute is used on the AVR to place read-only data
     in the non-volatile program memory (flash). The `progmem'
     attribute accomplishes this by putting respective variables into a
     section whose name starts with `.progmem'.

     This attribute works similar to the `section' attribute but adds
     additional checking. Notice that just like the `section'
     attribute, `progmem' affects the location of the data but not how
     this data is accessed.

     In order to read data located with the `progmem' attribute
     (inline) assembler must be used.
          /* Use custom macros from AVR-LibC (http://nongnu.org/avr-libc/user-manual/) */
          #include <avr/pgmspace.h>

          /* Locate var in flash memory */
          const int var[2] PROGMEM = { 1, 2 };

          int read_var (int i)
          {
              /* Access var[] by accessor macro from avr/pgmspace.h */
              return (int) pgm_read_word (& var[i]);
          }

     AVR is a Harvard architecture processor and data and read-only data
     normally resides in the data memory (RAM).

     See also the *note AVR Named Address Spaces:: section for an
     alternate way to locate and access data in flash memory.

`io'
`io (ADDR)'
     Variables with the `io' attribute are used to address
     memory-mapped peripherals in the io address range.  If an address
     is specified, the variable is assigned that address, and the value
     is interpreted as an address in the data address space.  Example:

          volatile int porta __attribute__((io (0x22)));

     The address specified in the address in the data address range.

     Otherwise, the variable it is not assigned an address, but the
     compiler will still use in/out instructions where applicable,
     assuming some other module assigns an address in the io address
     range.  Example:

          extern volatile int porta __attribute__((io));

`io_low'
`io_low (ADDR)'
     This is like the `io' attribute, but additionally it informs the
     compiler that the object lies in the lower half of the I/O area,
     allowing the use of `cbi', `sbi', `sbic' and `sbis' instructions.

`address'
`address (ADDR)'
     Variables with the `address' attribute are used to address
     memory-mapped peripherals that may lie outside the io address
     range.

          volatile int porta __attribute__((address (0x600)));


6.38.2 Blackfin Variable Attributes
-----------------------------------

Three attributes are currently defined for the Blackfin.

`l1_data'
`l1_data_A'
`l1_data_B'
     Use these attributes on the Blackfin to place the variable into L1
     Data SRAM.  Variables with `l1_data' attribute are put into the
     specific section named `.l1.data'. Those with `l1_data_A'
     attribute are put into the specific section named `.l1.data.A'.
     Those with `l1_data_B' attribute are put into the specific section
     named `.l1.data.B'.

`l2'
     Use this attribute on the Blackfin to place the variable into L2
     SRAM.  Variables with `l2' attribute are put into the specific
     section named `.l2.data'.

6.38.3 M32R/D Variable Attributes
---------------------------------

One attribute is currently defined for the M32R/D.

`model (MODEL-NAME)'
     Use this attribute on the M32R/D to set the addressability of an
     object.  The identifier MODEL-NAME is one of `small', `medium', or
     `large', representing each of the code models.

     Small model objects live in the lower 16MB of memory (so that their
     addresses can be loaded with the `ld24' instruction).

     Medium and large model objects may live anywhere in the 32-bit
     address space (the compiler generates `seth/add3' instructions to
     load their addresses).

6.38.4 MeP Variable Attributes
------------------------------

The MeP target has a number of addressing modes and busses.  The `near'
space spans the standard memory space's first 16 megabytes (24 bits).
The `far' space spans the entire 32-bit memory space.  The `based'
space is a 128-byte region in the memory space that is addressed
relative to the `$tp' register.  The `tiny' space is a 65536-byte
region relative to the `$gp' register.  In addition to these memory
regions, the MeP target has a separate 16-bit control bus which is
specified with `cb' attributes.

`based'
     Any variable with the `based' attribute is assigned to the
     `.based' section, and is accessed with relative to the `$tp'
     register.

`tiny'
     Likewise, the `tiny' attribute assigned variables to the `.tiny'
     section, relative to the `$gp' register.

`near'
     Variables with the `near' attribute are assumed to have addresses
     that fit in a 24-bit addressing mode.  This is the default for
     large variables (`-mtiny=4' is the default) but this attribute can
     override `-mtiny=' for small variables, or override `-ml'.

`far'
     Variables with the `far' attribute are addressed using a full
     32-bit address.  Since this covers the entire memory space, this
     allows modules to make no assumptions about where variables might
     be stored.

`io'
`io (ADDR)'
     Variables with the `io' attribute are used to address
     memory-mapped peripherals.  If an address is specified, the
     variable is assigned that address, else it is not assigned an
     address (it is assumed some other module assigns an address).
     Example:

          int timer_count __attribute__((io(0x123)));

`cb'
`cb (ADDR)'
     Variables with the `cb' attribute are used to access the control
     bus, using special instructions.  `addr' indicates the control bus
     address.  Example:

          int cpu_clock __attribute__((cb(0x123)));


6.38.5 PowerPC Variable Attributes
----------------------------------

Three attributes currently are defined for PowerPC configurations:
`altivec', `ms_struct' and `gcc_struct'.

 For full documentation of the struct attributes please see the
documentation in *note x86 Variable Attributes::.

 For documentation of `altivec' attribute please see the documentation
in *note PowerPC Type Attributes::.

6.38.6 SPU Variable Attributes
------------------------------

The SPU supports the `spu_vector' attribute for variables.  For
documentation of this attribute please see the documentation in *note
SPU Type Attributes::.

6.38.7 x86 Variable Attributes
------------------------------

Two attributes are currently defined for x86 configurations:
`ms_struct' and `gcc_struct'.

`ms_struct'
`gcc_struct'
     If `packed' is used on a structure, or if bit-fields are used, it
     may be that the Microsoft ABI lays out the structure differently
     than the way GCC normally does.  Particularly when moving packed
     data between functions compiled with GCC and the native Microsoft
     compiler (either via function call or as data in a file), it may
     be necessary to access either format.

     Currently `-m[no-]ms-bitfields' is provided for the Microsoft
     Windows x86 compilers to match the native Microsoft compiler.

     The Microsoft structure layout algorithm is fairly simple with the
     exception of the bit-field packing.  The padding and alignment of
     members of structures and whether a bit-field can straddle a
     storage-unit boundary are determine by these rules:

       1. Structure members are stored sequentially in the order in
          which they are declared: the first member has the lowest
          memory address and the last member the highest.

       2. Every data object has an alignment requirement.  The
          alignment requirement for all data except structures, unions,
          and arrays is either the size of the object or the current
          packing size (specified with either the `aligned' attribute
          or the `pack' pragma), whichever is less.  For structures,
          unions, and arrays, the alignment requirement is the largest
          alignment requirement of its members.  Every object is
          allocated an offset so that:

               offset % alignment_requirement == 0

       3. Adjacent bit-fields are packed into the same 1-, 2-, or
          4-byte allocation unit if the integral types are the same
          size and if the next bit-field fits into the current
          allocation unit without crossing the boundary imposed by the
          common alignment requirements of the bit-fields.

     MSVC interprets zero-length bit-fields in the following ways:

       1. If a zero-length bit-field is inserted between two bit-fields
          that are normally coalesced, the bit-fields are not coalesced.

          For example:

               struct
                {
                  unsigned long bf_1 : 12;
                  unsigned long : 0;
                  unsigned long bf_2 : 12;
                } t1;

          The size of `t1' is 8 bytes with the zero-length bit-field.
          If the zero-length bit-field were removed, `t1''s size would
          be 4 bytes.

       2. If a zero-length bit-field is inserted after a bit-field,
          `foo', and the alignment of the zero-length bit-field is
          greater than the member that follows it, `bar', `bar' is
          aligned as the type of the zero-length bit-field.

          For example:

               struct
                {
                  char foo : 4;
                  short : 0;
                  char bar;
                } t2;

               struct
                {
                  char foo : 4;
                  short : 0;
                  double bar;
                } t3;

          For `t2', `bar' is placed at offset 2, rather than offset 1.
          Accordingly, the size of `t2' is 4.  For `t3', the zero-length
          bit-field does not affect the alignment of `bar' or, as a
          result, the size of the structure.

          Taking this into account, it is important to note the
          following:

            1. If a zero-length bit-field follows a normal bit-field,
               the type of the zero-length bit-field may affect the
               alignment of the structure as whole. For example, `t2'
               has a size of 4 bytes, since the zero-length bit-field
               follows a normal bit-field, and is of type short.

            2. Even if a zero-length bit-field is not followed by a
               normal bit-field, it may still affect the alignment of
               the structure:

                    struct
                     {
                       char foo : 6;
                       long : 0;
                     } t4;

               Here, `t4' takes up 4 bytes.

       3. Zero-length bit-fields following non-bit-field members are
          ignored:

               struct
                {
                  char foo;
                  long : 0;
                  char bar;
                } t5;

          Here, `t5' takes up 2 bytes.

6.38.8 Xstormy16 Variable Attributes
------------------------------------

One attribute is currently defined for xstormy16 configurations:
`below100'.

`below100'
     If a variable has the `below100' attribute (`BELOW100' is allowed
     also), GCC places the variable in the first 0x100 bytes of memory
     and use special opcodes to access it.  Such variables are placed
     in either the `.bss_below100' section or the `.data_below100'
     section.



File: llvm.info,  Node: Type Attributes,  Next: Alignment,  Prev: Variable Attributes,  Up: C Extensions

6.39 Specifying Attributes of Types
===================================

The keyword `__attribute__' allows you to specify special attributes of
`struct' and `union' types when you define such types.  This keyword is
followed by an attribute specification inside double parentheses.
Eight attributes are currently defined for types: `aligned', `packed',
`transparent_union', `unused', `deprecated', `visibility', `may_alias'
and `bnd_variable_size'.  Other attributes are defined for functions
(*note Function Attributes::), labels (*note Label Attributes::) and
for variables (*note Variable Attributes::).

 You may also specify any one of these attributes with `__' preceding
and following its keyword.  This allows you to use these attributes in
header files without being concerned about a possible macro of the same
name.  For example, you may use `__aligned__' instead of `aligned'.

 You may specify type attributes in an enum, struct or union type
declaration or definition, or for other types in a `typedef'
declaration.

 For an enum, struct or union type, you may specify attributes either
between the enum, struct or union tag and the name of the type, or just
past the closing curly brace of the _definition_.  The former syntax is
preferred.

 *Note Attribute Syntax::, for details of the exact syntax for using
attributes.

`aligned (ALIGNMENT)'
     This attribute specifies a minimum alignment (in bytes) for
     variables of the specified type.  For example, the declarations:

          struct S { short f[3]; } __attribute__ ((aligned (8)));
          typedef int more_aligned_int __attribute__ ((aligned (8)));

     force the compiler to ensure (as far as it can) that each variable
     whose type is `struct S' or `more_aligned_int' is allocated and
     aligned _at least_ on a 8-byte boundary.  On a SPARC, having all
     variables of type `struct S' aligned to 8-byte boundaries allows
     the compiler to use the `ldd' and `std' (doubleword load and
     store) instructions when copying one variable of type `struct S' to
     another, thus improving run-time efficiency.

     Note that the alignment of any given `struct' or `union' type is
     required by the ISO C standard to be at least a perfect multiple of
     the lowest common multiple of the alignments of all of the members
     of the `struct' or `union' in question.  This means that you _can_
     effectively adjust the alignment of a `struct' or `union' type by
     attaching an `aligned' attribute to any one of the members of such
     a type, but the notation illustrated in the example above is a
     more obvious, intuitive, and readable way to request the compiler
     to adjust the alignment of an entire `struct' or `union' type.

     As in the preceding example, you can explicitly specify the
     alignment (in bytes) that you wish the compiler to use for a given
     `struct' or `union' type.  Alternatively, you can leave out the
     alignment factor and just ask the compiler to align a type to the
     maximum useful alignment for the target machine you are compiling
     for.  For example, you could write:

          struct S { short f[3]; } __attribute__ ((aligned));

     Whenever you leave out the alignment factor in an `aligned'
     attribute specification, the compiler automatically sets the
     alignment for the type to the largest alignment that is ever used
     for any data type on the target machine you are compiling for.
     Doing this can often make copy operations more efficient, because
     the compiler can use whatever instructions copy the biggest chunks
     of memory when performing copies to or from the variables that
     have types that you have aligned this way.

     In the example above, if the size of each `short' is 2 bytes, then
     the size of the entire `struct S' type is 6 bytes.  The smallest
     power of two that is greater than or equal to that is 8, so the
     compiler sets the alignment for the entire `struct S' type to 8
     bytes.

     Note that although you can ask the compiler to select a
     time-efficient alignment for a given type and then declare only
     individual stand-alone objects of that type, the compiler's
     ability to select a time-efficient alignment is primarily useful
     only when you plan to create arrays of variables having the
     relevant (efficiently aligned) type.  If you declare or use arrays
     of variables of an efficiently-aligned type, then it is likely
     that your program also does pointer arithmetic (or subscripting,
     which amounts to the same thing) on pointers to the relevant type,
     and the code that the compiler generates for these pointer
     arithmetic operations is often more efficient for
     efficiently-aligned types than for other types.

     The `aligned' attribute can only increase the alignment; but you
     can decrease it by specifying `packed' as well.  See below.

     Note that the effectiveness of `aligned' attributes may be limited
     by inherent limitations in your linker.  On many systems, the
     linker is only able to arrange for variables to be aligned up to a
     certain maximum alignment.  (For some linkers, the maximum
     supported alignment may be very very small.)  If your linker is
     only able to align variables up to a maximum of 8-byte alignment,
     then specifying `aligned(16)' in an `__attribute__' still only
     provides you with 8-byte alignment.  See your linker documentation
     for further information.

`packed'
     This attribute, attached to `struct' or `union' type definition,
     specifies that each member (other than zero-width bit-fields) of
     the structure or union is placed to minimize the memory required.
     When attached to an `enum' definition, it indicates that the
     smallest integral type should be used.

     Specifying this attribute for `struct' and `union' types is
     equivalent to specifying the `packed' attribute on each of the
     structure or union members.  Specifying the `-fshort-enums' flag
     on the line is equivalent to specifying the `packed' attribute on
     all `enum' definitions.

     In the following example `struct my_packed_struct''s members are
     packed closely together, but the internal layout of its `s' member
     is not packed--to do that, `struct my_unpacked_struct' needs to be
     packed too.

          struct my_unpacked_struct
           {
              char c;
              int i;
           };

          struct __attribute__ ((__packed__)) my_packed_struct
            {
               char c;
               int  i;
               struct my_unpacked_struct s;
            };

     You may only specify this attribute on the definition of an `enum',
     `struct' or `union', not on a `typedef' that does not also define
     the enumerated type, structure or union.

`transparent_union'
     This attribute, attached to a `union' type definition, indicates
     that any function parameter having that union type causes calls to
     that function to be treated in a special way.

     First, the argument corresponding to a transparent union type can
     be of any type in the union; no cast is required.  Also, if the
     union contains a pointer type, the corresponding argument can be a
     null pointer constant or a void pointer expression; and if the
     union contains a void pointer type, the corresponding argument can
     be any pointer expression.  If the union member type is a pointer,
     qualifiers like `const' on the referenced type must be respected,
     just as with normal pointer conversions.

     Second, the argument is passed to the function using the calling
     conventions of the first member of the transparent union, not the
     calling conventions of the union itself.  All members of the union
     must have the same machine representation; this is necessary for
     this argument passing to work properly.

     Transparent unions are designed for library functions that have
     multiple interfaces for compatibility reasons.  For example,
     suppose the `wait' function must accept either a value of type
     `int *' to comply with POSIX, or a value of type `union wait *' to
     comply with the 4.1BSD interface.  If `wait''s parameter were
     `void *', `wait' would accept both kinds of arguments, but it
     would also accept any other pointer type and this would make
     argument type checking less useful.  Instead, `<sys/wait.h>' might
     define the interface as follows:

          typedef union __attribute__ ((__transparent_union__))
            {
              int *__ip;
              union wait *__up;
            } wait_status_ptr_t;

          pid_t wait (wait_status_ptr_t);

     This interface allows either `int *' or `union wait *' arguments
     to be passed, using the `int *' calling convention.  The program
     can call `wait' with arguments of either type:

          int w1 () { int w; return wait (&w); }
          int w2 () { union wait w; return wait (&w); }

     With this interface, `wait''s implementation might look like this:

          pid_t wait (wait_status_ptr_t p)
          {
            return waitpid (-1, p.__ip, 0);
          }

`unused'
     When attached to a type (including a `union' or a `struct'), this
     attribute means that variables of that type are meant to appear
     possibly unused.  GCC does not produce a warning for any variables
     of that type, even if the variable appears to do nothing.  This is
     often the case with lock or thread classes, which are usually
     defined and then not referenced, but contain constructors and
     destructors that have nontrivial bookkeeping functions.

`deprecated'
`deprecated (MSG)'
     The `deprecated' attribute results in a warning if the type is
     used anywhere in the source file.  This is useful when identifying
     types that are expected to be removed in a future version of a
     program.  If possible, the warning also includes the location of
     the declaration of the deprecated type, to enable users to easily
     find further information about why the type is deprecated, or what
     they should do instead.  Note that the warnings only occur for
     uses and then only if the type is being applied to an identifier
     that itself is not being declared as deprecated.

          typedef int T1 __attribute__ ((deprecated));
          T1 x;
          typedef T1 T2;
          T2 y;
          typedef T1 T3 __attribute__ ((deprecated));
          T3 z __attribute__ ((deprecated));

     results in a warning on line 2 and 3 but not lines 4, 5, or 6.  No
     warning is issued for line 4 because T2 is not explicitly
     deprecated.  Line 5 has no warning because T3 is explicitly
     deprecated.  Similarly for line 6.  The optional MSG argument,
     which must be a string, is printed in the warning if present.

     The `deprecated' attribute can also be used for functions and
     variables (*note Function Attributes::, *note Variable
     Attributes::.)

`may_alias'
     Accesses through pointers to types with this attribute are not
     subject to type-based alias analysis, but are instead assumed to
     be able to alias any other type of objects.  In the context of
     section 6.5 paragraph 7 of the C99 standard, an lvalue expression
     dereferencing such a pointer is treated like having a character
     type.  See `-fstrict-aliasing' for more information on aliasing
     issues.  This extension exists to support some vector APIs, in
     which pointers to one vector type are permitted to alias pointers
     to a different vector type.

     Note that an object of a type with this attribute does not have any
     special semantics.

     Example of use:

          typedef short __attribute__((__may_alias__)) short_a;

          int
          main (void)
          {
            int a = 0x12345678;
            short_a *b = (short_a *) &a;

            b[1] = 0;

            if (a == 0x12345678)
              abort();

            exit(0);
          }

     If you replaced `short_a' with `short' in the variable
     declaration, the above program would abort when compiled with
     `-fstrict-aliasing', which is on by default at `-O2' or above.

`visibility'
     In C++, attribute visibility (*note Function Attributes::) can
     also be applied to class, struct, union and enum types.  Unlike
     other type attributes, the attribute must appear between the
     initial keyword and the name of the type; it cannot appear after
     the body of the type.

     Note that the type visibility is applied to vague linkage entities
     associated with the class (vtable, typeinfo node, etc.).  In
     particular, if a class is thrown as an exception in one shared
     object and caught in another, the class must have default
     visibility.  Otherwise the two shared objects are unable to use
     the same typeinfo node and exception handling will break.

`designated_init'
     This attribute may only be applied to structure types.  It
     indicates that any initialization of an object of this type must
     use designated initializers rather than positional initializers.
     The intent of this attribute is to allow the programmer to
     indicate that a structure's layout may change, and that therefore
     relying on positional initialization will result in future
     breakage.

     GCC emits warnings based on this attribute by default; use
     `-Wno-designated-init' to suppress them.

`bnd_variable_size'
     When applied to a structure field, this attribute tells Pointer
     Bounds Checker that the size of this field should not be computed
     using static type information.  It may be used to mark variable
     sized static array fields placed at the end of a structure.

          struct S
          {
            int size;
            char data[1];
          }
          S *p = (S *)malloc (sizeof(S) + 100);
          p->data[10] = 0; //Bounds violation

     By using an attribute for a field we may avoid bound violation we
     most probably do not want to see:

          struct S
          {
            int size;
            char data[1] __attribute__((bnd_variable_size));
          }
          S *p = (S *)malloc (sizeof(S) + 100);
          p->data[10] = 0; //OK


 To specify multiple attributes, separate them by commas within the
double parentheses: for example, `__attribute__ ((aligned (16),
packed))'.

6.39.1 ARM Type Attributes
--------------------------

On those ARM targets that support `dllimport' (such as Symbian OS), you
can use the `notshared' attribute to indicate that the virtual table
and other similar data for a class should not be exported from a DLL.
For example:

     class __declspec(notshared) C {
     public:
       __declspec(dllimport) C();
       virtual void f();
     }

     __declspec(dllexport)
     C::C() {}

In this code, `C::C' is exported from the current DLL, but the virtual
table for `C' is not exported.  (You can use `__attribute__' instead of
`__declspec' if you prefer, but most Symbian OS code uses `__declspec'.)

6.39.2 MeP Type Attributes
--------------------------

Many of the MeP variable attributes may be applied to types as well.
Specifically, the `based', `tiny', `near', and `far' attributes may be
applied to either.  The `io' and `cb' attributes may not be applied to
types.

6.39.3 PowerPC Type Attributes
------------------------------

Three attributes currently are defined for PowerPC configurations:
`altivec', `ms_struct' and `gcc_struct'.

 For full documentation of the `ms_struct' and `gcc_struct' attributes
please see the documentation in *note x86 Type Attributes::.

 The `altivec' attribute allows one to declare AltiVec vector data
types supported by the AltiVec Programming Interface Manual.  The
attribute requires an argument to specify one of three vector types:
`vector__', `pixel__' (always followed by unsigned short), and `bool__'
(always followed by unsigned).

     __attribute__((altivec(vector__)))
     __attribute__((altivec(pixel__))) unsigned short
     __attribute__((altivec(bool__))) unsigned

 These attributes mainly are intended to support the `__vector',
`__pixel', and `__bool' AltiVec keywords.

6.39.4 SPU Type Attributes
--------------------------

The SPU supports the `spu_vector' attribute for types.  This attribute
allows one to declare vector data types supported by the
Sony/Toshiba/IBM SPU Language Extensions Specification.  It is intended
to support the `__vector' keyword.

6.39.5 x86 Type Attributes
--------------------------

Two attributes are currently defined for x86 configurations:
`ms_struct' and `gcc_struct'.

`ms_struct'
`gcc_struct'
     If `packed' is used on a structure, or if bit-fields are used it
     may be that the Microsoft ABI packs them differently than GCC
     normally packs them.  Particularly when moving packed data between
     functions compiled with GCC and the native Microsoft compiler
     (either via function call or as data in a file), it may be
     necessary to access either format.

     Currently `-m[no-]ms-bitfields' is provided for the Microsoft
     Windows x86 compilers to match the native Microsoft compiler.


File: llvm.info,  Node: Alignment,  Next: Inline,  Prev: Type Attributes,  Up: C Extensions

6.40 Inquiring on Alignment of Types or Variables
=================================================

The keyword `__alignof__' allows you to inquire about how an object is
aligned, or the minimum alignment usually required by a type.  Its
syntax is just like `sizeof'.

 For example, if the target machine requires a `double' value to be
aligned on an 8-byte boundary, then `__alignof__ (double)' is 8.  This
is true on many RISC machines.  On more traditional machine designs,
`__alignof__ (double)' is 4 or even 2.

 Some machines never actually require alignment; they allow reference
to any data type even at an odd address.  For these machines,
`__alignof__' reports the smallest alignment that GCC gives the data
type, usually as mandated by the target ABI.

 If the operand of `__alignof__' is an lvalue rather than a type, its
value is the required alignment for its type, taking into account any
minimum alignment specified with GCC's `__attribute__' extension (*note
Variable Attributes::).  For example, after this declaration:

     struct foo { int x; char y; } foo1;

the value of `__alignof__ (foo1.y)' is 1, even though its actual
alignment is probably 2 or 4, the same as `__alignof__ (int)'.

 It is an error to ask for the alignment of an incomplete type.


File: llvm.info,  Node: Inline,  Next: Volatiles,  Prev: Alignment,  Up: C Extensions

6.41 An Inline Function is As Fast As a Macro
=============================================

By declaring a function inline, you can direct GCC to make calls to
that function faster.  One way GCC can achieve this is to integrate
that function's code into the code for its callers.  This makes
execution faster by eliminating the function-call overhead; in
addition, if any of the actual argument values are constant, their
known values may permit simplifications at compile time so that not all
of the inline function's code needs to be included.  The effect on code
size is less predictable; object code may be larger or smaller with
function inlining, depending on the particular case.  You can also
direct GCC to try to integrate all "simple enough" functions into their
callers with the option `-finline-functions'.

 GCC implements three different semantics of declaring a function
inline.  One is available with `-std=gnu89' or `-fgnu89-inline' or when
`gnu_inline' attribute is present on all inline declarations, another
when `-std=c99', `-std=c11', `-std=gnu99' or `-std=gnu11' (without
`-fgnu89-inline'), and the third is used when compiling C++.

 To declare a function inline, use the `inline' keyword in its
declaration, like this:

     static inline int
     inc (int *a)
     {
       return (*a)++;
     }

 If you are writing a header file to be included in ISO C90 programs,
write `__inline__' instead of `inline'.  *Note Alternate Keywords::.

 The three types of inlining behave similarly in two important cases:
when the `inline' keyword is used on a `static' function, like the
example above, and when a function is first declared without using the
`inline' keyword and then is defined with `inline', like this:

     extern int inc (int *a);
     inline int
     inc (int *a)
     {
       return (*a)++;
     }

 In both of these common cases, the program behaves the same as if you
had not used the `inline' keyword, except for its speed.

 When a function is both inline and `static', if all calls to the
function are integrated into the caller, and the function's address is
never used, then the function's own assembler code is never referenced.
In this case, GCC does not actually output assembler code for the
function, unless you specify the option `-fkeep-inline-functions'.
Some calls cannot be integrated for various reasons (in particular,
calls that precede the function's definition cannot be integrated, and
neither can recursive calls within the definition).  If there is a
nonintegrated call, then the function is compiled to assembler code as
usual.  The function must also be compiled as usual if the program
refers to its address, because that can't be inlined.

 Note that certain usages in a function definition can make it
unsuitable for inline substitution.  Among these usages are: variadic
functions, use of `alloca', use of variable-length data types (*note
Variable Length::), use of computed goto (*note Labels as Values::),
use of nonlocal goto, and nested functions (*note Nested Functions::).
Using `-Winline' warns when a function marked `inline' could not be
substituted, and gives the reason for the failure.

 As required by ISO C++, GCC considers member functions defined within
the body of a class to be marked inline even if they are not explicitly
declared with the `inline' keyword.  You can override this with
`-fno-default-inline'; *note Options Controlling C++ Dialect: C++
Dialect Options.

 GCC does not inline any functions when not optimizing unless you
specify the `always_inline' attribute for the function, like this:

     /* Prototype.  */
     inline void foo (const char) __attribute__((always_inline));

 The remainder of this section is specific to GNU C90 inlining.

 When an inline function is not `static', then the compiler must assume
that there may be calls from other source files; since a global symbol
can be defined only once in any program, the function must not be
defined in the other source files, so the calls therein cannot be
integrated.  Therefore, a non-`static' inline function is always
compiled on its own in the usual fashion.

 If you specify both `inline' and `extern' in the function definition,
then the definition is used only for inlining.  In no case is the
function compiled on its own, not even if you refer to its address
explicitly.  Such an address becomes an external reference, as if you
had only declared the function, and had not defined it.

 This combination of `inline' and `extern' has almost the effect of a
macro.  The way to use it is to put a function definition in a header
file with these keywords, and put another copy of the definition
(lacking `inline' and `extern') in a library file.  The definition in
the header file causes most calls to the function to be inlined.  If
any uses of the function remain, they refer to the single copy in the
library.


File: llvm.info,  Node: Volatiles,  Next: Using Assembly Language with C,  Prev: Inline,  Up: C Extensions

6.42 When is a Volatile Object Accessed?
========================================

C has the concept of volatile objects.  These are normally accessed by
pointers and used for accessing hardware or inter-thread communication.
The standard encourages compilers to refrain from optimizations
concerning accesses to volatile objects, but leaves it implementation
defined as to what constitutes a volatile access.  The minimum
requirement is that at a sequence point all previous accesses to
volatile objects have stabilized and no subsequent accesses have
occurred.  Thus an implementation is free to reorder and combine
volatile accesses that occur between sequence points, but cannot do so
for accesses across a sequence point.  The use of volatile does not
allow you to violate the restriction on updating objects multiple times
between two sequence points.

 Accesses to non-volatile objects are not ordered with respect to
volatile accesses.  You cannot use a volatile object as a memory
barrier to order a sequence of writes to non-volatile memory.  For
instance:

     int *ptr = SOMETHING;
     volatile int vobj;
     *ptr = SOMETHING;
     vobj = 1;

Unless *PTR and VOBJ can be aliased, it is not guaranteed that the
write to *PTR occurs by the time the update of VOBJ happens.  If you
need this guarantee, you must use a stronger memory barrier such as:

     int *ptr = SOMETHING;
     volatile int vobj;
     *ptr = SOMETHING;
     asm volatile ("" : : : "memory");
     vobj = 1;

 A scalar volatile object is read when it is accessed in a void context:

     volatile int *src = SOMEVALUE;
     *src;

 Such expressions are rvalues, and GCC implements this as a read of the
volatile object being pointed to.

 Assignments are also expressions and have an rvalue.  However when
assigning to a scalar volatile, the volatile object is not reread,
regardless of whether the assignment expression's rvalue is used or
not.  If the assignment's rvalue is used, the value is that assigned to
the volatile object.  For instance, there is no read of VOBJ in all the
following cases:

     int obj;
     volatile int vobj;
     vobj = SOMETHING;
     obj = vobj = SOMETHING;
     obj ? vobj = ONETHING : vobj = ANOTHERTHING;
     obj = (SOMETHING, vobj = ANOTHERTHING);

 If you need to read the volatile object after an assignment has
occurred, you must use a separate expression with an intervening
sequence point.

 As bit-fields are not individually addressable, volatile bit-fields may
be implicitly read when written to, or when adjacent bit-fields are
accessed.  Bit-field operations may be optimized such that adjacent
bit-fields are only partially accessed, if they straddle a storage unit
boundary.  For these reasons it is unwise to use volatile bit-fields to
access hardware.


File: llvm.info,  Node: Using Assembly Language with C,  Next: Alternate Keywords,  Prev: Volatiles,  Up: C Extensions

6.43 How to Use Inline Assembly Language in C Code
==================================================

The `asm' keyword allows you to embed assembler instructions within C
code.  GCC provides two forms of inline `asm' statements.  A "basic
`asm'" statement is one with no operands (*note Basic Asm::), while an
"extended `asm'" statement (*note Extended Asm::) includes one or more
operands.  The extended form is preferred for mixing C and assembly
language within a function, but to include assembly language at top
level you must use basic `asm'.

 You can also use the `asm' keyword to override the assembler name for
a C symbol, or to place a C variable in a specific register.

* Menu:

* Basic Asm::          Inline assembler without operands.
* Extended Asm::       Inline assembler with operands.
* Constraints::        Constraints for `asm' operands
* Asm Labels::         Specifying the assembler name to use for a C symbol.
* Explicit Reg Vars::  Defining variables residing in specified registers.
* Size of an asm::     How GCC calculates the size of an `asm' block.


File: llvm.info,  Node: Basic Asm,  Next: Extended Asm,  Up: Using Assembly Language with C

6.43.1 Basic Asm -- Assembler Instructions Without Operands
-----------------------------------------------------------

A basic `asm' statement has the following syntax:

     asm [ volatile ] ( ASSEMBLERINSTRUCTIONS )

 The `asm' keyword is a GNU extension.  When writing code that can be
compiled with `-ansi' and the various `-std' options, use `__asm__'
instead of `asm' (*note Alternate Keywords::).

Qualifiers
..........

`volatile'
     The optional `volatile' qualifier has no effect.  All basic `asm'
     blocks are implicitly volatile.

Parameters
..........

ASSEMBLERINSTRUCTIONS
     This is a literal string that specifies the assembler code. The
     string can contain any instructions recognized by the assembler,
     including directives.  GCC does not parse the assembler
     instructions themselves and does not know what they mean or even
     whether they are valid assembler input.

     You may place multiple assembler instructions together in a single
     `asm' string, separated by the characters normally used in
     assembly code for the system. A combination that works in most
     places is a newline to break the line, plus a tab character
     (written as `\n\t').  Some assemblers allow semicolons as a line
     separator. However, note that some assembler dialects use
     semicolons to start a comment.

Remarks
.......

Using extended `asm' typically produces smaller, safer, and more
efficient code, and in most cases it is a better solution than basic
`asm'.  However, there are two situations where only basic `asm' can be
used:

   * Extended `asm' statements have to be inside a C function, so to
     write inline assembly language at file scope ("top-level"),
     outside of C functions, you must use basic `asm'.  You can use
     this technique to emit assembler directives, define assembly
     language macros that can be invoked elsewhere in the file, or
     write entire functions in assembly language.

   * Functions declared with the `naked' attribute also require basic
     `asm' (*note Function Attributes::).

 Safely accessing C data and calling functions from basic `asm' is more
complex than it may appear. To access C data, it is better to use
extended `asm'.

 Do not expect a sequence of `asm' statements to remain perfectly
consecutive after compilation. If certain instructions need to remain
consecutive in the output, put them in a single multi-instruction `asm'
statement. Note that GCC's optimizers can move `asm' statements
relative to other code, including across jumps.

 `asm' statements may not perform jumps into other `asm' statements.
GCC does not know about these jumps, and therefore cannot take account
of them when deciding how to optimize. Jumps from `asm' to C labels are
only supported in extended `asm'.

 Under certain circumstances, GCC may duplicate (or remove duplicates
of) your assembly code when optimizing. This can lead to unexpected
duplicate symbol errors during compilation if your assembly code
defines symbols or labels.

 Since GCC does not parse the ASSEMBLERINSTRUCTIONS, it has no
visibility of any symbols it references. This may result in GCC
discarding those symbols as unreferenced.

 The compiler copies the assembler instructions in a basic `asm'
verbatim to the assembly language output file, without processing
dialects or any of the `%' operators that are available with extended
`asm'. This results in minor differences between basic `asm' strings
and extended `asm' templates. For example, to refer to registers you
might use `%eax' in basic `asm' and `%%eax' in extended `asm'.

 On targets such as x86 that support multiple assembler dialects, all
basic `asm' blocks use the assembler dialect specified by the `-masm'
command-line option (*note x86 Options::).  Basic `asm' provides no
mechanism to provide different assembler strings for different dialects.

 Here is an example of basic `asm' for i386:

     /* Note that this code will not compile with -masm=intel */
     #define DebugBreak() asm("int $3")


File: llvm.info,  Node: Extended Asm,  Next: Constraints,  Prev: Basic Asm,  Up: Using Assembly Language with C

6.43.2 Extended Asm - Assembler Instructions with C Expression Operands
-----------------------------------------------------------------------

With extended `asm' you can read and write C variables from assembler
and perform jumps from assembler code to C labels.  Extended `asm'
syntax uses colons (`:') to delimit the operand parameters after the
assembler template:

     asm [volatile] ( ASSEMBLERTEMPLATE
                      : OUTPUTOPERANDS
                      [ : INPUTOPERANDS
                      [ : CLOBBERS ] ])

     asm [volatile] goto ( ASSEMBLERTEMPLATE
                           :
                           : INPUTOPERANDS
                           : CLOBBERS
                           : GOTOLABELS)

 The `asm' keyword is a GNU extension.  When writing code that can be
compiled with `-ansi' and the various `-std' options, use `__asm__'
instead of `asm' (*note Alternate Keywords::).

Qualifiers
..........

`volatile'
     The typical use of extended `asm' statements is to manipulate input
     values to produce output values. However, your `asm' statements may
     also produce side effects. If so, you may need to use the
     `volatile' qualifier to disable certain optimizations. *Note
     Volatile::.

`goto'
     This qualifier informs the compiler that the `asm' statement may
     perform a jump to one of the labels listed in the GOTOLABELS.
     *Note GotoLabels::.

Parameters
..........

ASSEMBLERTEMPLATE
     This is a literal string that is the template for the assembler
     code. It is a combination of fixed text and tokens that refer to
     the input, output, and goto parameters. *Note AssemblerTemplate::.

OUTPUTOPERANDS
     A comma-separated list of the C variables modified by the
     instructions in the ASSEMBLERTEMPLATE.  An empty list is
     permitted.  *Note OutputOperands::.

INPUTOPERANDS
     A comma-separated list of C expressions read by the instructions
     in the ASSEMBLERTEMPLATE.  An empty list is permitted.  *Note
     InputOperands::.

CLOBBERS
     A comma-separated list of registers or other values changed by the
     ASSEMBLERTEMPLATE, beyond those listed as outputs.  An empty list
     is permitted.  *Note Clobbers::.

GOTOLABELS
     When you are using the `goto' form of `asm', this section contains
     the list of all C labels to which the code in the
     ASSEMBLERTEMPLATE may jump.  *Note GotoLabels::.

     `asm' statements may not perform jumps into other `asm' statements,
     only to the listed GOTOLABELS.  GCC's optimizers do not know about
     other jumps; therefore they cannot take account of them when
     deciding how to optimize.

 The total number of input + output + goto operands is limited to 30.

Remarks
.......

The `asm' statement allows you to include assembly instructions directly
within C code. This may help you to maximize performance in
time-sensitive code or to access assembly instructions that are not
readily available to C programs.

 Note that extended `asm' statements must be inside a function. Only
basic `asm' may be outside functions (*note Basic Asm::).  Functions
declared with the `naked' attribute also require basic `asm' (*note
Function Attributes::).

 While the uses of `asm' are many and varied, it may help to think of an
`asm' statement as a series of low-level instructions that convert input
parameters to output parameters. So a simple (if not particularly
useful) example for i386 using `asm' might look like this:

     int src = 1;
     int dst;

     asm ("mov %1, %0\n\t"
         "add $1, %0"
         : "=r" (dst)
         : "r" (src));

     printf("%d\n", dst);

 This code copies `src' to `dst' and add 1 to `dst'.

6.43.2.1 Volatile
.................

GCC's optimizers sometimes discard `asm' statements if they determine
there is no need for the output variables. Also, the optimizers may move
code out of loops if they believe that the code will always return the
same result (i.e. none of its input values change between calls). Using
the `volatile' qualifier disables these optimizations. `asm' statements
that have no output operands, including `asm goto' statements, are
implicitly volatile.

 This i386 code demonstrates a case that does not use (or require) the
`volatile' qualifier. If it is performing assertion checking, this code
uses `asm' to perform the validation. Otherwise, `dwRes' is
unreferenced by any code. As a result, the optimizers can discard the
`asm' statement, which in turn removes the need for the entire
`DoCheck' routine. By omitting the `volatile' qualifier when it isn't
needed you allow the optimizers to produce the most efficient code
possible.

     void DoCheck(uint32_t dwSomeValue)
     {
        uint32_t dwRes;

        // Assumes dwSomeValue is not zero.
        asm ("bsfl %1,%0"
          : "=r" (dwRes)
          : "r" (dwSomeValue)
          : "cc");

        assert(dwRes > 3);
     }

 The next example shows a case where the optimizers can recognize that
the input (`dwSomeValue') never changes during the execution of the
function and can therefore move the `asm' outside the loop to produce
more efficient code.  Again, using `volatile' disables this type of
optimization.

     void do_print(uint32_t dwSomeValue)
     {
        uint32_t dwRes;

        for (uint32_t x=0; x < 5; x++)
        {
           // Assumes dwSomeValue is not zero.
           asm ("bsfl %1,%0"
             : "=r" (dwRes)
             : "r" (dwSomeValue)
             : "cc");

           printf("%u: %u %u\n", x, dwSomeValue, dwRes);
        }
     }

 The following example demonstrates a case where you need to use the
`volatile' qualifier.  It uses the x86 `rdtsc' instruction, which reads
the computer's time-stamp counter. Without the `volatile' qualifier,
the optimizers might assume that the `asm' block will always return the
same value and therefore optimize away the second call.

     uint64_t msr;

     asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
             "shl $32, %%rdx\n\t"  // Shift the upper bits left.
             "or %%rdx, %0"        // 'Or' in the lower bits.
             : "=a" (msr)
             :
             : "rdx");

     printf("msr: %llx\n", msr);

     // Do other work...

     // Reprint the timestamp
     asm volatile ( "rdtsc\n\t"    // Returns the time in EDX:EAX.
             "shl $32, %%rdx\n\t"  // Shift the upper bits left.
             "or %%rdx, %0"        // 'Or' in the lower bits.
             : "=a" (msr)
             :
             : "rdx");

     printf("msr: %llx\n", msr);

 GCC's optimizers do not treat this code like the non-volatile code in
the earlier examples. They do not move it out of loops or omit it on the
assumption that the result from a previous call is still valid.

 Note that the compiler can move even volatile `asm' instructions
relative to other code, including across jump instructions. For
example, on many targets there is a system register that controls the
rounding mode of floating-point operations. Setting it with a volatile
`asm', as in the following PowerPC example, does not work reliably.

     asm volatile("mtfsf 255, %0" : : "f" (fpenv));
     sum = x + y;

 The compiler may move the addition back before the volatile `asm'. To
make it work as expected, add an artificial dependency to the `asm' by
referencing a variable in the subsequent code, for example:

     asm volatile ("mtfsf 255,%1" : "=X" (sum) : "f" (fpenv));
     sum = x + y;

 Under certain circumstances, GCC may duplicate (or remove duplicates
of) your assembly code when optimizing. This can lead to unexpected
duplicate symbol errors during compilation if your asm code defines
symbols or labels.  Using `%=' (*note AssemblerTemplate::) may help
resolve this problem.

6.43.2.2 Assembler Template
...........................

An assembler template is a literal string containing assembler
instructions.  The compiler replaces tokens in the template that refer
to inputs, outputs, and goto labels, and then outputs the resulting
string to the assembler. The string can contain any instructions
recognized by the assembler, including directives. GCC does not parse
the assembler instructions themselves and does not know what they mean
or even whether they are valid assembler input. However, it does count
the statements (*note Size of an asm::).

 You may place multiple assembler instructions together in a single
`asm' string, separated by the characters normally used in assembly
code for the system. A combination that works in most places is a
newline to break the line, plus a tab character to move to the
instruction field (written as `\n\t').  Some assemblers allow
semicolons as a line separator. However, note that some assembler
dialects use semicolons to start a comment.

 Do not expect a sequence of `asm' statements to remain perfectly
consecutive after compilation, even when you are using the `volatile'
qualifier. If certain instructions need to remain consecutive in the
output, put them in a single multi-instruction asm statement.

 Accessing data from C programs without using input/output operands
(such as by using global symbols directly from the assembler template)
may not work as expected. Similarly, calling functions directly from an
assembler template requires a detailed understanding of the target
assembler and ABI.

 Since GCC does not parse the assembler template, it has no visibility
of any symbols it references. This may result in GCC discarding those
symbols as unreferenced unless they are also listed as input, output,
or goto operands.

Special format strings
......................

In addition to the tokens described by the input, output, and goto
operands, these tokens have special meanings in the assembler template:

`%%'
     Outputs a single `%' into the assembler code.

`%='
     Outputs a number that is unique to each instance of the `asm'
     statement in the entire compilation. This option is useful when
     creating local labels and referring to them multiple times in a
     single template that generates multiple assembler instructions.

`%{'
`%|'
`%}'
     Outputs `{', `|', and `}' characters (respectively) into the
     assembler code.  When unescaped, these characters have special
     meaning to indicate multiple assembler dialects, as described
     below.

Multiple assembler dialects in `asm' templates
..............................................

On targets such as x86, GCC supports multiple assembler dialects.  The
`-masm' option controls which dialect GCC uses as its default for
inline assembler. The target-specific documentation for the `-masm'
option contains the list of supported dialects, as well as the default
dialect if the option is not specified. This information may be
important to understand, since assembler code that works correctly when
compiled using one dialect will likely fail if compiled using another.
*Note x86 Options::.

 If your code needs to support multiple assembler dialects (for
example, if you are writing public headers that need to support a
variety of compilation options), use constructs of this form:

     { dialect0 | dialect1 | dialect2... }

 This construct outputs `dialect0' when using dialect #0 to compile the
code, `dialect1' for dialect #1, etc. If there are fewer alternatives
within the braces than the number of dialects the compiler supports,
the construct outputs nothing.

 For example, if an x86 compiler supports two dialects (`att',
`intel'), an assembler template such as this:

     "bt{l %[Offset],%[Base] | %[Base],%[Offset]}; jc %l2"

is equivalent to one of

     "btl %[Offset],%[Base] ; jc %l2"   /* att dialect */
     "bt %[Base],%[Offset]; jc %l2"     /* intel dialect */

 Using that same compiler, this code:

     "xchg{l}\t{%%}ebx, %1"

corresponds to either

     "xchgl\t%%ebx, %1"                 /* att dialect */
     "xchg\tebx, %1"                    /* intel dialect */

 There is no support for nesting dialect alternatives.

6.43.2.3 Output Operands
........................

An `asm' statement has zero or more output operands indicating the names
of C variables modified by the assembler code.

 In this i386 example, `old' (referred to in the template string as
`%0') and `*Base' (as `%1') are outputs and `Offset' (`%2') is an input:

     bool old;

     __asm__ ("btsl %2,%1\n\t" // Turn on zero-based bit #Offset in Base.
              "sbb %0,%0"      // Use the CF to calculate old.
        : "=r" (old), "+rm" (*Base)
        : "Ir" (Offset)
        : "cc");

     return old;

 Operands are separated by commas.  Each operand has this format:

     [ [ASMSYMBOLICNAME] ] CONSTRAINT (CVARIABLENAME)

ASMSYMBOLICNAME
     Specifies a symbolic name for the operand.  Reference the name in
     the assembler template by enclosing it in square brackets (i.e.
     `%[Value]'). The scope of the name is the `asm' statement that
     contains the definition. Any valid C variable name is acceptable,
     including names already defined in the surrounding code. No two
     operands within the same `asm' statement can use the same symbolic
     name.

     When not using an ASMSYMBOLICNAME, use the (zero-based) position
     of the operand in the list of operands in the assembler template.
     For example if there are three output operands, use `%0' in the
     template to refer to the first, `%1' for the second, and `%2' for
     the third.

CONSTRAINT
     A string constant specifying constraints on the placement of the
     operand; *Note Constraints::, for details.

     Output constraints must begin with either `=' (a variable
     overwriting an existing value) or `+' (when reading and writing).
     When using `=', do not assume the location contains the existing
     value on entry to the `asm', except when the operand is tied to an
     input; *note Input Operands: InputOperands.

     After the prefix, there must be one or more additional constraints
     (*note Constraints::) that describe where the value resides. Common
     constraints include `r' for register and `m' for memory.  When you
     list more than one possible location (for example, `"=rm"'), the
     compiler chooses the most efficient one based on the current
     context.  If you list as many alternates as the `asm' statement
     allows, you permit the optimizers to produce the best possible
     code.  If you must use a specific register, but your Machine
     Constraints do not provide sufficient control to select the
     specific register you want, local register variables may provide a
     solution (*note Local Reg Vars::).

CVARIABLENAME
     Specifies a C lvalue expression to hold the output, typically a
     variable name.  The enclosing parentheses are a required part of
     the syntax.


 When the compiler selects the registers to use to represent the output
operands, it does not use any of the clobbered registers (*note
Clobbers::).

 Output operand expressions must be lvalues. The compiler cannot check
whether the operands have data types that are reasonable for the
instruction being executed. For output expressions that are not
directly addressable (for example a bit-field), the constraint must
allow a register. In that case, GCC uses the register as the output of
the `asm', and then stores that register into the output.

 Operands using the `+' constraint modifier count as two operands (that
is, both as input and output) towards the total maximum of 30 operands
per `asm' statement.

 Use the `&' constraint modifier (*note Modifiers::) on all output
operands that must not overlap an input.  Otherwise, GCC may allocate
the output operand in the same register as an unrelated input operand,
on the assumption that the assembler code consumes its inputs before
producing outputs. This assumption may be false if the assembler code
actually consists of more than one instruction.

 The same problem can occur if one output parameter (A) allows a
register constraint and another output parameter (B) allows a memory
constraint.  The code generated by GCC to access the memory address in
B can contain registers which _might_ be shared by A, and GCC considers
those registers to be inputs to the asm. As above, GCC assumes that
such input registers are consumed before any outputs are written. This
assumption may result in incorrect behavior if the asm writes to A
before using B. Combining the `&' modifier with the register constraint
on A ensures that modifying A does not affect the address referenced by
B. Otherwise, the location of B is undefined if A is modified before
using B.

 `asm' supports operand modifiers on operands (for example `%k2'
instead of simply `%2'). Typically these qualifiers are hardware
dependent. The list of supported modifiers for x86 is found at *note
x86 Operand modifiers: x86Operandmodifiers.

 If the C code that follows the `asm' makes no use of any of the output
operands, use `volatile' for the `asm' statement to prevent the
optimizers from discarding the `asm' statement as unneeded (see *note
Volatile::).

 This code makes no use of the optional ASMSYMBOLICNAME. Therefore it
references the first output operand as `%0' (were there a second, it
would be `%1', etc). The number of the first input operand is one
greater than that of the last output operand. In this i386 example,
that makes `Mask' referenced as `%1':

     uint32_t Mask = 1234;
     uint32_t Index;

       asm ("bsfl %1, %0"
          : "=r" (Index)
          : "r" (Mask)
          : "cc");

 That code overwrites the variable `Index' (`='), placing the value in
a register (`r').  Using the generic `r' constraint instead of a
constraint for a specific register allows the compiler to pick the
register to use, which can result in more efficient code. This may not
be possible if an assembler instruction requires a specific register.

 The following i386 example uses the ASMSYMBOLICNAME syntax.  It
produces the same result as the code above, but some may consider it
more readable or more maintainable since reordering index numbers is
not necessary when adding or removing operands. The names `aIndex' and
`aMask' are only used in this example to emphasize which names get used
where.  It is acceptable to reuse the names `Index' and `Mask'.

     uint32_t Mask = 1234;
     uint32_t Index;

       asm ("bsfl %[aMask], %[aIndex]"
          : [aIndex] "=r" (Index)
          : [aMask] "r" (Mask)
          : "cc");

 Here are some more examples of output operands.

     uint32_t c = 1;
     uint32_t d;
     uint32_t *e = &c;

     asm ("mov %[e], %[d]"
        : [d] "=rm" (d)
        : [e] "rm" (*e));

 Here, `d' may either be in a register or in memory. Since the compiler
might already have the current value of the `uint32_t' location pointed
to by `e' in a register, you can enable it to choose the best location
for `d' by specifying both constraints.

6.43.2.4 Input Operands
.......................

Input operands make values from C variables and expressions available
to the assembly code.

 Operands are separated by commas.  Each operand has this format:

     [ [ASMSYMBOLICNAME] ] CONSTRAINT (CEXPRESSION)

ASMSYMBOLICNAME
     Specifies a symbolic name for the operand.  Reference the name in
     the assembler template by enclosing it in square brackets (i.e.
     `%[Value]'). The scope of the name is the `asm' statement that
     contains the definition. Any valid C variable name is acceptable,
     including names already defined in the surrounding code. No two
     operands within the same `asm' statement can use the same symbolic
     name.

     When not using an ASMSYMBOLICNAME, use the (zero-based) position
     of the operand in the list of operands in the assembler template.
     For example if there are two output operands and three inputs, use
     `%2' in the template to refer to the first input operand, `%3' for
     the second, and `%4' for the third.

CONSTRAINT
     A string constant specifying constraints on the placement of the
     operand; *Note Constraints::, for details.

     Input constraint strings may not begin with either `=' or `+'.
     When you list more than one possible location (for example,
     `"irm"'), the compiler chooses the most efficient one based on the
     current context.  If you must use a specific register, but your
     Machine Constraints do not provide sufficient control to select
     the specific register you want, local register variables may
     provide a solution (*note Local Reg Vars::).

     Input constraints can also be digits (for example, `"0"'). This
     indicates that the specified input must be in the same place as
     the output constraint at the (zero-based) index in the output
     constraint list.  When using ASMSYMBOLICNAME syntax for the output
     operands, you may use these names (enclosed in brackets `[]')
     instead of digits.

CEXPRESSION
     This is the C variable or expression being passed to the `asm'
     statement as input.  The enclosing parentheses are a required part
     of the syntax.


 When the compiler selects the registers to use to represent the input
operands, it does not use any of the clobbered registers (*note
Clobbers::).

 If there are no output operands but there are input operands, place two
consecutive colons where the output operands would go:

     __asm__ ("some instructions"
        : /* No outputs. */
        : "r" (Offset / 8));

 *Warning:* Do _not_ modify the contents of input-only operands (except
for inputs tied to outputs). The compiler assumes that on exit from the
`asm' statement these operands contain the same values as they had
before executing the statement.  It is _not_ possible to use clobbers
to inform the compiler that the values in these inputs are changing. One
common work-around is to tie the changing input variable to an output
variable that never gets used. Note, however, that if the code that
follows the `asm' statement makes no use of any of the output operands,
the GCC optimizers may discard the `asm' statement as unneeded (see
*note Volatile::).

 `asm' supports operand modifiers on operands (for example `%k2'
instead of simply `%2'). Typically these qualifiers are hardware
dependent. The list of supported modifiers for x86 is found at *note
x86 Operand modifiers: x86Operandmodifiers.

 In this example using the fictitious `combine' instruction, the
constraint `"0"' for input operand 1 says that it must occupy the same
location as output operand 0. Only input operands may use numbers in
constraints, and they must each refer to an output operand. Only a
number (or the symbolic assembler name) in the constraint can guarantee
that one operand is in the same place as another. The mere fact that
`foo' is the value of both operands is not enough to guarantee that
they are in the same place in the generated assembler code.

     asm ("combine %2, %0"
        : "=r" (foo)
        : "0" (foo), "g" (bar));

 Here is an example using symbolic names.

     asm ("cmoveq %1, %2, %[result]"
        : [result] "=r"(result)
        : "r" (test), "r" (new), "[result]" (old));

6.43.2.5 Clobbers
.................

While the compiler is aware of changes to entries listed in the output
operands, the inline `asm' code may modify more than just the outputs.
For example, calculations may require additional registers, or the
processor may overwrite a register as a side effect of a particular
assembler instruction.  In order to inform the compiler of these
changes, list them in the clobber list. Clobber list items are either
register names or the special clobbers (listed below). Each clobber
list item is a string constant enclosed in double quotes and separated
by commas.

 Clobber descriptions may not in any way overlap with an input or output
operand. For example, you may not have an operand describing a register
class with one member when listing that register in the clobber list.
Variables declared to live in specific registers (*note Explicit Reg
Vars::) and used as `asm' input or output operands must have no part
mentioned in the clobber description. In particular, there is no way to
specify that input operands get modified without also specifying them
as output operands.

 When the compiler selects which registers to use to represent input
and output operands, it does not use any of the clobbered registers. As
a result, clobbered registers are available for any use in the
assembler code.

 Here is a realistic example for the VAX showing the use of clobbered
registers:

     asm volatile ("movc3 %0, %1, %2"
                        : /* No outputs. */
                        : "g" (from), "g" (to), "g" (count)
                        : "r0", "r1", "r2", "r3", "r4", "r5");

 Also, there are two special clobber arguments:

`"cc"'
     The `"cc"' clobber indicates that the assembler code modifies the
     flags register. On some machines, GCC represents the condition
     codes as a specific hardware register; `"cc"' serves to name this
     register.  On other machines, condition code handling is different,
     and specifying `"cc"' has no effect. But it is valid no matter
     what the target.

`"memory"'
     The `"memory"' clobber tells the compiler that the assembly code
     performs memory reads or writes to items other than those listed
     in the input and output operands (for example, accessing the
     memory pointed to by one of the input parameters). To ensure
     memory contains correct values, GCC may need to flush specific
     register values to memory before executing the `asm'. Further, the
     compiler does not assume that any values read from memory before an
     `asm' remain unchanged after that `asm'; it reloads them as needed.
     Using the `"memory"' clobber effectively forms a read/write memory
     barrier for the compiler.

     Note that this clobber does not prevent the _processor_ from doing
     speculative reads past the `asm' statement. To prevent that, you
     need processor-specific fence instructions.

     Flushing registers to memory has performance implications and may
     be an issue for time-sensitive code.  You can use a trick to avoid
     this if the size of the memory being accessed is known at compile
     time. For example, if accessing ten bytes of a string, use a
     memory input like:

     `{"m"( ({ struct { char x[10]; } *p = (void *)ptr ; *p; }) )}'.


6.43.2.6 Goto Labels
....................

`asm goto' allows assembly code to jump to one or more C labels.  The
GOTOLABELS section in an `asm goto' statement contains a comma-separated
list of all C labels to which the assembler code may jump. GCC assumes
that `asm' execution falls through to the next statement (if this is
not the case, consider using the `__builtin_unreachable' intrinsic
after the `asm' statement). Optimization of `asm goto' may be improved
by using the `hot' and `cold' label attributes (*note Label
Attributes::).

 An `asm goto' statement cannot have outputs.  This is due to an
internal restriction of the compiler: control transfer instructions
cannot have outputs.  If the assembler code does modify anything, use
the `"memory"' clobber to force the optimizers to flush all register
values to memory and reload them if necessary after the `asm' statement.

 Also note that an `asm goto' statement is always implicitly considered
volatile.

 To reference a label in the assembler template, prefix it with `%l'
(lowercase `L') followed by its (zero-based) position in GOTOLABELS
plus the number of input operands.  For example, if the `asm' has three
inputs and references two labels, refer to the first label as `%l3' and
the second as `%l4').

 Alternately, you can reference labels using the actual C label name
enclosed in brackets.  For example, to reference a label named `carry',
you can use `%l[carry]'.  The label must still be listed in the
GOTOLABELS section when using this approach.

 Here is an example of `asm goto' for i386:

     asm goto (
         "btl %1, %0\n\t"
         "jc %l2"
         : /* No outputs. */
         : "r" (p1), "r" (p2)
         : "cc"
         : carry);

     return 0;

     carry:
     return 1;

 The following example shows an `asm goto' that uses a memory clobber.

     int frob(int x)
     {
       int y;
       asm goto ("frob %%r5, %1; jc %l[error]; mov (%2), %%r5"
                 : /* No outputs. */
                 : "r"(x), "r"(&y)
                 : "r5", "memory"
                 : error);
       return y;
     error:
       return -1;
     }

6.43.2.7 x86 Operand Modifiers
..............................

References to input, output, and goto operands in the assembler template
of extended `asm' statements can use modifiers to affect the way the
operands are formatted in the code output to the assembler. For
example, the following code uses the `h' and `b' modifiers for x86:

     uint16_t  num;
     asm volatile ("xchg %h0, %b0" : "+a" (num) );

These modifiers generate this assembler code:

     xchg %ah, %al

 The rest of this discussion uses the following code for illustrative
purposes.

     int main()
     {
        int iInt = 1;

     top:

        asm volatile goto ("some assembler instructions here"
        : /* No outputs. */
        : "q" (iInt), "X" (sizeof(unsigned char) + 1)
        : /* No clobbers. */
        : top);
     }

 With no modifiers, this is what the output from the operands would be
for the `att' and `intel' dialects of assembler:

Operand   masm=att   masm=intel
--------------------------------------- 
`%0'      `%eax'     `eax'
`%1'      `$2'       `2'
`%2'      `$.L2'     `OFFSET FLAT:.L2'

 The table below shows the list of supported modifiers and their
effects.

Modifier   Description                                  Operand   `masm=att' `masm=intel'
------------------------------------------------------------------------------------------ 
`z'        Print the opcode suffix for the size of the  `%z0'     `l'        
           current integer operand (one of                                   
           `b'/`w'/`l'/`q').                                                 
`b'        Print the QImode name of the register.       `%b0'     `%al'      `al'
`h'        Print the QImode name for a "high" register. `%h0'     `%ah'      `ah'
`w'        Print the HImode name of the register.       `%w0'     `%ax'      `ax'
`k'        Print the SImode name of the register.       `%k0'     `%eax'     `eax'
`q'        Print the DImode name of the register.       `%q0'     `%rax'     `rax'
`l'        Print the label name with no punctuation.    `%l2'     `.L2'      `.L2'
`c'        Require a constant operand and print the     `%c1'     `2'        `2'
           constant expression with no punctuation.                          

6.43.2.8 x86 Floating-Point `asm' Operands
..........................................

On x86 targets, there are several rules on the usage of stack-like
registers in the operands of an `asm'.  These rules apply only to the
operands that are stack-like registers:

  1. Given a set of input registers that die in an `asm', it is
     necessary to know which are implicitly popped by the `asm', and
     which must be explicitly popped by GCC.

     An input register that is implicitly popped by the `asm' must be
     explicitly clobbered, unless it is constrained to match an output
     operand.

  2. For any input register that is implicitly popped by an `asm', it is
     necessary to know how to adjust the stack to compensate for the
     pop.  If any non-popped input is closer to the top of the
     reg-stack than the implicitly popped register, it would not be
     possible to know what the stack looked like--it's not clear how
     the rest of the stack "slides up".

     All implicitly popped input registers must be closer to the top of
     the reg-stack than any input that is not implicitly popped.

     It is possible that if an input dies in an `asm', the compiler
     might use the input register for an output reload.  Consider this
     example:

          asm ("foo" : "=t" (a) : "f" (b));

     This code says that input `b' is not popped by the `asm', and that
     the `asm' pushes a result onto the reg-stack, i.e., the stack is
     one deeper after the `asm' than it was before.  But, it is
     possible that reload may think that it can use the same register
     for both the input and the output.

     To prevent this from happening, if any input operand uses the `f'
     constraint, all output register constraints must use the `&'
     early-clobber modifier.

     The example above is correctly written as:

          asm ("foo" : "=&t" (a) : "f" (b));

  3. Some operands need to be in particular places on the stack.  All
     output operands fall in this category--GCC has no other way to
     know which registers the outputs appear in unless you indicate
     this in the constraints.

     Output operands must specifically indicate which register an output
     appears in after an `asm'.  `=f' is not allowed: the operand
     constraints must select a class with a single register.

  4. Output operands may not be "inserted" between existing stack
     registers.  Since no 387 opcode uses a read/write operand, all
     output operands are dead before the `asm', and are pushed by the
     `asm'.  It makes no sense to push anywhere but the top of the
     reg-stack.

     Output operands must start at the top of the reg-stack: output
     operands may not "skip" a register.

  5. Some `asm' statements may need extra stack space for internal
     calculations.  This can be guaranteed by clobbering stack registers
     unrelated to the inputs and outputs.


 This `asm' takes one input, which is internally popped, and produces
two outputs.

     asm ("fsincos" : "=t" (cos), "=u" (sin) : "0" (inp));

This `asm' takes two inputs, which are popped by the `fyl2xp1' opcode,
and replaces them with one output.  The `st(1)' clobber is necessary
for the compiler to know that `fyl2xp1' pops both inputs.

     asm ("fyl2xp1" : "=t" (result) : "0" (x), "u" (y) : "st(1)");

